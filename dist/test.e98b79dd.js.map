{"version":3,"sources":["node_modules/regenerator-runtime/runtime.js","node_modules/codemirror/lib/codemirror.js","../src/utils.ts","node_modules/process/browser.js","node_modules/path-browserify/index.js","node_modules/onigasm/lib/onigasm.js","../src/onigasmH.ts","node_modules/onigasm/node_modules/yallist/iterator.js","node_modules/onigasm/node_modules/yallist/yallist.js","node_modules/onigasm/node_modules/lru-cache/index.js","../src/OnigString.ts","../src/OnigScanner.ts","../src/OnigRegExp.ts","../src/index.ts","../src/rule.ts","../src/matcher.ts","../src/debug.ts","../src/grammar.ts","../src/registry.ts","node_modules/fast-plist/release/src/main.js","../src/json.ts","../src/grammarReader.ts","../src/theme.ts","../src/main.ts","node_modules/p-cancelable/index.js","node_modules/pseudomap/pseudomap.js","node_modules/pseudomap/map.js","node_modules/util/support/isBufferBrowser.js","node_modules/util/node_modules/inherits/inherits_browser.js","node_modules/util/util.js","node_modules/yallist/yallist.js","node_modules/lru-cache/index.js","../src/tmToCm.ts","../src/Highlighter.ts","test.js"],"names":["process","module","exports","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","setTimeout","e","clearTimeout","runTimeout","fun","call","runClearTimeout","marker","queue","draining","currentQueue","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","nextTick","args","Array","arguments","i","push","Item","array","prototype","apply","title","env","argv","version","versions","noop","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","CancelError","reason","PCancelable","executor","_cancelHandlers","_isPending","_isCanceled","_rejectOnCancel","_promise","Promise","resolve","reject","_reject","onResolve","value","onReject","error","onCancel","handler","Object","defineProperties","shouldReject","get","set","bool","onFulfilled","onRejected","then","catch","onFinally","finally","userFn","setPrototypeOf","default","Map","require","getOwnPropertyDescriptors","obj","keys","descriptors","getOwnPropertyDescriptor","formatRegExp","format","f","isString","objects","inspect","join","str","String","replace","x","Number","JSON","stringify","_","isNull","isObject","deprecate","fn","msg","noDeprecation","warned","deprecated","throwDeprecation","traceDeprecation","console","trace","debugs","debugEnviron","debuglog","isUndefined","toUpperCase","RegExp","test","pid","opts","ctx","seen","stylize","stylizeNoColor","depth","colors","isBoolean","showHidden","_extend","customInspect","stylizeWithColor","formatValue","styles","styleType","style","arrayToHash","hash","forEach","val","idx","recurseTimes","isFunction","constructor","ret","primitive","formatPrimitive","visibleKeys","getOwnPropertyNames","isError","indexOf","formatError","isRegExp","toString","isDate","Date","base","braces","isArray","n","toUTCString","output","formatArray","map","key","formatProperty","pop","reduceToSingleString","simple","isNumber","l","hasOwnProperty","match","desc","split","line","substr","numLinesEst","reduce","prev","cur","ar","arg","isNullOrUndefined","isSymbol","re","objectToString","d","isPrimitive","isBuffer","o","pad","months","timestamp","time","getHours","getMinutes","getSeconds","getDate","getMonth","log","inherits","origin","add","prop","kCustomPromisifiedSymbol","Symbol","undefined","promisify","original","TypeError","defineProperty","enumerable","writable","configurable","promiseResolve","promiseReject","promise","err","getPrototypeOf","custom","callbackifyOnRejected","cb","newReason","callbackify","callbackified","maybeCb","self","rej","LRUCache","util","Yallist","hasSymbol","makeSymbol","MAX","LENGTH","LENGTH_CALCULATOR","ALLOW_STALE","MAX_AGE","DISPOSE","NO_DISPOSE_ON_SET","LRU_LIST","CACHE","naiveLength","options","max","Infinity","lc","stale","maxAge","dispose","noDisposeOnSet","reset","mL","trim","allowStale","mA","lC","hit","rforEach","thisp","walker","tail","forEachStep","node","isStale","del","head","next","toArray","k","values","dump","v","now","filter","h","dumpLru","extras","as","didFirst","item","has","Entry","unshift","peek","load","arr","expiresAt","prune","doUse","unshiftNode","diff","delete","removeNode","scopeName","fetch","json","editor","CodeMirror","fromTextArea","document","getElementById","lineNumbers","mode"],"mappings":"AmBAA,AYAA,AtBAA,AFAA,ACAA,AgBAA,AEAA,ADAA,AGAA,ADAA,AGAA,IJAI,kBAAiC,WAAjC,IACA,4BAAqC,MADzC,EAEE,YAA6B,MAA7B;ATFF,AIAA,ADAA,AGAA,ARAA,AGAA,AJAA,AQAA,ApBAA,AiBCA,AdDA,AICA,AFAA,ACAA,AJDA,ADAA,AsBCA,AzBDA,A4BCA,ADAA,AEDA,ACCA;AlBDA,ADAA,ADGA,AMHA,AHAA,APIA,A0BJA,A/BAA,AkBEA,AYAAC,A1BDA,AICA,AFAA,ACAA,AJDA,ADAA,AuBGA,ADFA,AzBDA,A4BCA,ADAA,AEDA,ACCA,AIFA,I/BCID,AuBGA,EhBDE,AJCA,AyBFA,CAACE,I5BDI,AuBGA2F,GKFX,A5BDc5F,AuBGV,EhBDY,CqBDCmP,ELEE,CvBHC,CAAClP,I4BCrB,CzBE0B,CyBA1B,C5BHc,CGGe,AoBAzB,EvBH2B,E6BDC,A7BChC,AuBGiC,EvBDjC,CGCoC,CAAC,CKJA,GEAA,EaIrC,EAA8D,EdJA,INIX,CAAC,qFAAqF,CAAC,CAAA;AMG1I,ADNA,AEIS,APQT,A0BZA,A/BAA,AkBEA,AYEA,A1BHA,AICA,AFAA,ACAA,AJDA,ADEA,AuBCED,ADFF,AzBDA,A4BCA,ADAA,AEDA,ACCA,EJEEA,EhBaE,CJLC,CMNC,EcFE,CAACC,MpBQM,CMNC,AFWA,AgBbd,GbLO,AaKU2F,GAAjB,ChBa6B,EJLN,CAAC,KAAkB,OOb3B,CAKA,EFJoB,aqBAa,MfCU,AIAA,ADAA,AGAA,ARAA,AGAA,AJAA,AQAA,ApBAA;ASA5D,AEDA,AmBGA,A/BFA,AkBEA,AdDA,AICA,AFAA,ACAA,AJDA,ADEA,AuBCC,ADFD,AzBDA,A4BCA,ADAA,AEDA,ACCA,AIHA,CRGA,GdMI,ANIA,A0BVQ,GNEL,ChB+CI,GJvCA,A0BeV,I1Bfc,OIuCK,AJvCE,CAAC,CAAC,CIuCD,CAAC,KAAK,AJvCE,EIuCA,AJvCE,GIuCC,EAAE,CJvCG,CIuCD,CJvCG,EAAE,EKZN,AEDuB;AF6B5D,AM1BA,AICA,ARAgC,AODhC,ALSA,AGTA,AIUA,AUVA,A9BEA,ADHA,AkBEA,AYCA,A1BFA,AICA,AFAA,ACAA,AJDA,ADEA,AuBCE5F,ADFF,AzBDA,A4BCA,ADAA,AEDA,ACCA,EJEEA,EKDE4F,GAAG,CzBSC,AoBRA,CAAC3F,CKDC4F,CCFE,CtBkDJ,EJvCM,CJTW,CkBFT,AdWA,AoBRd,CKDe,CCFE,ADED,CrBgDH,AJvCI,AoBRAA,EbNZ,APcc,EIuCF,CAAC,AKzCc,AbPG,CISZ,CoBRC,CNHkB,AdWjB,AoBRA,ENHmB,AWE7B,CrBgDS,AqBhD1B,CrBgD2B,CUlD8B,ALSP,ATElB,CWXA,CICI,ANQgB,ATElB,GAAG,AYXwE,GRkDzE,AgB/CV,ChB+CW,AGrDpB,AaMf,CbFwC,EPUE,CSFkE,ATElE,CIuCF,EAAE,GAAG,CAAC,CAAA;AOhDhD,AIAA,ARJA,AKOA,AjBLA,AkBEA,AdDA,AICA,AFAA,ACAA,AJDA,AsBGC,ADFD,AzBDA,A4BCA,ACDA,ACCA,AIJA,IdGC,ALSA,AOcA,AUvBG,A9BEH,IQgDG,AKzCC,ATEG,CIuCH,CAAA,CRhDG,IaOI,GAA8B,AbP3B,CAAC,CaO4B,CAAC,OTEjB,A0BXX,A9BEQ,CISI,AgBa3B,AUxBe,A9BES,CAAC,CeDqJ,EIArI,CCuB5B,EACb,WT5B4D,CS4BtC,EACtB,KAAa,EACb,SAAiB,EACjB,UAAkB,EAClB,UAAkB,0CF7B6G;AHGjI,AIDA,ARFmB,AXGnB,ADHA,AkBEA,AYAA,A1BDA,AICA,AFAA,ACAA,AJDA,ADEA,AsBDA,AzBDA,A4BCA,ACDA,ACCA,C5BCC,GkBFA,ALSA,AGCA,AcVG,ADCAuJ,A5BCAlP,GSKG,CF4CI,AK1CN,AOqBH,AS7BM,EXDD,CWCI2F,CzBUC,AgBmBN,CAAC,CF9BI,GLSG,COqBF,AS7BM,CXDF,AWCG,CXDF,ALSA,AZPjB,COiDmB,AYrBJ,CTlCR,EHuDe,CAAC,AqBlDL,CbSL,AIoBO,AS7BpB,CzBU2B,AgBmBN,ChBnBO,AyBR5B,ErBgD4B,CWlDsB,AHSzB,CRyCK,AK1CD,CAAC,CKTC,CVmDE,AJxCE,EIwCA,AOjDiB,AGFlB,AdWG,C0BXV,CtBmDU,AsBnDV,EjBSW,CAAC,CFbrB,AEasB,CFVV,IOCe,CAAC,GAAG,AdWG,GcXA,IAAI,GAAG,GAAG,GAAG,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,KAAK,CAAC,CAAC;AHIlI,AIDA,ARNA,AOIA,AlBDA,ADAA,AkBEA,AdDA,AICA,AFAA,ACAA,AJDA,ADEA,AsBDA,AzBDA,A4BCA,ACDA,ACCA,AILA,CdIC,GROG,AGEH,AiBTG,A7BEA1F,IYOC,AGCH,AIoBA,IZqBM,AQzCF,AIoBA,CPrBI,AGCH,AIoBA,GVvBS,AGEH,ATEG,GIwCD,AQzCF,GNHiB,AMGd,AhBTf,ACCD,COiDmB,CAAC,CK1CE,AOqBH,CD5Bc,ANOV,CTEI,AYDN,CZCO,AYDN,AIoBA,EZqBI,AK1CC,CL0CD,CK1CG,CENW,AFMV,CMPmB,AWF1B,CAAA,CXE4B,GfSZ,CAAC,AgBmBN,CAAC,GD5BgC,CRN9B,APeQ,EAAE,OAAO,CAAC;AUd1C,ACiBb,AJhB4C,AOU5C,AlBLA,ADHA,AkBEA,AdDA,AICA,ADAA,AJDA,AqBCA,AzBDA,A4BCA,ACDA,ACCA,GnByBG,CUxBF,ANOA,AiBTG,GhBJS,CJWL,AF4CJ,AMvDS,AKMR,AHQH,AIoBA,CZqBG,CAAA,CK1CG,CHFI,AMGN,AIoBA,CVvBO,AMGN,AIoBA,EFvBe,CLET,CbPI,CoB4BL,CVvBO,ECZZ,AOY6B,ALElB,ATEG,AgBmBN,CVvBO,AMGN,CDGc,AGNQ,CJXzB,CDaS,ATEG,AYDN,CZCO,AgBmBN,ApB5BW,CcNC,ADaR,ATEG,AYDN,AIoBA,CVvBO,AMGN,CNHM,CKMsB,CGNI,CHMF,AIX/B,CDKmC,AdIvB,CUfM,AKMhB,AWFA,C1BWY,A0BXZ,E1BWc,IUfL,AHDf,CAEqC,GOUuB,CJX1B,CCiBwB,EAAE,QDjB7C,GAAiC,KAAjC,CCiBqF,EDjB5C,ACiB8C,CDjB7C,SCiBsE,CDjBnI,CCiBqI,iBAAsD;AgBrBxM,AtBmCA,AK9Ba,AHLb,AZQA,AkBEA,AYAA,A1BDA,AICA,ADAA,AJDA,ADEA,AsBDA,AzBDA,A4BCA,ACDA,ACCA,IbYC,AGNA,AYPG,A9BEH,A6BDGkP,GfLS,CJYL,AFEA,AMdK,AKMX,ADKG,ALEH,AGCA,AIoBA,ApB5BG,CSwBI,ARxBAjP,EcWD,AcZG,CnBOC,AFEA,AKDN,AGCA,AIoBA,CJpBC,AIoBA,ApB5BG,CAAC,A6BDGyF,CdYF,AIXU,IXQH,AUHH,CLEF,ATEU,CUfX,AdMK,A6BDG,CdYF,AGNA,AEuBH,ApB5BG,A6BDG,CdYF,AFJU,CCbD,ADaE,CAAC,AGCb,AIoBA,AnB5BnB,COQ0B,AUHH,CCLc,CAAC,AHQhB,AfRM,CQwBC,CAAC,AMbH,ACHH,CRAO,AMdK,AEcX,AhBRG,A6BDP,CdYQ,AfXA,A6BD7B,CpByB6C,CWIjB,AU9BL,A9BEQ,A6BC/B,CzBQuC,AgBmBV,AU9BN,CXEuB,AfSN,EUfX,AKMmB,CXQT,EAAE,AGnBD,AOgBF,CAAC,AdIO,CUfE,AVeD,GeTS,CJWZ,CIXc,ADKb,CHMC,AGNA,CAAC,CdIQ,CeTO,AfSN,C2BpB0C,AZWnC,AfSP,CUf3B,AKMmC,GLNF,KAAjC,GAAyC,CAAC,ACiBR,EAAE,QDjBpD,ECiB8D,EAAE,iBAAiB,CAAC,CAAC;AgBrBhG,AhBsBA,AJtBA,AZQA,AkBEA,AdDA,AICA,ADAA,AJDA,ADEI,AsBDJ,AzBDA,A4BCA,ACDA,ACCA,CbYC,GNaG,ASnBH,AYPG,CXEF,GDKG,ALEH,AGCA,AIoBA,ApB5BA,ACAQ,EQwBA,EClBE,AFEA,AKDN,AGCA,AIoBA,AnB5BQxF,CQwBD,ASnBH,AFGH,AIoBA,EpB5BE,CUMO,ADkBA,ASnBH,AdIO,CMHH,AGCN,ATEU,AHTX,COQQ,AKDN,ATEU,AHTF,EiBKH,EVGK,CYoBL,CVtBO,AGCN,CbPC,CoB4BC,AU9BL,A9BEK,CUMO,AoBRZ,EZOW,ALEH,CAAC,CHDO,AFEA,AUHH,AFGH,CRAO,AUHH,ELED,AGCA,CPgBJ,ATxBK,CSwBJ,AOhBK,AIoBA,ApB5BA,CgBQC,AIoBA,ApB5BA,EaOE,CAAC,GJiBF,CAAC,EIjBO,CJiBJ,AIjBK,CJiBJ,AIjBK,CAAC,EZPjC,CSMgC,ATNtC,CSMuC,ACjBuB,CoBAhB,ArBiBN,AGCI,GJiBF,AIjBK,CHDH,ADkBD,CClBE,AFEU,AKDN,CLCO,CAAA,GCgBP,CClBE,ADkBD,CClBE,ADkBF,CClBG,CAAA;AqBhBzD,AhBmBA,AJnBA,AZQA,AkBEA,AdDA,AICA,ADAA,AJDA,ADEC,AsBDD,AzBDA,A4BCA,ACDA,ACCA,InByBI,AUxBH,ADKA,AFGA,AcVG,CdUF,AhBRA,GkBKG,AEuBH,CVtBO,AFEA,EWRY,CNOlB,AOqBG,CFvBI,AEuBH,ED5BkB,CAAC,INOf,CMPoB,AfSV,CeTW,CVwBpB,AWIK,CXJJ,CIjBG,CAAC,ATES,AgBmBN,ChBnBO,CAAC,CAAC,CKeV,AUxBqB,AWFrB,CrB0BC,AUxBqB,AfSV,A0BXZ,CXEuB,ANOnB,CAAC,ATES,CKeV,ASnBU,ALER,CJiBD,ASnBU,ALER,COqBI,CWvCiC,AlBkBnC,AOqBG,CXJJ,AMd1B,CNc2B,KEnCe,IFmCN,EAAE,GAAG,CAAC,CAAA;AsBzB3C,AhB2BA,AIzBA,ARXA,AZQA,AkBEA,AYAA,A1BDA,AICA,ADAA,AJDA,AqBCA,AzBDA,A4BCA,ACDA,ACCA,CTCC,GVwBG,ASnBH,AFIO,AImBP,AU9BG,A9BEH,A6BDGiP,CT6BF,CW9BI,ErBOI,AFGF,AUHH,AlBLA,GSwBM,ASnBH,CVGI,CAAC,AqBTA,CpByBC,ASnBE,CRAC,ADmBH,ATxBF,CaOR,AgBRY,CEDC,CbOG,CVGD,AUHE,CaPD,ArBOE,ANIE,C2BXH,AlBSZ,CHFe,AFGF,CuBVC,AFCA1B,ChBQX,AbPS,E+BFK,A3BWI,CAAC,CAAA,CIDF,ARRH,A6BDV,CrBSa,CuBVE,CDAV,CCAY,ADAZ,CDCa,CEDC,AfWnB,CeXoB,C/BEF,CgBSjC,ChBTmC,C+BFI,IFCxB,GED+B,ApBTJ,CoBSW,AfWrC,AaV+B,CEDO,GAAG,CfW7B,CeX+B,EAAE,MFC6B,GAA3F;ApB0BA,AU9BA,ARMa,AZHb,AkBEA,AYAA,A1BDA,AICA,ADAA,AJDA,ADCA,AsBAA,AzBDA,A4BCA,ACDA,ACCA,CnByBC,GsB1BG,AbOH,AEuBD,AU9BI,ADCA2B,IEDI,AvBUA,AGRK,AOKR,AFGJ,AhBRC,CCDOjP,GSMG,AFGA,CAAC,CqBTb,C7BCS,CISW,CAAC,COTE,AOKR,AdIO,CAAA,CSHR,CFNY,AOKK,EVGR,AUHU,AlBLhB,CkBKiB,AYPrB,A9BEK,CgBchB,AchBW,CtBUa,AYoBzB,EPtBqB,AZPtB,C8BD6B,CvBUC,CAAA,AKFL,AZPO,CYON,CkBRO,AlBQN,AbNA,CAAC,CAAC,I+BFU,EAAE,GZCxC,ERCoC,CAAC,UAAU,CAAA,wBDKkC;ADqBlF,AUzBA,ARAa,ACZb,AQuCA,ArB9BA,AkBEA,AdDA,AICA,ADAA,AJDA,ADCI,AsBAJ,AzBDA,A4BCA,ACDA,ACCA,CRDA,AA6BC,ELFE,CGpBF,AYPG,CV6BH,ApB3BC,G+BFO,AvBUD,AGRK,AOKR,AFGH,AfTQ,CSMD,ADoBA,GDjBG,AQAN,AfTQD,COSD,AQAN,CeVgB,CAAC,CbOX,AdIG,CHVN,CAAU,CiBMG,AFGV,CHHe,CKAH,CAAC,AFGV,CZCO,COTM,CHQJ,AJCA,CSJS,ATIT,CeTS,ARAF,AKQX,AJpBQ,CJoBD,AQAN,IRAU,CAAA,CuBVW,ADApB,CCAqB,AZEM,AWF3B,EXE6B,CYFL,EAAE,AtB2BT,CAAC,CsB3BU,EtB2BC,CUzBgB,IYFV,EAAE,CpBEjB,CoBFmB,ApBElB,AVDlC,CAAN,C8BD4D,CAAC,CAAA,YpBEL,CAAA;AI0B5D,AJxBA,ACbA,AQSa,ArBAb,AkBEA,AYDA,A1BAA,AICA,ADAA,AJDA,ADCC,AsBAD,AzBDA,A4BCA,ACDA,ACCA,IlBMI,ADoBA,ADhBA,AWTH,ADMA,AYRG,A9BEH,A6BFGiP,CEAC,ArBOA,AFIA,GWTA,AHQH,CgBpBa7N,CvBqCL,CTzBF,CISI,CAAC,AyBXb,CbUQ,CPiBO,AOjBN,AaVM,ChBOX,EJoBc,COjBL,CPiBO,AOjBN,AhBRG,CSyBG,AIpBX,AbLS,GaKN,AGGM,CAAC,GcVF,CAAA,GXEI,CPZ+B,COY7B,AHQK,CAAC,CAAC,MDiBY,AK5Bd,CJWS,CAAC,IDiByB,EAAE,ICjB1B,IDiB8C,KCjBrC;AJlBhD,AQsCA,ApB3BA,ADHA,AkBEA,AYDE8N,A1BAF,AICA,ADAA,AJDA,AqBCA,AzBDA,A4BCA,ACDA,ACCA,C5BCC,C6BFCA,EnBQE,ADmBA,ADfA,AOeH,Ae3BG,IrB2BI,ADfO,AWVb,ADMA,CaTS,AtB4BF,AMAH,AXhBG,CAAC,EKgBE,AOjBT,AaVS,CpB2BC,AMAH,CNAG,AMAF,CIzBW,AUFP,CbUR,CREiB,AOeV,CAAC,AGnBH,CAAC,CHmBI,AIzBU,ANIb,CMJc,EJyBR,AGnBH,AFEH,CEFI,CEqBO,AS7BArE,Cd2BF,ACjBN,EHJK,AOuBc,AU7BnB,ADAF,CXQQ,AYRN,CZQO,AWRM,CXQL,ALFA,AGIJ,CHJK,AGIJ,CHJK,CEqBI,AFrBH,CEqBI,AHpCqC,GOWxB,CAAC,EJyBR,ACjBP,CAAC,CDiBQ,CAAC,GAAG,AIzBU,EAAE,CJyBT,CCjBN,CDiBQ,ACjBP,CDiBQ,ACjBP,EDiBS,EAAE,AIzBU,EAAE,yBAAyB,CAAC,CAAC;APT7F,AZWA,ADJA,AkBEA,AYDI,A1BAJ,AICA,ADAA,AJDA,ADAC,AsBCD,AzBDA,A4BCA,ACDA,ACCA,InB0BI,AGnCE,AQqCL,AU7BG,CXEF,GYHM,AvBaA,AOgBN,AGpBA,AEqBG,GXFM,AoB3BA0C,CrBYC,AOgBN,AClBH,CREU,AJDA,AHXA,GiBQH,CVIO,AOgBN,AGpBA,AdGM,AyBXA,CEDC,AvBaA,AOgBN,AXjBM,AyBXA1C,CEDC,AfWT,CHLmB,AGKlB,AhBPS,CkBKL,AWRE,CEDK,AbSN,AWRZ,CjBRqB,AZWK,C+BJN,ChB6BL,AGpBA,AdGM,AgBkBH,CW9BI,AhB6BN,AGpBA,ALHe,ATMT,AQnBE,AQqCL,CW9BI,AbSN,CaTM,AvBaC,AJDA,EKgBT,ADfW,AYiBH,CXFP,AWEQ,CU7BP,CAAA,Cf4BO,AKCG,CLDF,AHpCQ,AQqCL,CLDF,AClBH,AJlBW,CHmCZ,AMCK,AKCG,CXFP,AMCK,AClBH,CAAC,EPiBA,CAAC,IMCS,CNDJ,AMCK,EAAE,ENDH,EAAE;AGlC1C,AbOA,AkBEA,AYDG,A1BAH,AICA,ADAA,AJDA,ADAI,AsBCJ,AzBDA,A4BCA,ACDA,ACCA,GCHE,CVID,ADMA,ANhBK,AkBQF,A9BGH,C+BJI,AbSH,CjBRM,EQ2BA,AOjBN,AImBA,ApB1BG,CgBOF,AhBPG,CgBOF,CGRiB,AHQhB,CREO,AOgBT,AXjBa,AJRA,CSwBH,CAAC,ATxBI,CSwBH,ATxBI,CQSH,AWVU,ANGtB,CJsBa,ADfA,AWVU,CVyBT,AWEN,GXFS,CUzBW,CXUT,AWVU,CPVP,CJoBD,CAAA,CIpBI,CRmBL,GeTiB,AfSd,CeTe,CAAC,GWFlB,ClBRc,AkBQd,C1BWS,AQnBM,CRmBN,CKgBL,CAAC,GMCK,CAAC,ENDA,CAAC,GAAG,AMCE,ENDA,AMCE,CNDD,CAAA,MMCS,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;AgB5BlE,AZGA,APSA,AbZA,AkBEA,AYDC,A1BAD,AICA,ADAA,AJDA,ADAQ,AsBCR,AzBDA,A4BCA,ACDA,ACCA,CGFC,AZGA,AUND,CEGE,CAAA,CbUD,AFCA,AcVG,A9BGH,CSwBI,AOjBH,EaVK,CT6BL,AnB7BU,COYH,AOgBN,AfzBG,GIQU,CJRN,CAAC,CoB0BF,AnB7BU3K,EDGL,CAAC,CIQQ,AgBkBV,CPxBR,AOwBS,ApB1BG,CIQQ,CAAA,CJRL,ECHR,CDGW,CaEX,CAAC,CbFa,CAAC,ACHO,CYKlB,CAAC,IiBLQ,A9BGQ,C8BHR,C9BGU,CAAC,CCH5B,EDG+B,ACHO,GDGJ,EAAE,CAAC,EAAE,EAAE,EaEZ,KAAK,uBAAoB,CAAC,CAAC;AkBJhE,AZJA,ApBGA,AkBEA,AYDEgP,A1BAF,AICA,ADAA,AJDA,ADAYrP,AsBCZ,AzBDA,A4BCA,ACAA,ACAA,ECDEqP,EpB2BE,AOhBI,AJUP,AkBrBG,AHCAzJ,CP4BF,CW7BI,A9BAM5F,CSQL,CFIC,AOiBN,AGpBA,AdEU,AJRV,CIQW,AJRV,CIQW,AJRV,CSwBO,ALhBG,AJRT,Ce0BC,Af1BA,A6BHM,CXSL,ALJH,ELOW,ARTN,A6BHM,CpB2BC,ASlBN,CaTO,AtB2BA,CGNJ,CJTM,AOiBN,CPjBO,CCeC,CMEL,Af1BA,ACHY,CQ2BL,ATxBN,CSwBM,CoB3BEgL,A5BAM3K,CiBSX,AlBNA,CkBMC,ANYY,AZlBZ,CAAC,A6BHP,CjBqBoB,AZlBZ,A2BFM,CnBWC,AOiBN,AGpBA,AlBNA,A6BHM,CrBYA,AOiBL,AHRoB,AZlBpB,Ce0BC,AGpBA,ASRMsE,CZ4BL,AGpBA,ANYoB,CGQnB,Cd7BhB,EWqB+C,CIVxC,AcXQ,AHCW,CfoBuB,AkBrBlC,AHCYiB,EZ4BJ,AClBlC,CDkBmC,II5BnC,IPoB+E,cepBhD,CKhBhC,GLiBE,SAASA,yBAAT,CAAmCC,GAAnC,EAAwC;AlB0B1C,AV5BA,AkBEA,AYDI,AtBCJ,ADAA,AJDA,ADAS,AsBCT,AzBDA,A4BCA,ACCI,ACDJ,AIjBA,CvB2CC,EExBE,CoBgJC,ArB3IO,AFIP,AYkBH,AU9BG,CtBYC,ARTH,ACLM,C0BIAC,EZ4BN,AGrBA,AdEM,AYAN,AJUA,AQSG,EO5BO,CTOP,AWTM,A5BAI,Cc8BT,AFzBH,ATMS,AQUN,CGSC,AHTA,AenBQnB,CjBMM,AQCb,CRDc,AMGb,CewIO,ClB9IR,AgBLSqG,EzBWE,AYAN,AWTQ,CZ4BP,AFzBH,AGMG,AaXV,AFEkBlF,CIiJoB,ArB3IO,CKsBjC,AGrBA,ANYA,CFbmC,AQClC,CdEO,AuBTT,CfmBI,AQSG,AO5BKD,CTOP,AFEA,AImBG,CJnBF,CEFC,ASPP,CTOQ,ALJH,ATMS,AuBTzB,CdGiB,AOyBM,AU9BR,CV8BS,AU9BT,GjBKM,ADgBG,AQSG,CRTF,AQSG,CVtByC,AGH9C,CAAC,AOyBM,CJnBF,EZAQ,AYAN,CAAC,CZAO;AKkB1C,AEzBA,AZJA,AkBEA,AYDG,AtBCH,ADAA,AJDA,ADAY7F,AsBCZ,AzBDA,A4BCA,ACCI,ACDJ,AIlBA,GHeE,CrBeE,AUJH,AFEA,AcXG,A9BGH,CkBMC,AFEA,CPiBI,AR5BMA,A0BEJ+F,EIiJA,ArB3IA,AEaN,AQSA,CT3BoB,AEEnB,EJuBQ,ATzBH,C+BgJI,ArB3IA,AKsBT,AXnBS,AQUN,AZlBG,CYkBF,AZlBG,CSyBI,CGPL,EmB8HQ,ArB3IA,AiBNE,CjBMF,ADoBC,AGPN,CmB8HO,CnB9HL,AQSA,AO5BQ,CZ4BV,AHTG,CXrBa,A0BExB,ChBCgC,CAAC,CVHN7F,CQ4BL,CAAgC,KqB5BrC,CnBGiC,AmBHjC,EnBGmC,MVH5C,IUGgE,yDPQ0B;AJPtG,ADJA,AkBEA,AYDC,AtBCD,ADAA,AJDA,ADAS,AsBCT,AzBDA,A8BCA,AInBA,ChCqBC,GSyBG,ASlBH,AFEA,AcZG,IpBQI,AGHN,ADgBA,AQSA,CLAC,ENFQ,CsBuHC,ArB3IA,AGHN,ATMM,AQUN,CHOO,AGPN,CHOO,CWEL,CWqHO,EbzID,ANWH,CChBC,AOyBA,CAAC,CXFoB,ASlBR,ANWX,CChBC,CkB8IO,AtBvHa,ECpBX,AEaN,EHOuC,CsBuH9B,CAAC,ArB3IA,ADoB+B,AGPrC,EHOuC,EsBuH7B,ArB3IA,AEaN,CAAC,CFbO,AoBRX,CAAA,ECmJc,AlB9IN,EAAE,CAAC,KkB8IW,EAAE,E3BxIE;AJNlD,ADLA,AkBEA,AVAA,ADAA,AJDA,ADAK,AsBCL,AzBDA,A6BCI,ACAJ,AIpBA,G/BaI,C6BMA,A7BAE,CmB8BJ,EZjBK,AmBZE,ClB2BD,AMGN,AJ7BE,AOQF,ALLA,ADgBA,GXrBWI,A0BCAsB,CjBOD,AKuBN,AF1BA,ATMM,AQUN,AXrBA,A0BCQ,CfoBP,CHOO,AE1BJ,AOQF,AjBVQ,CiBUP,ASTQ,CIkJD,AJlJZ,E3BGc,A2BHEA,CZ8BP,AF1BA,ATMM,AuBVE,CvBUD,CSNL,AbDW,C+B+IJ,AJlJEkE,CvBUD,CWoBL,CLvBO,CqB2IC,AbzIN,AdCM,A0BXX,AHCa,ClB2BD,AqB5BZ,AHCc5E,CjBOD,AQEN,CRFO,ANGA,AQUN,CFbM,ADoBC,ALjBD,CWoBJ,AJ7BE,AOQF,CAAC,ANWA,CMXC,ASTvB,ChBC0B,CoBiJK,AhBpHN,AY9BQU,CIkJD,AJlJE,EAAlC,EAAsC,EZ8BN,KAAK,ENHH,CAAC,CGPF,CAAC,EGUU,EAAE,CNHJ,CAAC,CE1BN,CAAC,EF0BS,CAAC,AGPH,CAAC,IAAI,CAAC,IHOO,CAAC,AE1BP,ACmBI,CDnBH,ACmBI,CAAC,IHOO,CAAC,CAAA,EE1BJ,EAAE,UAAU,CAAC,CAAA,GoBiJsB,CAAC,CAAA;AhCnJtG,AkBEA,AYDA,AtBCA,ADAA,AJDA,ADAQ5B,AsBCR,AzBDA,A6BCM+F,ACAN,AIrBA,IxBiCI,AUHH,AEqBA,AU/BG,A9BIH,A6BJGuJ,A5BAItP,A0BCF+F,CTSJ,EFEE,AaZG,CpB4BC,ADfQ,AGXZ,ACmBF,AQUG,ApB3BA,CUII,AVJH,C6BJIsJ,Ed+BP,AF1BA,ATMS,AQUN,AZjBQ,C+B+ID,AnB9HN,CDnBG,AXEM,CAAC,A2BHA,CAACvJ,GnBYS,AKRjB,CAAC,AgBLS,A5BAI,A0BCF,CEDD,AFCElE,CAAD,C1BDK1B,A0BCV,CdIF,AcJT,CdIU,ADgBG,AQUG,CAAC,AS/BH,CpB4BJ,AIvBE,AgBLlB,AFC6ByE,ClB2BZ,AGPK,AkBrBL,CAAA,CV+BU,CAAC,CT7BA,CAAC,AgBDM,ClB2BZ,AIvBE,AO0BM,AO9BKqB,ClB2BZ,AWGQ,ET7BC,AS6BC,CXHP,CAAC,AE1BO,ACmBF,AXrBzB,IQ4BwB,AIvBP,ADgBY,CHOJ,CIvBN,EDgBc,CAAC,ERVQ,GSNf,CJuBQ,EAAE,AE1BO,CAAC,CAAA,AgBDxB,CAAgCH,GAAhC,CdIM,CcJ+BC,CdI7B,CAAC,CAAC,CcJ+B,ClB2BZ,AkB3BalE,ClB2BZ,AkB3BW,ClB2BX,AkB3B9B,CAAvB,IZ8B6D;AhB/BnE,AkBEA,AYDA,AtBCA,ADAA,AJDA,ADAK,AsBCL,AzBDA,A6BCK,ACAL,AItBA,IdgCC,AFCO,AcZJ,A9BIH,A6BJG2N,InBQI,ADoBA,ADfA,AGXJ,ACmBF,AQUA,CP1BC,AbDG,C6BJI,CXWF,CawII,AvBtIA,AOkBT,AXpBS,AQUN,CFbO,AFKA,AIQN,AZjBG,A6BJGF,CpB4BC,CE1BH,AS6BF,CWoHO,ArB3IA,AVJH,C+B+II,AvBtIA,CAAC,CJFC,CMHC,ADoBA,ALjBA,AJPH,CUII,AKuBT,ENHW,ATxBH,A6BJG,CXWF,AWXG,CEmJC,AbxIH,AdAG,AJPH,G+B+IM,ArB3IA,AFKA,AJFA,CMHC,CFKC,EGXF,AkBFL,CEmJU,ApBjJL,APSK,AyBXjC,CEmJiC,A3BxIA,EcAA,ANUH,AkBrBL,CdYP,AcZO,CZWU,CNUF,CIThC,EPgB8B,CAAC,ASjBQ,CAAC,ERHK,AQGH,CRHI,GMI5B,GNJkC,EAAE,EMIhB,CJSK,CITH,AJSI,QHOW,CCpBY,ADoBX,CCpBY,CAAA,AEab,CAAC,IAAI,CAAC,EITS,GPgBD,EAAE,KGPE,CAAC,CHOI,AGPH,CHOI,QAAQ,CAAC,MAAM,CAAC,CAAA;AV5BhG,AkBEA,AYDA,AtBCA,ADAA,AJDA,AqBCA,AzBDA,A8BCA,AIvBA,IrBwBA,ACmBC,AkBrBG,ADAAG,ClBEH,ACmBC,GFbM,ADoBA,AShBN,ALPA,AGOA,AImBA,ApB3BA,Ce2BC,Af3BA,CAAC,E+B+IQ,AtBvHA,ADfA,AUDN,ALPA,ATMM,AYCN,CAAC,AhBRA,CAAC,CUIO,AUuBN,CWoHO,AvBtIA,CuBsIC,AvBtIA,AUDN,ALPA,AbDA,CSwBO,CCpBC,AUuBN,AYpDH,CtB6BU,AUuBN,CS/BO,CEmJC,AlB9IN,CJuBO,ADfA,CCeC,ATxBN,A6BJMH,CEmJC,AvBtIA,AKRN,AGOA,AhBRA,CSwBO,ADfD,AQDL,CHPC,CbDC,CAAC,GAAG,CgBQC,AhBRA,CgBQC,AhBRA,A6BJM,C7BIL,A6BJM,GEmJL,CAAC,ADnJH,CZYQ,AYZR,EpBQc,AQIJ,AcjCnB,CtB6BwB,AMIN,CAAC,GAAG,ENJQ,CNGC,CMHC,EmBRjB,CbYc,AaZhD,CbYiD,CNJO,AsB7B9C,CDwKuC,ArB3IQ,AsB9BzD,CDyKkD,ArB3IO,KqB2IF,CAAC,CAAA;AhCnJxD,AkBEA,AYDA,AtBCA,ADAA,AJDA,ADDI,AsBEJ,AzBDA,A6BAI,ACCJ,CjBAC,GDOG,AEcH,AkBtBG,ADAAI,CnBQC,AUuBH,ApB3BA,CCLM,EciCN,ACnBA,CesIO,AvBtIA,AmBbE1J,GlB4BC,AMIN,AGpBH,ALPA,ATMS,AYEN,GabS,CXYR,ETgBW,AIvBT,AgBLSsJ,CdgCL,AGpBH,AdDS,CWqBL,AXrBM,AuBXhB,ITYW,AdDS,EWqBJ,ACnBA,AJSR,CGUS,AXrBM,CKiBC,AMIN,AGpBH,AWZS,CdgCL,ACnBe,AabT,CXYR,CTgBU,ALjBA,AYES,CZFT,AYEU,EDmBb,GAAG,EAAE,AehCL,CAAA,CDAA,CAA5B,WjBsBqB,SHMyC,CAAC,mBAAQ,CAAC,aAAa,EAAE,CAAC,CAAA;AE/BxF,AmBIA,A/BDA,AkBEA,AYDA,AtBCA,ADAA,AJDA,ADDQ,AsBER,AzBDA,A6BAG,ACCH,AIzBA,CFwBC,AHRD,EGjBY,CC4KR,ArB1IA,AUuBH,ApB5BA,A6BJGK,AP3BElM,CS8KD,GvBtIG,AQAN,AImBG,AnBjCO,CYMT,ATMM,C0BpCU,C9B6BX,A6BJG,CpB4BC,AMIT,Af5BM,CYiBR,AkB9CW,A9B6BF,C6BJI6L,CrBaC,APdI9O,CiBaf,ETgBc,CDfC,CAAC,AUDZ,CAAC,CTgBa,EoB5BE,CTgCF,AShCG,CTgCF,CXJI,AR7Bf,CQ6BgB,AqBrDT,EVyDQ,CAAC,CZnBI,APdI,COcJ,AsBtCpB,ADyBY,CTgCO,AShC/B,CTgCgC,EAAE,CXJI,CAAC,AOfhB,CPegB,AE5BtC,AKauB,EfdhB,EAAwC,EciCX,EezDlB,EZqCmB,CAAC,CAAC,EFCF,EAAE,AcbvC,Oda8C,CAAC,CAAC;ALXjD,AmBCA,A9BEA,ADLA,AkBEA,AYDA,AtBCA,ADAA,AJDA,ADDYN,AsBEZ,AzBDA,A8BCA,AIvBUkT,ChC0BT,G+BbU,AvBsBP,AJFA,AyBXAxD,CrBaC,AJFA,CAAC,AHZM1P,CGYN,CSNJ,AGSA,AIkBA,CXJO,CsBrCQ,CAAC,AFSP,CdgCR,AClBG,AJOJ,AoB3CQkT,CdkCN,ALPG,CgBLO9D,EhBKJ,AO2BA,GRXQ,EmB9BU,AhByChB,AiBzDZ,CDgB6B,CnB8BP,CAAC,AiBrBC,A5BDM,A+BrBR,CnB2BH,AgBLM,ChBKL,CZNa9O,GYMT,CkBdsB,AfuBrB,CHTC,CkBdsB,AlBcrB,AGSA,CadH,CjBqBW,AiBrBnC,CjBqBoC,GXtBxB,A+BxBZ,CDgB0E,AnB8BlC,SAAI,IAAI,CAAC,EAAE,WAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,SAAI,IAAI,CAAC,SAAS,CAAC,IAAM,CAAC;ARTzH,AJNA,ADNA,AkBEA,AYDA,AtBCA,ADAA,AJDA,ADDS,AsBET,AzBDA,A6BAA,ACCA,AIvBI,C5BiCH,GIGG,AqBdAqP,AFAA3J,CdKF,AZRM,G8BNA,AtBqCA,ADdO,AIOd,AQWC,CLAC,AHXD,EXtBa,CiBcZ,AFCA,GRAmB,AYkBb,CFnBF,AFCA,AWdS,CXcR,EevBW,AXyCN,AOhCM,CITC,AXyCN,CFnBF,AWbS,CXaR,AlBRgB,E6BLLoJ,EXaP,CTeD,CAAC,ATvBuB,C2BLxC,IlB4BsB,CAAC,AoB5BW,CbcR,AadS,CbcR,MevBe,CAAC,AfuBT,CAAC,EevBW,CAAC,AtBqCX,CAAC,AuBlDtB8D,CvBkDsB,EoB5BH,CAAlC,Cbc4C,CAAC,EevBW,CbsBF,AFCN,AgBpC5C,CDasD,CbsBF,MatBS,CAAC,CAAA,SfuBC,CAAC,mDgBpC1C;A5BmC1B,ALbA,AkBEA,AYDA,AtBCA,ADAA,AJDA,ADDYlT,AsBEZ,AzBDA,A8BCA,AIxB0B,IDctB,AtBqCA,AIvBH,ATOG,AJRsC,A6BJtC4P,CETC,AtBqCA,AWIH,CnBjCU5P,EOeJ,AOmBN,GF5BM,CE4BF,ACnBH,AadS,GrBcG,AqBdAoP,CXaX,CdDa,CSPF,CLSI,AUDZ,ALRS,CLSI,AJFA,CJRuC,Ce6B3C,AGpBN,EAAE,AjBdkB,CckCX,AGpBN,AdDY,AyBZA,CrBcC,AJFD,AyBZC,CrBcA,APfOjP,IeeX,CDmBI,ACnBH,CDmBI,EcjCF,CAAzB,Gbc8B,CDmBI,ACnBH,CDmBI,GAAG,CAAC,CAAC,AdlC5B,IeemB,SAAS;AZAxC,ALdA,AkBEA,AYDA,AtBCA,ADAA,AJDA,ADDS,AsBET,AzBDA,A6BDAL,ACEA,AIzB0B,GF0BvB,CCVC,AtBoCA,ADdA,AKRH,AO2BA,ASjCG+P,CrBcC,ECcE,AkB7BA,CZkCL,AYlCM5J,ClB6BC,ATzBiC,A6BHjC,ETiCD,CLAF,AcjCMmJ,CpB4BC,CkB7Bb,ETcI,AFCA,AImBS,CAAC,AOlCG,E3BI0C,CkBUnD,ClBVkC,Ce8B1B,AcjCM,CAAC,GdiCH,CAAC,AYlCKlJ,CAAT,CZkCM,CCnBL,AadI,AFDO,CXeV,AadnB,CXaoB,EAAE,MFCM,CAAC,ChBX8B,EgBW3B,AhBXU,IgBWN,AhBXuB,CgBWtB;AIoBrC,AU/BA,A/BHA,AkBEA,AVAA,ADAA,AgBhCC,ApB+BD,ADDK,AsBEL,AzBDA,A6BDE,ACEF,AI1B0B,CvBqDzB,AWKA,CXLC,CAAA,ARnCE,COsBA,APhBE,E0BAA,CjBUC,AESL,AenBKC,CnBgBQ,AKTb,AbJwC,C8BA1B,E7BHH9F,CckCV,AF3BG,AGQH,AffG,CeeF,CRCiB,AQDhB,AffW,CeeV,AWfS,CAAC6F,CdOL,AcPI,CZkCN,AYlCP,CZkCQ,CGpBL,ASde,EdOJ,CKOR,AI5CK1C,CJ4CJ,CLPU,CE2BF,CAAC,AF3BG,AiBJa,CAAC,CRjClC,EAAoB,KPgEM,Ae/BoC,Cf+BnC,CAAC,EAAE,Af/B4B,OkBW3B,GHoBS,AGpBN,CHoBO,CAAC,GAAG,AGpBN,CAAC,GHoBS,CAAC,MGpBA,CAAC,QAAQ,CAAC,CAAC;ATiB9D,AWKA,ArBnCA,AkBEA,AYDA,AtBCA,ADAA,AgBjCqB,ApBgCrB,ADDQxD,AsBER,AzBDA,A6BDI,ACEJ,AI3B0B,ItBmCf,AEUH,AkBjBJ,A7BHIA,EQ8BK,EDdL,AmBhBAoG,CZkCL,ACnBA,AadM0J,CnBSQ,AoBPP,CpBOQ,CGHf,GLSY,AsBbA,AHHA,EjBU8B,ADoBrB,AShBnB,ALPG,CiBJU,AHHA,CjBU6B,AFM5B,CAAC,AKTT,AgBNX,AFDI,E1BAsB,C4BCF,E5BDK3P,COgBH,AIIX,CJJY,EKTP,ADanB,CCboB,CiBJE,CpBO8C,AoBP7C,CtBaS,CENsC,AFMtC,AKTR,EAAE,CAAC,EDaZ,GFVmH,ETV3H,GWoBwB,EAAE,CkBjBQ,CAAC,QAAQ,CAAC,CAAA,ElBiBiB;AbnBrE,AkBEA,AYF0B,AtBE1B,ADAA,AJDA,ADDK,AsBEL,AzBDA,A8BCA,AI5B0B,GrB4BvB,APYA,CKiBC,ADfA,AsBbA,A9BDH,CQcI,GENG,AMKN,AJKA,CiBpB+B,CCGvB,ADHgB,C7BElB,CUQI,AGHT,ADaG,AZlBG,Ce+BA,AHbF,EILE,CEDL,ALPG,CDaI,CAAC,CZlBI,CAAC,CgBaF,CAAC,GNLS,AQIZ,AYXY,CdYL,CEDL,AFCM,CEDL,AYXY,CpBOC,CVRZ,GUQgB,CGHR,ADaG,CFVO,CEUL,AZlBP,CaKK,IGQO,CAAC,CAAC,MHRG,EAAE,CAAC;AFJ3C,APYO,ALdP,AkBEA,AYHoC,AtBGpC,ADAA,AgBnCqB,ApBkCrB,ADDC,AsBED,AzBDA,A6BFI,ACGJ,AI7B0B,C/BQzB,C4BoBD,CTkCG,CZVC,AQVH,AflCD,CGiCY,AYCV,EetBK,CvBgCQ,AsBtBP,A9BDN,CWAoB,AmBCb,AHJA,GjBWG,AKuBT,AF1BA,ADaA,CZlBI,A2BHMwB,CAAC,CvBeQ,CcAlB,AYXY,CAAC,A9BDN,A2BHM,CZkCR,AYlCL,CZkCM,AF1BA,ADaA,CZlBI,A2BHMA,CTeX,AYXY,AHJA,CGIC,C1BWQ,AQMhB,CRNiB,AQMhB,AkBjBS,A9BDN,A2BHMD,CjBWC,ACRa,CI+BrB,AJ/BsB,CI+BrB,CLvBU,ANI6B,CMJ5B,AGHnB,ADaU,AkBjBS,AE9BgByR,CtBqChB,AFeQ,AOQhB,AHbA,AkBjBS,A9BDN,EAAE,C2BHO,CZkCR,AYlCSlS,AK1BgB,CjB4DxB,AJ/B8B,AmBCrB,CAAC,CnBDsB,GgBHtD,CdQkB,CKOU,ASfUU,CTeT,ASfU,EdQjB,AcRtB,EAA2C,EhBGiC,GEKtD,GiBJ6B,CAAC,CAAC,CAAC,CAAC,CAAC,AE9BlC,UnBkCkB,AiBJ0B,IjBItB,CAAC,kBAAkB,CAAC,YAAY,CAAC,EAAvD,CAAuD,CAAC;AO6BlF,ArBnCA,AkBEA,AYDA,AtBCA,ADAA,AJDA,AqBCA,AzBDA,A6BFMyE,ACGN,IGTW,A3BqBP,AYEH,EWjBKA,EnB0BE,AJXA,A0BXA,CpBOC,AKuBN,AF1BA,ADaA,AkBjBM,CCVQ,CAAC,C/BSf,C2BHU,CAACxE,CnB0BC,CUXX,AYXY,CAAC,C9BDR,A2BHH,CnB0Ba,ARvBT,A2BHSyE,CnB0BC,AYUO,ChBrBN,CJZR,CIYU,AJZT,E+BTkB,AbqBnB,CarBoB,AX0CW,AUhClB,A9BDT,A2BHS,CGIC,AHJA3E,EGIE,EtBsBE,CRvBR,CAAC,C8BCU,CCVgB,ADUf,CtBsBC,ARvBT,A2BHS,CINgB,A/BSxB,A2BHSC,C3BGR,A2BHO,CAAV,CnB0Bc,AsBtBA,AHJlC,CnB0BkC,AsBtBC,MCV+B,uBDUF,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU;ATpCrF,AtBkCA,AkBEA,AYDA,AtBCA,ADAA,AgBpCE,ApBmCF,ADFA,AsBGA,AzBDA,A6BFK,ACGL,AI/B0B,IxBsDtB,AYUH,CZVI,AOQH,ENFK,CsBtCC,ArBiBA,ACTJ,AEMF,ATOM,AQMN,AQeG,AUhCG,CVgCF,AUhCG,A9BDN,ACHMpB,G8BNG,ArBiBA,AGHN,CkBdO,AbqBT,CPbM,APaI,CQML,AQeG,CUhCI,CjBIL,AO4BG,AUhCG,CCVC,A3BqBA,C2BrBC,ArBiBA,ATXnB,CAAoBC,EYQJ,CTOO,AHfvB,CGewB,A0BXA,CjBIL,AiBJM,A7BJA,C8BNC,CAAC,AlBcN,AiBJM,GRrCnBgD,CXmCmB,CDSK,AoBPA,CAAC,CnBFH,ACmBV,CAAC,CUtDP,CS2BuB,ArBiBA,CqBjBC,ADUA,CTrCI,ASqCH,CRrCrB,ES2BwB,CAAC,IrBiBI,EAAE,CEUb,CAAC,EmB3BgB,CAAC,CnB2Bb,CAAC,GmB3BiB,ApBQlB,CoBRmB,ApBQlB,CoBRmB,AnB2Bd,CUtD7C,CVsD+C,GmB3BiB,CDUC,CCVC,ADUA,CAAC,CCVC,ADUA,CCVC,AnB2Bd,AkBjBc,CAAC,ClBiBb,GDnBD,CAAC,CoBRmB,IDUI,CCVC,GpBQf,CCmBK,CmB3Be,ApBQlB,ACmBI,CAAC,OmB3BqB,CAAC,EAAE,CpBQjB,CAAC,CAAA,qBPawC,CAAC,CAAA;AWoB5H,AMnEA,AtBkCA,AkBEA,AYDA,AtBCA,ADAA,AgBpCE,ApBmCF,ADFI,AsBGJ,AzBDA,A8BCA,AIhC0B,CjB+DzB,GNFG,ADLO,AINV,AZlBA,CIYI,AQMH,AZlBA,CAAC,ACHKzD,CeiBJ,AhBdA,CWDA,ASkCF,AUhCM,CAAC,CRrCFkD,ES2BK,ArBiBA,AQKT,ALRA,EFNO,AWnCR,CFqEO,CXJO,AShBT,AYZS,CjBIR,AO4BG,AUhCM,ARrCH,CS2BI,AX0CN,EVzBQ,AGHT,CKQC,CatBU,AbsBT,AjBhBW,CSWD,CDqBW,AqB5BV,CAAC,CZYR,CYZU,A7BJE7C,CO2BM,CAAC,AKnBhB,CAAC,ASzCnB,CS2B6B,CAAC,ApBQJ,AmBEI,CnBFH,AmBEI,CjBIR,EHGW,AGHT,CHGS,ACTH,AEML,AZRxB,C6BIkC,CtBuBgB,AGzBnB,AmBEI,A7BJE,UoBjC6B,OVmClB,CAAC,AmBEI,CnBFJ,AOcE,AYZG,CAAC,CZYF,AYZG,CAAC,CAAC,OEjCgBgT,GFiCN,CEjC9C,sCDuBqF,CAAC,CAAA;AhB0ChH,AMpEA,AtBkCA,AkBEA,AYDA,AtBCA,ADAA,AgBvCqB,ApBsCrB,ADFQ,AsBGR,AzBDA,A6BHI,ACIJ,IxBYI,AYEI,AJKA,AZnBP,CoBiCC,GXJM,ADLA,AGzBJ,APaI,A0BXA,CCVC,ADUA,E9BDD,A2BJGhN,CjBYC,ADqBA,ADLA,AKnBT,GFNQ,APaI,CcCX,ALRG,AiBJS,CAAC,A9BDH,CAAC,A2BJG,CTiBX,AdDY,AuBhBAE,GnB4BG,AUXZ,CSjBC,CTiBC,AdDY,A0BXA,AHLA,CjBYC,AFgBA,AUXZ,AYZY,CtBuBC,CsBvBC,AHLhB,CjBYiB,AFgBA,AmB5BxB,CjBYyB,CAAA,CDqBT,CE9BQ,APaI,A0BXA,CnBFJ,AUnCI,ALkDlB,AJKQ,AkBlBW,C1BWC,CSPR,CJwBD,AOfxB,AJKA,ECd4B,AiBJS,CAAC,CrB4BV,EAAE,IOfhB,AJKQ,EkBlByB,CAAC,CAAC,CAAC,CAAC,CAAC,ClBkBd,CILP,CJKS,ECdQ,EAAE,CAAC,EiBJW,OlBkBa;AStD5E,ArBoCA,ADFA,AkBEA,AYDA,AtBCA,ADAA,AgBrCE,ApBoCF,ADFQ,AsBGR,AzBDA,A6BHG,ACIH,AIlC0B,ChCkCzB,GWDD,ASkCC,CTlCA,GoBRO,A3BqBA,AYEN,AJKA,AQcG,AUhCG,CpBOC,AUyBH,AUhCG,E7BJMlG,CQgCH,ADLA,AKnBT,ADcG,CAAC,CmB5BO,A3BqBA,CYEL,AImBG,CFpBR,ALRG,AO4BM,AUhCG,ClBkBL,AkBlBM,CrB4BC,AGVN,CJKO,AQVN,CRUO,AQVN,AcbM,CtBuBA,AKnBR,AiBJS,A7BJI,CQgCH,ARhCII,C6BIH,CVgCF,CFpBR,AdDY,AHfA,CYQR,CJwBU,AShBZ,AjBhBgB,CQgCH,AShBZ,AdDY,AgBqBH,AUhCG,A7BJH,CYQL,AO4BM,AUhCG,A7BJrB,E8BNuB,AlBcT,CGSI,CAAC,CevBO,A3BqBA,AgBqBH,AUhCG,C1BWC,AgBqBH,AUhCG,ETrC0B,CU2BvB,GAAG,A3BqBA,AQON,CILC,AImBG,CW1CY,AfuBd,AJKA,AQcG,CW1CW,AfuBb,EZFQ,CAAC,EgBqBD,CAAC,ChBrBI,CAAC,CAAC,CAAC,G0BXG,CVgCF,AUhCG,CVgCF,AUhCG,CAAC,CVgCF,AUhCG,CAAC,G1BWG,EAAE,CAAA,I0BXK,uDrB4BuD,CAAC,CAAA;AY5DhI,ArBwBA,ADMA,AkBEA,AYDA,AtBCA,ADAA,AJDA,ADFK,AsBGL,AzBDA,A8BCA,AInC0B,CrBiCzB,EIkCE,AdvCsB,CoBzBrB,AL8CH,AfhBG,CegBF,GevBM,ArBiBA,ANIA,AgBqBN,AUhCM,CrB4BC,ADLA,AsBvBA,GpBOG,AEWT,ERPW,CgBqBL,CFpBL,ALRA,AiBJY,CVgCL,AUhCM,CCVC,AX0CN,CW1CO,AVvBA,ATmDT,EMND,ALRA,CQrC8B,ASiCjB,ClBkBR,AkBlBS,CjBIX,ATOY,AQOT,CRPU,A0BXA,CCVC,CAAC,CAAC,CDUC,ICVI,AlBcZ,CAAC,CkBda,C3BqBC,AQOT,AZpB1B,C+BRoC,A3BqBA,AQOT,CCdF,ATOW,ESPT,CKQG,ALRF,CKQG;AHoBhC,AJvCA,AXOA,ADFA,AkBEA,AYDA,AtBCA,ADAA,AJDA,AqBCA,AzBDA,A6BHE,ACIF,AIpC0B,IXIzB,AL+CA,AhBfG,CIYC,AgBqBH,COrCImB,CAAC,ClBiCC,ADLA,AsBvBA,ClBkBL,AkBlBM,CHLC,CAAR,CILU,ArBiBA,CDqBC,AIxBT,CLmBU,EuBjCE,AbsBZ,AYZY,CrB4BC,AqB5BA,CpBOC,ADqBA,GCrBG,ADqBA,CAAC,CDLC,AsBvBA,CpBOC,ADqBA,AY7DH,ASiCG,CrB4BC,AShBZ,CVWa,AaxDH,ASiCG,A9BDA,C+BTC,CAAC,ArBiBA,ADqBA,CCrBC,AVRA,CQwBC,AsBvBA,CtBuBC,KCKK,AY7DZ,CZ6Da,ECrBE,CAAC,CFgBC,CAAA,CCKE,CMGC,AJnC3C,CFgC4C,AY7DJ,CXwCK,ADqBA,ECrBE,ADqBA,CsBtCC,AVvBH,CUuBI,AtBsCA,AMGe,EAAE,CgBzCd,CAAC,EVvBR,GUuBa,CAAC,AVvBV,CXwCW,CqBjBC,ArBiBA,AKwB+B,AMhE/C,CXwCgB,AWxCZ,KrBgCkB,CAAC;AWDrE,AXGA,ADHA,AkBEA,AVAA,ADAA,AJDA,AqBCA,AzBDA,A6BHE,ACIF,AIrC0B,IjBqEzB,AMhEA,ADiEA,ETnCK,AgBFAH,EnB4BE,AILN,AQcG,AUhCG,Cf+BF,AXrBK,A0BVF,CHLC,EjBYE,ADqBA,ADLA,AKnBT,CE2BO,AGnBN,AdFW,AuBfFE,EfuBJ,CmB5BO,AX0CH,AUhCG,Cf+BF,AMhEA,AjB2CK,A0BVF,CrB4BC,CY7DF,ARqCN,AO4BM,AUhCG,CpBOC,AoBPA,CpBOC,AKwBH,CPRI,AsBvBA,AHLpB,EhBEsB,CDUC,ADqBA,AWIH,CZTI,AYSH,AUhCG,CCVC,ArBiBA,ACV0B,CoBPzB,AtBsCA,CY7DX,AjB2Cc,CMHD,CAAC,AKwBH,AJlC6B,CDU1B,CKwBD,CJlC8B,ACqBxC,AQcW,CZTI,AILd,AQcW,CXJI,ADLA,AG1B0B,CF+BzB,AE/ByB,CF+BxB,AY7DJ,ARqCL,CJwBU,AIxBT,CJwBS,ALlBG,EIaA,AaxDH,AjB2CK,GIaC,CAAC,EAAE,CuBjCC,AVvBV,CUuBW,AnB4Bd,CAAC,EmB5BgB,AVvBV,CUuBW,CVvBf,ATmDE,CSnDE,ATmDD,GmB5BiB,CAAC,CAAC,GAAG,CAAC,GnB4BX,EAAE,ImB5BkB,CAAC,CAAA,EnB4BX,EAAE,cAAc,CAAC,CAAC;ADpBlF,AZAA,AkBEA,AVAA,ADAA,AJDA,ADHI,AsBIJ,AzBDA,A6BHE,ACIF,AItC0B,CXMzB,CAAC,ETmDD,AQcA,ApBjCD,CYmBE,CXvBM,A0BAFL,CXmBF,AfnBKtB,CcoCP,AXrBM,AgBsBH,AUhCG,CpBOC,AGHN,AiBJM,ARxCR,AKmCQ,GlBiCG,ADLA,AOQN,AGlBH,ASlBSyB,CILC,C3BoBC,AgBsBH,EXJK,AMGN,AGlBH,AYbS,AHLA,CTkBR,AEmByB,AUhChB,AHLAP,ChBEC,CH0BC,AOQN,AJlCM,ASmCgB,EAAE,AExEnB,CXqCI,CF+BC,ADLA,AG1BA,AVFE,A0BAvB,CnB4BsB,AJbA,A0BVA,C1BUC,A0BVA,EAAE,C7BLGhB,CcoCP,AXrBM,CKkBC,ADLA,AOQN,AXrBM,AgBsBgB,CZTf,AJbD,CObE,AmBGA,CVgCiB,AUhChB,Cf+BL,AJlCM,ASmCgB,CXJf,AMGN,AKCsB,CLDrB,CPRO,CAAA,AG1BC,AmBGA,CAAC,IrB4BI,ASfT,CAAC,AjBlB1B,CQiCoC,ASfT,GYbY,A7BLE,C6BKD,A7BLEF,C6BKD,CAAC,CAAC,CAAC,UnBHJ,AmBGc,EnBHZ,AVF3C,CUE4C,CAAA,GVFoBK,UAApE,EAAgF;AUIpF,AU0BA,AtB3BA,AkBEA,AYHA,AtBGA,ADAA,AgBvCE,ApBsCF,ADHQL,AsBIR,AzBDA,A6BHE,ACIF,AIvC0B,IhBsDlB,AJKA,AQaP,ApBND,AC/BQA,CGeH,AJgBJ,C2B/BKwG,EjBWI,AK0BR,AF5BA,AiBJM,CtBuBC,AUTN,AEkBG,AUhCG,ADJAyI,AFDA,GZqCH,AF5BA,AcTMxI,CPqCF,AExED,CFwEE,CV1BM,CDsBD,AMIN,AehCM,CCXG,AhB2CR,AKAG,AUhCG,ADJjB,APpCE,CFwEa,ASpCIuJ,AFDD,CAAC7J,CjBWG,AU0BL,AnBrCO,A0BAN,CGKG,AHLT,CjBWY,ADsBF,AqB5BA,AHLAO,CPqCF,AnBrCOrG,CYST,AiBJM,CfgCL,AF5BA,AgBRnB,CpBgC0B,AWIH,CSpCK,CCIA,CfgCL,AYrCX,CdSY,AcTM4F,CdSL,EAAE,AZTnB,CcqCoB,AKAG,CXJI,AMIN,AKAG,CXJI,COdlB,GAAjB,CIkBqC,CLAF,AYrCxB,CZqCyB,AHbL,AQaQ,CAAC,AOrCG,EfwB3C,CGawC,AKAG,CLAF,EClBvB,AIkB4B,EAAE,CAAC,COrCGU,CPqCD,AOrCR,CZqCM,AHbjB,CGakB,AKAG,AOrCE,EZqCH,EClBf,EJKiB,EAAE,GAAqB,EAAE,OAAgB,sCHSmB,CAAC,CAAA;AV9BpH,AkBEA,AYHE,AtBGF,ADAA,AgBvCE,ApBsCF,ADHQ,AsBIR,AzBDA,A6BHI,ACIJ,AIxC0B,IhCwCX,E6BHT,ErB4BE,AUTN,AFDA,AJKA,AQaA,AUhCM,ADJA,AFDAA,CvBcG,A0BTF,AHLA,E1BAMtG,CSWH,AK0BT,AGjBG,ALXH,AO4BG,CXJO,AuBrET,CxBiEU,AILN,AexBM,CXmBL,CezBO,AlBeT,AiBJS,CZeL,AEiBA,AUhCM,ClBmBL,AexBR,CXmBS,CNRO,AMQN,AIkBA,AOrCM,CjBWC,AoBNA,A7BLI,C6BKH,A7BLII,CWwBT,CAAC,AkBnBM,ADJAwO,C5BDC,CSWC,CqBjBC,ArBiBA,AFkBA,AKpBT,AbLQ,ACJK,A0BAJ,CINC,ArBiBD,AU0BL,AnBrCG,CmBqCF,AUhCM,A7BLrB,CO6BsB,AKpBC,AO4BP,AUhCM,A9BD7B,A2BJmB,CPqCK,CP5BQ,AO4BP,ASpCpB,ChBQ4B,AgBRhC,CrB4BgC,CAAC,AsBxBA,ADJA,CCIC,EdcJ,CAAC,AJKA,CAAC,AZpBP,CYoBQ,CkBnBO,CAAC,CfgCR,AehCS,CfgCR,AehCS,CtBwBC,AUTJ,AYfI,CtBwBA,AsBxBC,CZeH,Ca1BK,CAAC,AfyBN,CDkBF,AClBG,AhBfC,CgBeA,CezBO,AhB2CT,CgB3CU,GhB2CN,AehCS,CfgCR,CgB3CU,EAAE,IAAI,ChB2CR,CAAC,CgB3CU,AhB2CT,EgB3CW,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAA;AhCStF,AkBEA,AYHI,AtBGJ,ADAA,AJDA,ADHK,AsBIL,AzBDA,A6BHI,ACIJ,AI7CA,GXsEG,CLVF,AJKA,CILC,AJKA,GJKM,AJfA,AgBwBN,AUjCM,A9BDN,A2BJMrN,CjBWC,ADsBA,AMIN,AehCM,AHLA,EECE,CrB4BC,AURT,ALZA,AO6BG,CW5CO,AX4CN,AOtCMN,CvBcC,CSLR,AbLG,A6BHM2N,CXoBR,AYhBS,AHLZ,CGKa,C1BSC,AgBwBN,AOtCM,CPsCL,EFjBD,CAAC,CYhBU,ADJZ,CCIa,ADJAe,CrB4BC,AmB7BArJ,CTqBR,AYhBS,AHLR,CvBcS,AgBwBN,ChBxBO,CIeC,AYSN,EUjCQ,ADJpB,CCIqB,ADJ5B,KCIiC,A9BDN,C8BCO,A9BDN,CQyBO,GRzBH,CQyBO,ARzBN,IQyBU,CAAC,MRzBA,CAAC,C8BCO,A9BDN,C8BCO,CZgBF,AYhBG,CAAC,CZgBF,AYhBG,CAAC,UAAU,CtBwBC,EAAE,+CJf+C,CAAC,CAAA;AiBgB1H,AtB3BA,AkBEA,AYHG,AtBGH,ADAA,AJDA,AqBCA,AzBDA,A8BCA,AI9CA,ItBqDI,AMSH,AJKO,AZrBP,CUOI,ANGA,AJVH,GS6BM,AMKN,AejCM,CAAC,GCXG,AtBuCA,ADJA,AOSN,AKAH,CXLU,GsBvCG,AhB4CN,AGjBN,ALZA,AiBJY,CfiCL,AejCM,EtBwBE,AwBlET,CvBsEU,CWKR,EXLW,CSZX,CYhBa,CZgBX,ANIC,AkBpBW,CCXC,AhB4CN,AGjBN,ALZA,CkBfa,AlBeZ,AiBJY,CfiCL,AHbtB,EHQ8B,CAAC,AIxBZ,CAAC,AiBJY,CAAC,EtBwBE,CCIC,ADJA,CKpBX,CJwBa,AIxBZ,ADgBX,AkBpBuB,CrB4BA,AIxBX,AiBJY,MlBoBF,EAAE,CmB/BS,CAAC,AvBmCA,EAAE,CuBnCC,CAAC,IDWI,CCXC,ADWA,CCXC,ADWA,CAAC,AE1ClCwM,CD+BmC,AvBmCA,AIJA,AkBpBA,CAAC,ClBoBC,CJIC,IAAI,CAAC,AIJS,AoB9DrE,EpB8DuE,AoB9D3C,CF0CmC,KlBoBuB,EoB9DtF,EAAsC,KAAtC,CALV,MxBuE8F,CAAC,GAAG,IAAI,CAAC,wBAAwB,CAAA;AT1B/H,AkBEA,AVAA,ADAA,AJDA,ADJI,AsBKJ,AzBDA,A6BJI,ACKJ,GjBDG,CDSC,ADqBA,AYCH,AjBnBG,AJVW,CS4BV,CRlCG,EW0BN,AkBpBM,CtBwBC,AYSN,AUjCM,GfiCN,AYvCSxM,CAAR,Cf0BI,EmB/BQ,Ab2BZ,ALZA,AiBJY,C1BUC,A0BVA,ClBoBL,ERVQ,CSNX,CQyBI,CTTI,CChBL,ATMY,AQUN,CMJL,AdNW,A0BVC,CAAC,EAAE,CT6B2B,ErB7BzB,E+BXG,AlBeZ,AiBJY,CCXC,AlBeZ,AiBJY,A9BAjC,G+BXoC,CAAC,AlBeZ,CDgBO,AkBpBM,CjBIX,ADgBM,AkBpBM,CjBIX,ADgBM,GZpBJ,EeiCM,CAAC,EgB5CW,CAAC,GhB4CN,EAAE,AfjCI,EAAE,EeiCF,CAAC,KejCc,CAAC,CAAC,CAAC,CAAC,CfiCR,AejCS,A9BAG,C+BXF,AhB4CT,CgB5CU,AhB4CT,AfjCY,G+BXA,CAAC,IDWI,CCXC,CAAC,CAAC,CAAA,E/BW2B;AWD9G,APYA,ALbA,AkBEA,AYHE,AtBGF,ADAA,AJDA,ADJQ,AsBKR,AzBDA,A6BJM,ACKN,AIhDA,C5B2DC,GKmBG,AGTH,CAAC,CiBxBI,CbmBF,CPcW,ADLP,AaIK,ADMX,AUlCM,A9BAN,CeiCC,AJnCa,AmBEP,EHNE,CPwCL,CW7CO,Ab2BT,ALZA,AgBRSqJ,ErB4BE,ARxBN,A2BNH,ClBmCiB,AqB7BP,CnBFQ,AmBEP,CnBFQ,ASoCb,EStCN,ChBQM,EFNsC,EH0BzB,AqB5BA,CrB4BA,AsBxBC,A9BAN,CoBkCE,AUlCK,A9BAN,CoBkCE,CUlCM,GT4BhB,CRxBW,AiBJS,ADJ/B,APhDwB7P,CDgFb,ARxBY,AbJG,CAAC,A6BJM,IhBQL,CAAC,EAAE,ebJkB,EqB4BI,ArB5BF,UAAC,KAAa,EAAE,KAAa,EAAE,YAAoB,EAAE,OAAe;AIJzH,ALEA,AkBEA,AYHI6P,AtBGJ,ADAA,AJDA,ADJQ,AsBKR,AzBDA,A6BLiB,ACMjB,AI1CUsD,IxBmEN,AG1BA,AKiBI,AJKR,AiBxBItD,CrB4BC,AOSH,GgB5CM,AtBwCA,AYDN,ADMA,AUlCM,CCXC,ADWA,CCXC,CAAA,AFOC,A5BFIhQ,CiBuBZ,AGWG,ARxBH,AO8BG,ApBlCH,AgC3COsT,CXuEH,CQhCO,CpBiCC,AGTd,Ae3BuB7M,CTwBjB,AYjBS,A9BAT,C8BAU,CElDjB,CvB+EmB,AIzBT,AO8BG,CXLO,CSZR,AGWG,AMnCe,AKpCX8M,Cd4DN,AYjBS,AHPS9R,CGOR,A9BAT,CqB4BI,ADMA,CAAC,AUlCM,CZiBR,AlBjBA,A2BPkB,ClBoCR,ARnCI,A0BDKG,ClBoCR,ALpB3B,AHf+BnB,A0BDK,CdW3B,AiBJmB,CVkCL,AOzCW,CNmCV,ApBlCM,A0BDD,CNmCJ,AMnCT,ClBoCgB,ARnCI,CAAN,CQmCI,AWKN,AnBxCrB,CQmC2B,EOdhB,EhBfY,CaIT,AGWrB,AhBf+B,AgC3CF+S,EZ6EO,CFjBI,CLbf,AO8Ba,CFjBI,GlBjBH,CAAC,EaIf,CmB/CP,CAAwBC,ChC2CG,IAAI,GgC3CC,CnB+Cd,AmB/CeC,CnB+Cd,ObJwB,EAAE,EaIf,AbJiB,CAAC,CaIhB,AbJiB,AgC3CzB,ChC2C0B,AgC3CF,MrByCiB,GqBzCzC,CAAxB,CnB+C4C,CAAC,AmB/Ce,EnB+CrD,CAAsC,CAAC;AE8BjE,AHdA,AbtBA,AkBEA,AYJgBzD,AtBIhB,ADAA,AJDA,ADJK,AsBKL,AzBDA,A8BCA,AI1CQ0D,CjB4EP,AH3DD,AA6CC,EX5BG,CQsCA,ADJO,AG3BP,AWzCEjQ,ArBqCA,CQmCD,AGVJ,CiBxBeuM,CnBYT,CqBlBC,ApBSA,AU8BN,ALbA,AcfM,CjBIL,AiBJM,ADLU,EAAED,A5BDT1P,CoBkCN,ADMH,ApBlCA,ACNG,CoBkCC,CpBlCO,A+BrCNqT,CrByCO,AKiBN,CEEL,AEiBG,AUlCS,A9BAT,C8BAU,EdeJ,CLjBO,AKiBN,CLjBO,AOmBZ,CEiBI,CUlCU,A9BAT,C8BAU,CnBFC,ASoCT,ApBlCA,AgC3CG,CXuEC,ALbA,AcfM,CdeL,AgB1DA,CxBoEc,CAAC,AaGb,CV9BO,ASoCT,CAAC,AUlCS,AE5CgD,CF4C/C,CT4BL,CUvCO,EX6CP,CAAC,AUlCS,CnBFC,AKiBN,AcfM,EtByBiB,AG3Bf,AKiBN,CAAC,KcfW,CAAC,CAAC,CAAC,CAAC,CZiBT,AYjBU,CZiBT,IGWH,CAAC,IS5BqB,ST4BhB,CAAC,kBAAkB,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;ANOjF,AH7DsB,AbwBtB,AkBEA,AYLc,AtBKd,ADAA,AgBjCC,ApBgCD,ADJQ,AsBKR,AzBDA,A6BNM,ACON,AI1CQC,ItBkDG,ADuBP,AOfH,CAAC,AarBE,GELI,AvBoCA,AG3BA,AU8BN,ARxBA,AiBJM,A7BNI,C6BMH,EHRE,CjBeQ,AFkBP,AaGN,ADOH,CV5BiB,AWqBb,CV9BO,AqBzCNA,CnB+CC,AcZH,CTyBF,AYjBY,A9BAZ,C8BAa,CnBFC,AqBzCN,CDgCO,ArBkB4B,AGHlC,CkBfO,AlBeN,AD/BY,AZ2BlB,AgC3CM,GxBoES,AG3BA,AWhCVjQ,CXgCW,AmBEA,CZiBX,AYjBY,CtByBC,ARzBZ,CQyBa,AsBzBA,CCXC,CvBoCC,ARzBZ,CqB4BO,CUvCO,ATvB9B,CQkC+B,CT4BL,AS5BM,ARlCV,ESuBY,CAAA,AX8CR,CCPI,CS5BO,CAAC,CT4BL,EAAE,ArB5BN,CqB4BO,ArB5BN,SAAS,CAAC,C8BAa,CAAC,CAAC,CAAC,CAAC,CAAC,C9BAX,CAAC,KAAK,EAAE,C8BAa,M9BAN,CAAC,GAAG,CAAC,CAAC,IWFgB,CAAC,CAAA;AC2BtF,Ab3BA,AkBEA,AYLG,AtBKH,ADAA,AgBlCuB,ApBiCvB,ADJY,AsBKZ,AzBDA,A6BPiB,ACQjB,AI7C+E,IX0E9E,ARxBA,AGYA,CLlBI,AU8BH,ARxBA,GkBfM,ArBkBA,AoBPA,CAAC,GpBOG,AFkBA,AYUT,CV5BU,AQUT,Ac/De,CAPnB,CD0Ce,AJESiD,CGSR,A9BAZ,C8BAa,CVmCR,CZVU,CuBpCC,ArBkBA,AFkBA,AsBzBA,CCXC,AvBoCD,AYUR,AUnCS,AHTS,CAACnF,CGSR,CpBOC,CqBlBC,ArBkBA,CqBlBC,AJES,CP4CjB,AO5CkBG,CP4CjB,AUnCS,AHTS,CGSR,CHTM,CjBgBJ,AiBhBD,CAAb,EGSiB,CVmCR,AUnCS,CpBOC,AU4BT,OW9CgB,AX8CT,CW9CU,CAAA,ArBkBC,AU4BT,EAAE,CAAC,CV5BU,AU4BT,GUnCY,CAAC,CAAC,CAAC,CpBOC,AoBPA,CAAC,KpBOK,KAAK,AoBPA,Q9BAJ,CUOa,CAAC,EAAE;AXT/E,AkBEA,AVAA,ADAA,AJDA,ADJY,AsBKZ,AzBDA,A8BCA,AI1CI8F,GjB6ED,CgB7CC,ApBSA,AU+BH,ARzBA,ADmBgC,CmBlC5B,GDWG,CtByBC,AsBzBA,GpBOG,AQWT,AEkBA,AY/ECA,C/BqCe1H,GiBwBZ,AYlBS,A9BAZ,CkBkBI,AYlBS,EpBOE,AsBlDR,CAACoN,CF2CS,CnBFC,AmBEA,CpBOC,ACTA,AXEZ,AgC3CP,CtBkDoB,AoBPA,AE3CRkG,ErByCU,CAAC,EmBEE,A9BAZ,ACNkB,CSaL,AoBPA,A9BAZ,ACNkB5S,A+BrChC,ChC2Ce,CWFa,AXEZ,CWFa,COoBR,AjBxBN,CSagB,AQWT,ANKW,AkBvBF,A7BNM,CiBwBd,AYlBS,CnBFC,AXEZ,CoBoCI,CTtCU,AVJpB,CDMS,CUOa,ATbMD,CSaN,AVPX,CWFa,CVJxB,EAAiC,CAAjC,CAAP,E6BMsC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,GnBFX,CAAC,KAAK,CAAC,CAAC,CAAA;AIqC9D,AJpCA,AZDA,AkBEA,AYLE,AtBKF,ADAA,AgBpCuB,ApBmCvB,ADJS,AsBKT,AzBDA,A6BRM,ACSN,CjBDC,GoBRG,AnBoCH,CXnCO,C4BGF,A5BAI,CesBN,AatBGuP,CrB+BC,AKrBN,AiBJM,CpBOC,AQYN,AYnBM,EHVE,CdcL,AOgCH,CnB1Ca1P,CO+BF,AqB/BZ,A5BAQ,C0BJJ,CGUU,ADNA,A5BAE,C6BMD,CVoCR,EPhCK,AbJT,CoBoCO,EZXW,AKrBQ,EAAE,ADsBpB,AkB1BY,CtByBC,AKrBQ,AiBJR,A9BAf,CoBoCO,CAAC,AUpCS,C9BAd,CQyBgB,CAAC,AOSO,EelCL,ClB0BA,AkB1BC,CVoCR,ApBpCN,CY0Be,AQUR,ApBpCN,CekCsC,CHRd,CGQgB,AelCtB,ClB0BQ,AkB1BP,CtByBC,CAAA,CYWP,CRVyB,CQUvB,ApBpCN,CekCmD,AHRpB,AZ1B9B,CoBoCO,ApBpCN,CoBoCO,ApBpCN,CoBoCO,ApBpCN,QY0B8C,EAAE,IkB1BnB,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,SlB0BwC;ADlCtH,AZMA,AkBEA,AYLI0P,AtBKJ,ADAA,AJDA,ADJY,AsBKZ,AzBDA,A6BRQ,ACSR,AIvDA,IjB0FC,AClBO,AatBJA,GRmCA,CXtBI,AFkBA,AOSH,AGdH,ALhBA,ADqBD,AkBzBO,CAAC,EDNE,CrB+BC,AULN,ALhBA,AOiCH,AO/CS,EEIE,CnBaC,AK2BH,CAAC,AelCG,ADNZ,CX0BO,AYpBM,A9BAZ,CoBqCI,CV9BU,AGHN,CHGO,AEmBlB,CQWU,CPjCI,CLqBO,COSF,EelCK,CtByBC,AYYT,AUrCS,CfkCF,AJrCxB,ASwCkB,CUrCU,CpBOC,CAAC,AFkBA,CAAC,COSF,AKGN,CLHO,AF9BH,AOiCH,AUrCS,CAAC,CjBIL,CHGO,AGHN,AGYb,AIqBU,CV9BU,AFkBA,AIC9B,AQWqB,CZZU,AYYT,CFjBM,AFJnC,AchBuC,CfkCF,AelCG,CpBOC,AK2BH,EGdC,CVKK,CElBC,CAAA,AFkBC,AIC9B,EGQ6B,AGdD,ANM1B,CGQ4B,AClB5B,CJUE,EAAE,IAAI,CGQ4B,CAAC,AClBpB,AJUP,EGQ6B,GelCM,CAAC,CAAC,CAAC,CAAC,CAAC,ClB0B7B,CAAC,QkB1BsC,ClB4B7E,CMR6E,EAAE;APrBjF,AZDA,AkBEA,AYLG,AtBKH,ADAA,AgBrCE,ApBoCF,ADJY,AsBKZ,AzBDA,A6BRU,ACSV,AIxDA,ItBgEI,AWsBI,CXtBH,CCTC,CFgCC,CMIL,AF9BA,AGYA,AJUA,AkB1BM,CVqCL,AUrCM,ARtCFpM,Gd+DK,AUJT,CNKG,AXhCa5D,CWgCZ,CCtBE,AGYA,CEKF,AYrBS,A9BAZ,C8BAa,AHVA6G,EnBmCE,AQTN,CAAC,CEKF,AS/BS,CdcL,AcdMC,EhBQE,AEMN,AbJN,AsBtCV,ENsDkB,AchBM,CnBFC,AKkBN,AchBM,ARtCF,Cd+DG,AG3BA,CH2BC,AsBzBA,ARtC3B,ArBgCiC,CAACpG,CUIL,AU+Bf,ArB7BG,A2BVF,CX0BS,AW1BMe,ChBQC,AKkBN,AchBM,A9BAZ,CqB6BpB,ApBnCkB,CO+BgB,AP/BM,C0BJL,CAACG,CnBmCC,AmBnCA,CnBmCC,AP/BpB,CO+BoB,AOSL,AY5CE,CZ4CD,AdxCYnB,A0BJ9B,CX0BmB,AJUD,AepCzB,CX0B2B,CEKA,AGQpB,ALbqB,AftBnB,CWgCmB,CXhCc,CcwCX,AdxCtB,CiB2BsB,AjB3B7B,CcwC+B,AMLV,IHRa,CAAC,EHaG,CAAC,CGbA,OHaQ,CAAC,CAAC,MHRK,CAAC,gBMLsB,EAAE;AnBvB3F,AkBEA,AVAA,ADAA,AgBrCE,ApBoCF,ADJS,AsBKT,AzBDA,A6BRS,ACST,AIzDA,ItBkEI,ADsBO,AEhCP,AKkBH,CDkBC,AClBA,AchBG,CAAA,ET6BH,CbJO,Ac/DFoD,AK0BC,CAEE,ENuCJ,ARzBH,CQyBI,ADOE,GFfL,CTSoB,AWMX,AO9CIkD,ClBwCQ,AkBxCf,CL5BR,CT0CS,AbJN,A2BVe,CdcR,COgCM,AE1EE,CF0ED,CXNiC,ASTxC,CLjBI,AbJN,CS8B4C,ASTxC,AGQM,ARzBH,AS1Cf,CJ2Da,AGQM,GDOK,CTtCK,ASsCJ,EPhCH,CAAC,CQyBI,ARzBH,AbJN,CqB6BU,ADOE,CAAC,EXN0C,EAAE,CWMvC,CAAC,EAAE,IXN+E,AYDrF,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC;AtB/B/D,AkBEA,AYLE,AtBKF,ADAA,AgBrCE,ApBoCF,ADJK,AsBKL,AzBDA,A6BRU,ACSV,AI1DA,IjB8FC,AJrCG,AU+BH,ALXA,AJOA,AkBxBG,CT4BF,ATJA,CiB/BIkJ,CEJC,CtBwCC,ADJA,AOSH,CczCI,APhCFnM,CXoCG,AmBGA,ErB6BE,AI1BT,AOgCA,AUnCS,ADPA,ErBgCE,COSF,CAAC,AGdT,AYpBY,CDPCwL,AFJA,CP8CR,AUnCS,CjBGR,CgBVE,APhCV,CF0EU,CPhCC,CFNU,AWpCF,CtBsCf,A6BNkBU,CpBoCC,ASTZ,CHcU,AJrCqD,ASsC3D,AUnCS,CtByBC,AYUT,CLDO,AelCG,ARvC1B,CboE2B,AkBxCnB,CnBoCoB,AG5BkD,CXEnE,A6BNkB,CT0CR,AS1CSC,CpBoCC,AEhCkD,ASsC3D,CZVU,AKtBT,CJ0BU,ADJA,AG5BkD,AkBJnF,ClBImF,AEM1D,AgBvBC,ChBuBA,AbJT,A6BLjB,C7BKkB,I8BCsB,EAAE,EtByBE,CAAA,AsBzBC,E9BDhB,EAAE,CAAC,G8BCqB,CAAA;A/BHvD,AkBEA,AVAA,ADAA,AgBrCE,ApBoCF,ADFC,AsBGD,AzBDA,A6BRS,ACST,AI3DA,IDkDW,ApBQP,AUgCH,ATLD,AkBxBI,ItByBI,AOSN,CF/BC,AOgCA,AE1EIlM,CS4BU,ApBQP,AmBGA,CCXQ,CtBuCmB,ADHzB,CULR,GYpBY,GAAG,C9BDd,EYyBJ,CD3BsB,CWpCrB,CbmEgD,ADHzB,AR1Bf,CWFgE,CoBRxC,AT5BT,CS4BU,AtBuCkB,AqB5BzB,CrB4B0B,ADHzB,CCGyB,AE/BwB,CWpC5E,CQuC8B,C9BDd,C8BCgB,CAAA,ECXkB,ApBQiC,EoBR/B,ApBQiC,CH4B/C,AG5B+C,EIqCnD,CAAC,CPTO,IAAI,CuBpC2B,AvBoC1B,AOSN,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC,EPTQ,EAAE;AID3E,Ab3BA,AkBEA,AYLE,AtBKF,ADAA,AgBpCE,ApBmCF,AqBCA,AzBDA,A8BCA,AI5DA,CpB6EA,AAQC,CARgC,EDlB7B,AmBGA,CfkCF,CHnBmC,AiBtB/B,CbwBF,AaxBGkM,CEJC,AlBcN,CJwBsD,AGJvD,AU7DMjM,CXmCG,AmBGA,ADPJ,EEJM,AvBoCA,AUJT,CahCU,AX6CJ,CSxCH,ChBSG,AiBHM,CZqBR,AW3BC,CPhCN,CQsCgB,CtByBC,CsBzBC,ARtCF,CJ2DN,AYrBQ,CZqBP,CW3BEiM,CELS,A/BUlB,AsBrCgBhM,CS2BG,AlBchB,CKkBQ,AW3BT,ClBGmB,GAA4G,CXE1H,A6BLU,APhCL,Cd+Dc,Ac/DF,Cd+DG,CG5B0G,GAAG,AEMzH,AbJF,CAAC,CWF4H,AkBH1I,ClBG0I,AkBJ1I,ChBUmB,CSzCMC,Ed+Da,AqB9BtC+L,CX0BoC,CahCI,CAAC,AvBoCA,AUJH,AW1BnC,ChBQgB,CbJM,AsBrCD,CS2BoB,CAAC,AvBoCA,AR1BlB,A6BJpB,APjC2B9L,Cd+DY,AR1BlB,A6BNhC,EAEc,EhBQiB,CAAC,ASzCJ,EAAqB,CS2BS,CAAC,ClBctB,CkBdwB,AlBcvB,UAAA,GLsBoC,CAAC,GAAG,AKtBjC,ILsBqC,AKtBjC,CLsBkC,MKtBlC,OAAO,CAAC,ULsBkD,CAAA,CKtBtC,CAAC,EAArB,CAAqB,CAAC,EAAhD,CAAgD,CAAC,CAAC,MAAM;ADYpE,AblBb,AkBEA,AYHI,AtBGJ,ADAA,AgBpCG,ApBmCH,ADHA,AsBIA,AzBDA,A6BTM,ACUN,AI7DA,IjBkGC,AJtCG,AEMH,AGcO,AchBJ,CjBEF,CSzCC,CZ6CI,AWsBH,CZFI,CDFC,AqB9BAmL,A5BDA3O,C6BOC,ECZE,AtBsCA,AWOT,AUjCS,ADNR,APjCG,CAACyD,GJ2DJ,AW1BY8L,ETuCP,CW7CS,AtBsCC,CSNX,AYpBY,A9BFf,AsBrCF,CFwES,CAAC,AUjCS,CRvCJ/L,CFwEH,ASvCX,A5BDJ,CmBwCgB,AnBxCSvD,CmBwCR,EFbD,CI3Db,EJ2DgB,AjB3BnB,CQiCgC,CRjCC,CWoBT,EMOA,CTMa,ASNZ,AYpBY,EAAE,GZoBT,AYpBY,CZoBX,GFJJ,CPUoB,EAAE,AOVhD,CchBiD,CAAC,IfkCC,AelCG,CAAC,CAAC,EdgB7B,EchBiC,EAAE,EAAE,CAAC,CAAC,CdgBtB,EAAE,CchBwB,CAAC,KAAK,CAAC,IAAI,EAAS,CdgBrB,AchBqB,EdgBnB,iBAAwC,EAAE,UAAyB;AJc3I,AblCA,AkBEA,AYHG,AtBGH,ADAA,AJDA,ADHI,AsBIJ,AzBDA,A6BTQ,ACUR,IlBSW,AK4BV,AMNO,AR1BP,AiBFG,E7BPIX,ESaO,AFkBP,AQRN,AchBM,CCZC,ArBkBO,AU2Bb,ELCK,CNRI,AOVN,CAAC,ENVoC,AFkB5B,AmBrCA0G,CTkCX,ASlCI,CjBmBqC,AK4B/B,AClBH,CDkBI,AClBH,EPUQ,ASLZ,CAAC,ETKc,AqB1BA,C9BFjB,ACLoB,CSaqE,AK4BzE,AelCG,CtBwBC,AOUH,CPVG,AQRL,CAAC,CfvBSpG,EDKlB,GkBuBS,AGOH,CNMa,AGbT,CTKa,AMQH,CNRG,AMQF,AMNjC,ALZ8B,AhBlBZ,CgBkBa,AhBlBZ,EgBkBc,CfvB9B,EAAyC,GiB4BX,EAAE,KAAK,CAAC,IAAoB,KAAK,CAAC,IAAK,kBAAwB,EAAE;AHcnG,AhBvCA,AkBEA,AVAA,ADAA,AgBpCG,ApBmCH,ADHQ,AsBIR,AzBDA,A6BpBI,ACqBJ,CbqCC,GPVG,AIYH,CJZI,GuBpCG,ArBkBA,AWsBN,AR1BA,AOgCA,AUlCM,ERvCC8D,EZ6CG,ADoBA,AIxBN,AGcH,AIkBG,EW9CQ,ADYA,CT4BL,CLZF,AchBS,C9BFX,EUQc,AWsBN,ACnEK,CJ4Db,AGOS,AR1BA,COgCC,CEzEM,CTyCU,CKmBtB,CTKgB,ASLf,ALnBuB,CAAC,AGcjB,AJoBJ,AkBpCa,CpBMC,CDoBC,AqB1BA,CrB0BC,AOVT,CPUS,CsBtCE,CrBkBC,AY7CXC,CDmEM,ALZH,AchBS,CCZC,AVwCN,ALZH,CchBU,ERvCT,CS2BY,AnBgDL,CQFS,AEzEZ,CV2EK,AQFQ,CW9CF,AbiCf,CRfgB,AQef,CajCwB,AbiCvB,CajCuB,ArBkBP,CWsBL,AS5BM,CdgBR,AJoBY,CSRR,ALZH,AchBS,CT4BL,ATQS,QIpBJ,CAAC,CAAC,EchBW,ClBoCoB,CkBpClB,SAAS,EAAE,GAAG,eAAe,CAAA;AfuB3F,AhB3BA,AkBEA,AYHE,AtBGF,ADAA,AgBpCI,ApBmCJ,ADHQ,AsBIR,AzBDA,A6BTG,ACUH,GDzBY,CnBqDA,AaGX,AMxDC,CNwDA,CQlCI6L,ClBEC,CoBRC,AlBcN,ADiCiD,AQDjD,AUlCM,ADNA,APjCJ,CbiEK,CDDS,CqB/BPH,A5BDIzP,C8BLH,ArBkBA,AGJN,AGcH,AIkBG,CW9CO,ADYA,A9BFT,C8BEU,ARvCN,CAACsD,CNuDF,CEKF,AFLG,CchBU,ADNA,ChBQL,AOgCA,AUlCM,ADNA3C,CnBYC,EGJJ,AiBFM,CCZC,ArBkBA,ATbI,CmByCT,AnBzCUN,C8BLH,AX8CN,ASxCR,APjCP,CZ6CsB,CMUR,CNVU,AoBNA,ARvCN,CNuDF,AatBSmP,C5BDF,CSaI,ATbvB,CSawB,CAAA,AU4BL,AEzEvB,CFyEwB,IPhCI,ADiCmB,ECjCjB,ADiCiB,AiBzCjD,ChBQiC,EOgCE,AUlCM,CAAC,CAAA,GVkCF,MLDzC,EKCiD,EAAE,ERC4B;AGOhF,AhB9CA,AkBEA,AVAA,ADAA,AgBpCI7L,ApBmCJ,ADHK,AsBIL,AzBDA,A8BCA,AInDA3C,G/B2CiC,A+B3C9B,CrBkDC,AUiCH,ApBnCG,IQiCI,ADFA,AKvBN,ADiCA,AkBnCM,ARvCJ2C,CZ6CK,CCVC,EoBRE,AtBuCA,AGQN,AQDH,AUlCS,EtByBE,CKvBL,ASzCE,CJ4DP,AFLA,AMvDQI,CdgEK,AR5BP,GQ4BU,AG7BA,AOyBZ,CAAC,AEaG,AEzED,CTyCK,AiBFM,ARvClB,CS2BmB,ApBQA,AKoBZ,Ce5Ba,AvBqCA,AG7BA,AEMN,AiBFM,CtByBC,AIUN,EGMQ,ACzBZ,AJmBM,CInBL,GRSe,CAAA,EG7BW,AOyBpB,CAAC,CPzBqB,ASsCf,CAAC,GLOkB,EAAE,GgBrDL,ApBQa,CoBRZ,AbiCZ,CPzB0B,COyBxB,CPzB0B,EI6CK,EgBrDd,AbiCZ,CajCa,AbiCZ,CajCa,CbiCX,YajCwB,EAAE,aAAa,EAAE,EAAE;AhCQvF,AkBEA,AYJE,AtBIF,ADAA,AgBpCI,ApBmCJ,AqBCA,AzBDA,A6BVE,ACWF,Ib4CC,EchDK,CPnCH,AK4BI,CjBoBC,AFmBA,AOgBH,AJ7CG,CI6CF,EYvDKqC,CjBoBC,ADqBA,AIzBT,ADiCA,AQAA,AUnCS,AHdA,CX8BR,AavBSwJ,CrBgCC,CAAC,AqBhCT,AFPS1O,CIEC,AnB+CT,AQAA,ApBtCH,CYsCI,AkBnCS,CrB2BC,ADFA,AG7BA,AmBIA,CnBJC,AgBVA,CIEC,AbiCf,ALnBM,AgBTS,AFPAG,CnBuCC,AKvBT,AchBO,CnBuCG,AOgBH,AezCG,AHdpB,ClByCqB,AqB3BA,A9BHZ,Ce4CU,AGpBZ,AEcM,AOjDSA,CTmCd,ALnBM,AchBS,ClByCC,AIzBT,COiCC,CZVU,AR5BZ,A2BXYN,CnBuCA,AG7BC,AXCZ,CS8Ba,AE/B6B,AkBHzD,CpBkC6B,AGQT,AejDpB,CfiDqB,AQAA,AS1CS,CELC,AlBcT,AOiCA,AOjDSqF,CIEC,AlBcT,AchBS,CdgBR,EkBdW,AJFAlF,CIEC,EpBQ+B,AmBI7B,CZqBd,AEcM,AOjDS,ChBU8B,AOyB5C,AEcM,AOjDS,CTmCd,CNcO,AejDSG,ChBU8B,ACuCtC,AejDK,CfiDJ,AejDnC,CIE6C,ApBQ6B,CoBR5B,AtBuCA,AkBzCA,ClByCC,CsBvCC,ADYA,CVmCR,CAAC,CUnCU,CAAC,CrB2BC,AqB3BD,ErB2BG,AWQT,CAAC,GAAG,CAAC,CAAC,OXRgB,CAAC,CAAA;AV/BvE,AkBEA,AYJIuO,AtBIJ,ADAA,AJDA,AqBCA,AzBDA,A6BVI,ACWJ,ICJIA,EAAE,ErBgCE,AOgBN,AYvDMnJ,CfiDL,AkBnCM,ADPA+I,GnBaG,ADqBA,ADFA,AG7BA,AEMT,AGeA,AIkBA,CpBtCC,C2BXU,CZuDL,AYvDMpJ,CdgBR,AGeA,AW/BO,CTmCT,AFJG,AIkBA,AOjDA,EhBUW,CoBRC,ArBkBA,ADqBA,AMcN,AchDV,CnBaiB,ADqBA,AMcN,AFvCH,AOiCA,AOjDS,CPiDR,AOjDSM,EIEE,CrBkBC,ADqBA,AWQT,CPjCC,AGeA,AIkBA,CV7BU,ADqBA,AOVT,CIkBC,CZVqB,AKvBpB,CLuBoB,AmBvCV,CjBoBC,AiBpBAN,CjBoBC,ADqBA,AWQT,AOjDO,ClByCG,AIzBT,AchBpB,ClByC6B,CsBvCE,AX+CT,AOjDS,CIEC,Af6BT,CAAC,CHfC,EHIW,AMWT,CNXU,EGJP,AOiCA,CAAC,EPjCE,CHIU,CAAC,AGJT,CHIU,CAAA,AU6BR,EAAE,CAAC,GAAG,CW/CU,CAAC,EX+CP,CW/CU,CAAC,AX+CT,CJlBT,AIkBU,CJlBT,CIkBW,EAAE,OJlBH,Ce7BoB,CAAC,Af6BnB,Ee7BqB,af6BN,EAAE,iBAAiB,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;AjBrB/G,AkBEA,AYJG,AtBIH,ADAA,AgBpCG,ApBmCH,ADJI,AsBKJ,AzBDA,A6BVMH,ACWN,Kb4CE,CdjDM,A0BNFA,CN2CF,ApBrCKvG,COiCD,AsBzBA,A9BHN,CUSO,ADqBA,AOVN,AhBpBA,A2BXM,C3BWL,AsBpCKsE,CtBoCJ,CQ4BO,AsBzBA,ClBkCH,AehDI,GhBUG,AO0BZ,ALpBA,AOiCA,EE1Ea,CTyCV,AchBYoC,CPiDX,AOjDF,CToCG,AI7DW,CdgEE,AsBzBA,ECZE,ADYA,CtByBC,AG7BA,AVJE,COiCD,CAAA,AG7BC,ASuCZ,CTvCa,ESuCV,AnB3CcvG,CqB/BZoE,EXmCa,EAAE,CWnCV,CXmCY,CAAC,ASuCZ,AE1EG,CXmCU,ASuCZ,CAAC,CW/Ca,ApBQA,ASuCZ,CW/Ca,AX+CZ,GW/Ce,CAAC,EbkCR,CAAC,AjB9B9B,CUIyC,EAAE,CVJG,CAACvE,G8BJC,ApBQA,CoBRC,ApBQA,SAAS,CAAC,IVJ5D,CUIiE,EAAE,EAAE,AVJEM,CUID,CoBRC,CAAC,GAAG,CAAC,K9BIhF,EAAyF,M8BJI,CAAC,CAAC,CAAA;AhCQnG,AkBEA,AVAA,ADAA,AgBpCI,ApBmCJ,ADJQN,AsBKR,AzBDA,A6BVK,ACWL,Ib4CC,AMZO,ArBhCP,ACLOA,CDKN,A2BbE,GjBqBM,ADqBA,ADDF,AOgBH,ACxBH,AMxDE,GKyBO,CnBuCC,AIST,AkBlCS,ERvCJ,CZ4CS,ADqBA,AOTR,AMxDA4D,CXmCO,AO2BZ,ANWG,AQCH,CRDI,AkBlCS,CAAC,CdiBL,CNZS,ADqBA,ASHd,ALrBH,AGeS,Ce7BO,AhBqDH,CLpCM,ADqBA,AqB1BF,A7BRI,CW0CZ,AkBlCS,CVmCX,CFZC,ALrBH,ASzCN,ArB+ByBtD,CciDN,AJ7CG,AO2BZ,ANWG,EDtCW,AEMf,ASzCS,CNwDC,CEML,AFNM,CLrBO,ASuCZ,ETvCc,ASuCZ,AE1EjB,CXmC8B,CH6BC,AOgBH,AJ7CG,AmBIA,EfyCD,AJ7CG,AEMf,AZVd,COiC8B,AKvBf,ADgCM,CJTU,AQRN,AJiBH,CJTS,AQRL,CAAC,CHfR,EAAE,CAAC,AiBFe,CnBJC,EAAE,AmBIA,CZuBL,AYvBM,CAAA,CZuBJ,IGML,GAAvC,UAAwC,KVjCc,EAAE,CAAC,QUiCO,EAAE,eAAuB,EAAE,iBAAwC;AtBjCpI,AkBEA,AYLE,AtBKF,ADAA,AgBpCI4D,ApBmCJ,ADJQ,AsBKR,AzBDA,A6BVMqC,ACWN,IZoBC,AhBpBD,CgBoBE,CW/BIA,CEMCgJ,CrBiCC,AOgBN,AMZA,ACpEErL,CQuCK,AHdA,E1BMM5D,CSaH,ADqBA,AGQT,CehDU,CLzBH,CPgFD,AMZA,ACpEEiE,CXmCK,ACsCT,CJTU,AKvBZ,ADgCG,EGOK,AMZA,AM3CM8B,CIEC,ArBiBA,ADqBA,AMeN,AGlBT,AGMS,ADMT,AE1EK,CZ4CW,ADqBA,AE9BA,AWnCjB,CtBoCH,CWDsB,AO2Bf,AjB/BmB,CiB+BlB,AW/BP,A5BA0B1F,CYUf,AOiCH,CV9BgB,ADqBA,AGQT,AehDS,CjBmBC,ADqBA,AkBxCA+F,CjBmBA,ADqBA,AoBlCCwJ,AFNF,CfgDN,AehDd,CdgBY,AgBVhB,A5BAyB,CAAnB,CUIwB,AO2Bf,CanCgB,AbmCf,AEYA,CW/CgB,AvBqCA,AIST,CJTU,AKvBZ,ADgCG,CMXL,ELrBK,EkBdc,CAAC,AbmCf,CAAC,ALrBG,ILuBwB,CUFtB,ALrBG,CKqBF,AGMS,CAAC,CUzCO,CAAC,CAAA,AlBcX,GAAG,EAAE,CAAC,OQ2Ba,EAAE,eAAe,EAAE,CR3BL,CQ2BO,iBAAiB,mBAAA,EAAE,CAAC,CAAC;ArBhCrG,ADDA,AkBEA,AYJE,AtBIF,ADAA,AgBpCI,ApBmCJ,ADJK,AsBKL,AzBDA,A6BVK,ACWL,C5B7BA,AA4BC,GqBiCA,ALZD,CDwBE,AMZA,ArBjCD,E6BHMV,APnCJ,CQ0CK,CpBKC,ADqBA,AGQN,GJTS,CG7BC,AEMT,AiBFS,CnBJA,AmBIC,GCZG,CvBqCC,AsBzBA,ADPhB,CCOiB,CZuBd,EYvBiB,ADPAO,CbwBrB,AcjBsB,CVmCjB,AUnCiB,ItByBK,CUFd,AW9Be,CAACI,CrBgCC,CAAC,CAAC,AYUlB,ES1CO,CrBgCc,AYUlB,GS1CqB,KAArC,CT0CyB,EZVoB,CAAC,GAAG,CAAC,CAAA,SYUN,CAAC;AJlB/C,AhBjDa,AD4Bb,AkBEA,AYJE,AtBIF,ADAA,AJDA,AqBCA,AzBDA,A6BVG,ACWH,CZpEA,AAuFC,GNXG,ADqBA,AMeH,AMXA,CXzBI,ADqBA,AOVJ,EavBMV,CdgDF,AJ7CG,ACuCN,AkBlCM,CnBLC,CAAC,CI6CF,AJ7CE,CoBRE,AvBqCA,AIUN,AkBlCM,CCbC,CAAC,AhBqDH,AchDT,CELY,CvBqCE,AIUN,CMZL,ALtBK,ADkCC,AkBlCM,CDRCM,CCQC,IfwCC,CAAC,AKNf,CS1CmB,CrBgCC,AIUN,AiB1CMK,EjB0CJ,EJVQ,AOgBH,AKNf,CLMgB,CchDV,ErBgCgB,AR1DV,EQ0DY,AqBhCA,CAAlC;AbhEW,AjBmEb,AkBEA,AYJE,AtBIF,ADAA,AgBpCG,ApBmCH,ADLI,AsBMJ,AzBDA,A8BCA,IlBSY,ADqBR,AMcH,AJ7CG,CAAC,CAAA,AVLG,C4BEDV,EELE,CT3BAlL,CPgFD,CHNL,AkBlCS,EDRV,ErBgCc,AUFZ,ALtBA,ADkCG,CAAC,AkBlCS,CAAC,ADRAuL,APhCD,EJ8DT,AEYH,CE1Ee,CTwCV,AiBAY,CAAC,CfwCF,CAAC,AGlBT,AEYH,AS1Ce,CnBaS,AQiBpB,AYtBY,ADRAM,CnBaS,EE6Bf,CMZF,CHkBU,AKNZ,AE1EI5L,CV0EG,AkBlCS,CpBK8B,AFmB7B,AqBhC/B,CdgD6B,CLnCiC,CFmB5B,AQjGX,AJ2GE,CGMO,AHNN,CU1ED,EZ6C0C,AFmB7B,AchET,CPgFO,MGlBG,EAAE,CVEO,CAAC,CAAC,EOgBD,AHNN,CJVU,AOgBH,CHNL,CAAC,IGMU,CAAC,CAAC,EAAE,CPhBI,CAAC,CAAA,AOgBF,CAAC,KAAK,EexCK,KAAK,EfwCD,GexCM,CfwCF,AexCG,CAAA,YfwCU,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC;AAC/G,AhB9CA,AkBEA,AYJE,AtBIF,ADAA,AgBpCI,ApBmCJ,ADLQ,AsBMR,AzBDA,A6BXE,ACYF,Cb4CC,GJ5CG,GkBJGkL,CnBaC,AY7CJ,CV0ED,AkBlCM,AHhBApJ,EhBYE,CDSC,ACTA,AgBZV,CIEa,AvBsCF,AKxBT,CFJ6B,AWpCzB,CAAC5C,CXoC0B,CoBVhB,ArBmBF,CqBnBG,EboCf,CRjBgB,EqBnBI,AboCjB,CapCkB,AboCjB,AEYH,AS1CJ,CnBauB,EAAE,CmBbCoM,EPhCxB,CS0B6B,AT1BRnO,CS0BS,AboCjB,CAAC,AEYH,ETtCkD,AkBJ9B,APhC/B,CJ8DiB,AEYH,AS1CkB0O,APhCN7L,CXoCqC,EAAE,CAAC,AO0B7C,CAAC,CapCkB,CAAC,AT1BzC,CXoCsE,CSsC/C,EWhDsB,CAAC,EFMtB,IAA0B,ClBI+B,CAAU,CAAO,CoBV1C,CAAC,AFM3D,CT0C0C,CAAC,GWhDqB,ApBU2C,CoBV1C,CAAC,ApBU2C,KoBVtC,CpBU4C,CoBV1C,CpBU4C,CoBV1C,CAAC,MpBUiD,CoBV1C,CpBU4C,EAAE,EoBVzC,KAAK,QAAQ,CAAC,EAAE;AhBwD1G,AhB/CA,AkBEA,AYJE,AtBIF,ADAA,AgBpCI,ApBmCJ,ADLQ,AsBMR,AzBDA,A6BXC,ACYD,CDhDA,EAuCA,IN0CI,AQrCG8L,APlCJ,CXsCM,ACuCP,AkBlCM,G7BXOvQ,C8BJH,ArBmBA,AGLT,ADmCG,AkBlCM,ADTV,CjB2CK,GDvCkB,CH2BN,AG3BO,CoBVR,ArBmBA,CGLR,ADmCG,CF9BO,AQiBf,CVCkB,AOkBF,CgBvDC,AlBcT,ADmCG,EQDV,CUjCmB,EAAE,ClBkCL,CDvCgB,AO0BxB,ANaS,AX7CU,CmB4CrB,AnB5CsBW,C8BJH,AvBqCE,AOkBQ,CgBvDT,ApBUS,CI6CE,CLpCT,CFkBG,CElBD,ATfH,CUMa,AVNtC,CUMsC,AEIjB,CHKU,AKoCoB,CFzC5B,CLuBY,AKvBX,ELuBa,CElBD,CAAA,kEqBnBmE,CAAC,CAAA;AhCShH,AkBEA,AYJC,AtBID,ADAA,AJDA,ADLK,AsBML,AzBDA,A6BRA,ACSA,ECFA,C5BPI,CcsDH,AMZa,ApBvCR,IcmDD,AJ7CG,ACuCN,CmBjDO,AlBcN,EZVUN,CSeD,ACTA,ACuCN,AkBlCM,A7BXN,CW6CC,CGMI,AdnDI,CcmDH,CLpCI,AFkBA,CUDX,AYrBY,CAAC,EnBLE,ASsCf,CLOa,CexCI,CpBIC,ACTA,AmBKA,CpBIA,AKoCF,CKPX,CUjCgB,EnBLE,CAAA,CCuCJ,EkBlCQ,CtBsBC,AIYN,CGMI,CAAC,CPlBI,AYWf,IZXmB,COkBF,EAAE,QPlBW,AaMT,CbNU,AIYN,CJZO,AIYN,CSN9C,EbNuD,CIYL,CAAC,IAAI,CAAC,CSNd,GbNwB,CAAC,CAAA,AIYL,CAAC,CAAC,SSNE,EAAE,ES5Be,aT4BQ,AS5BK,ET4BH,GS5BQ,CAAC,CAAA,QT4B2B;AtBlClI,AkBEA,AVAA,ADAA,AgBpCGqE,ApBmCH,ADLQ,AsBMR,AzBDA,A6BRA,ACSA,MNpCGA,CbkEI,CMeL,AJ7CM,AEIN,ADoCA,AX9CU,C6BWH,GpBIG,AY7CH,CSyBM,AvBsCF,Ac/DHC,EPiFD,AFzCA,CFJO,AO0BZ,CP1Ba,CDSC,EKoCJ,AJ7CM,AO0BZ,CRjBa,AKoCN,CJ7CO,CAAC,CSsCjB,CV7BmB,AQiBZ,ALtBJ,CHKiB,AQiBZ,GI9DX,CJ8De,AI9DSH,CXoCI,EDSE,AU6BlB,CV7BmB,ACTA,ESsChB,CPlCG,CFJiB,AWpCnC,CXoCoC,CAAA,AWpCF,CTwCZ,IOkCE,EFZc,CLtBhB,CHKwB,AQiBN,CRjBO,MAAM,AGLvB,CHKwB,AGLvB,CHKuB,GGLnB,CAAC,GOkCU,CAAC,MPlCX,OAAO,IAAI,OAAA,MDoCwC,CCpCjC,CAAC,YAAY,CAAC,EAArB,CAAqB,CAAC,EAA/C,CAA+C,CAAC,CAAC,KAAK;AdL/E,AkBEA,AVAA,ADAA,AgBpCII,ApBmCJ,ADLY,AsBMZ,AzBDA,A8BCA,InB8BW,AI1BV,ADoCA,CGKC,AFzCA,ADoCA,GDvCM,AmBKA,AR1CJA,ISyBQ,ArBoBA,ACRA,AmBKA,CnBLC,EAAE,EDQE,AFiBE,AGzBF,GOyBZ,AI9DW,CZ6CK,ADqBO,AqBxBP,CpBGC,ADqBO,AalEX,CSyBK,AbqCf,AYpBe,CCjBC,AbqCf,AEYH,CV7BmB,CAAC,EAAE,ADqB4B,CCrB3B,CDqB6B,AWQ9C,EV7BoB,AQiBf,CAAC,GAAG,IAAI,CAAC,ETIqD,EsBzClC,CAAC,ArBoBA,CAAC,MqBpBM,ArBoBA,CqBpBC,CAAC,ArBoBA,CAAC,EAAE,EAAE,QqBpBQ,EAAE,aAAa,EAAE,EAAE;AlBgBvF,AdNA,AkBEA,AYJAF,AtBIA,ADAA,AgBpCKG,ApBmCL,ADLY,AsBMZ,AzBDA,A8BCA,CfIC,GEyCA,AHJO,EiB7CF,CAACiJ,CpBkCC,AMeH,EOjFAjJ,EbkEO,AE7BA,AmBKA,CR1CJ,ArB8BW7E,EqB9BT,CSyBM,ArBoBA,AFiBA,AGzBA,CI4CF,AKPT,AUhCY,CAAC,ECjBE,AhBwDH,AGnBZ,CHmBa,AJ5CG,AkBLrB,CdiDmB,AJ5CG,AmBKA,ADVAgP,CnBaC,AoBHA,ErBwBE,CCrBC,AoBHA,GrBwBG,AE7BA,AOyBf,CarCgB,ApBYA,AkBLA,CEPC,AFOAjN,A5BFM,CW+CxB,AkBnCmB,A7BZMtB,CQoCL,ADJA,ECIE,AGWlC,CJfmC,APhCjB,CAAwB,C8BLL,CAAC,CrBoBC,AFiBA,AqB9BxC,CnBayC,ATftB,CSeuB,AmBbA,CnBaC,ATfME,CSeN,GmBb3C,ElBKiD,AkBLA,A5BF9B,CUO+B,AVPtC,COgCuC,CuBrCC,AvBqCA,AGzBA,CoBZC,AvBqCA,GuBrCG,AvBqCA,CuBrCC,CAAC,IAAI,KvBqCK,CAAC,CAAA,EsBpBG,ICjBI,CAAC,GAAG,CAAC,ADiBA,KAAK,CAAC,CAAA,ECjBG,CAAC,EAAE;AlB5D5F,AdsEA,AkBEA,AYJEmE,AtBIF,ADAA,AgBrCU,ApBoCV,ADLS,AsBMT,AzBDA,A6BVAhF,ACWA,ECJEgF,EdiDD,CcjDI,A5BLG,CAGE,C4BEH,AFPA,CfoDL,AepDMmC,CGiBC,EfuCD,CNhB6B,CDHxB,AYYT,AnB5Ca5G,CAAP,CW+CD,CFhCO,ACRA,AVPG,CiBgCd,AW9BYmQ,AFPjB,EfoDa,AiB7CN,APjCS,CS0BI,AJAA,CZwDF,AcjDG,CdiDF,AJ5CG,CDQC,CqBpBC,ArBoBA,CDoB0B,AalE9B,CAAC1M,CPkFG,CNhB6B,AMgB5B,AMfvB,CXrB2B,ADoByB,AE5BzB,CF4ByB,AE5BxB,AgBZDoD,CfoDJ,CFhCQ,AEgCP,AepDN,ChBYa,CAAC,AgBZDC,CIAE,CAAC,AnBoDN,CAAC,AepDX,CjBoB8B,AKoCzB,CLpC0B,AiBpBb,CdcrC,CSxCS,EV8E2B,CFhCmB,CAAC,AEgClB,GGIJ,CMf3B,ATWmC,CAAC,EFhCoB,CAAC,ACRZ,AU6BzC,CV7B0C,AU6BzC,ETWqC,CmBpDO,ApBYA,CoBZC,ArBoBY,ACRZ,ACwCN,CDxCa,CDQO,CqBpBX,CAAC,AnBoDN,CDxCa,ACwCZ,CAAC,CDxCa,CU6B9C,CXrBsD,ACRN,AU6B/C,CXrBsD,GAAG,CAAC,CAAA,EqBpBT,CAAC,EAAE,KVyCpC,CAAC,EAAA;ARzB3C,AdNA,AkBEA,AYJI,AtBIJ,ADAA,AgBtCU,ApBqCV,ADLY,AsBMZ,AzBDA,A6BVE,ACWF,IhByCC,CAAC,AkBnCG,CHjBC,EZwDJ,AcjDM,CpBgCgD,AWUrD,AS1CMqJ,EAAD,APnCU,CdiEN,CEjBC,AKoCN,AYxDM5Q,EEOE,CX8BX,CHmBO,AcjDM,CdiDL,EJ5CQ,AOyBZ,ASrCF,CZwDS,CFzCO,EkBfE,AFOA4Q,CX8BX,ASrCY,CTqCX,AW9BG,ChBQkB,GEyCX,AGnBN,CW9Ba,CdiDL,CAAC,EPnBQ,COmBL,AYxDxB,EnBqCgC,CqB9BvB,CAAP,AFPgC5Q,CIAC,CAAC,AhBwDN,CAAC,CcjDO4Q,CEPC,CAAC,AFOA,CFPC,CAACpJ,CnBqCC,AOmBN,AGnBD,CVAO,AqB9BC,CdiDL,AGnBD,AW9BxC,CdiD0C,CcjDO,CdiDL,EAAE,CgBxDO,CAAC,EpBYE,CgBZpB,KAA0B,IAAhE,EAAsE,OIAO,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC,CAAA;AhCUnG,AkBEA,AYJMoJ,AtBIN,ADAA,AgBtCK1L,ApBqCL,ADLY,AsBMZ,AzBDA,A6BVI,ACWJ,IfIC,ADsCO,AkBnCJ,EDXE0L,EpBgCE,AWWN,AUhCM,ADXA,EPlCH1L,CT0CG,AgBRGmL,AFPA/I,CjBoBC,AFiBA,AOmBT,AKNG,CE7EE,AK2BJ,EL3BM,CPmFH,AFzCM,GHKM,AmBbb,ClBKc,AOyBf,ALtBY,CkBfI,AtBuCA,CWWL,AUhCM,CZmBd,CTEgB,AE3BA,AOyBf,AGEP,ASrBsB,CjBHF,AOmCK,AE7EjBnC,CT0Ca,EJwBK,CAAC,ADFA,AYaE,AE7EjB,CdgEgB,AYaE,CPnCJ,AS1CV,CJgED,ALtBY,CHKI,AKoCT,AGnBN,AGEyB,CXnBV,AKoCR,AMjBmB,EHFvB,ANgBJ,CDzCoB,CAAC,CCyCrC,CJhBuC,AOmBT,CAAC,AGnBN,CVAgB,AOmBT,AGnBN,ALtBY,CLsBI,AOmBT,AFzCM,CJwBI,AE3BA,AEGH,CJwBI,AMiBT,AJ5CS,CHyBC,CAAC,CAAA,CGzBE,ACyC/B,CDzCgC,EAAE,GI4CN,CAAC,ENjBW,AMiBT,AHHd,CHdwB,CAAA;AIvB3D,AdNA,AkBEA,AYJK,AtBIL,ADAA,AgBtCM,ApBqCN,ADLY,AsBMZ,AzBDA,A6BVG,ACWH,CfIC,EclBqC,CAKpC,IlBsCM,ADHA,AIgBN,AQHA,AUhCM,CpBEC,AFiBA,GCGG,AGaN,AQHA,AE7EA,CrBgCa/E,C6BaL,EfsCV,AHHM,AkBnCM,ClBmCL,CUhFD,CF6EG,AE7EF8D,CS2BS,AbqCf,GNgBY,CDzCO,AU2BtB,ADWgB,CLML,AKNM,CXVO,AqBtBA,EfsCV,AHHM,AkBnCM,CrBsBC,AMgBZ,AGnBH,EjBhCuB,CcmDjB,AdnDkBrD,C8BLL,AhBwDZ,AKNM,CWlDO,AtBwCA,AMgBZ,AKNM,AE7EtB,CbmE6B,AqBtBA,C7BbhB,CWgDY,AkBnCM,AR7CRsE,ArBgCc,CQmCL,CAAC,AGaN,CmBrDO,CAAC,ApBYA,AWvCnC,ArBgCa,EQmCwB,ARnCMpE,CQmCL,AWUN,CXVM,CYDnC,CSrBsC,EVgCJ,AUhCM,A7Bb9B,C8BL+B,AVuCrC,ApBlCD,C8BLuC,AVuCrC,CUvCqC,KXkDA,IAAI,QUhCc,CTqBpC,CAAC,ASrBqC,KVgCD,CAAC,KAAK,CAAC,ICX3B,EAAE,EDWiC,AUhCM,CVgCL,CUhCO,GAAG,MVgCA,CAAC,CCX9B,CDWgC,CCX9B,ISrByC,CAAA,QTqB5B,CAAC,iBAAiB,EAAE,aAAa,CAAC,UAAU,CAAC,EAAC;ARtBhI,AdPA,AkBEA,AVAA,ADAA,AgBtCM,ApBqCN,ADLS,AsBMT,AzBDA,A8BCA,QnB6BQ,ADFA,AsBpBA,IrBsBI,AGaT,AQHA,CV/BY,AoBDF,CtBoBC,AsBpBA,EfsCV,CgBxDa,AbqCZ,CTGa,AqBtBA,ClBmCR,AkBnCS,CtBoBC,CCEC,CAAC,AIxBA,AOkCT,AUhCS,CrBsBA,ADFC,AOkBZ,CJ5Ca,CSsCR,EZZW,AOkBZ,AFxCoB,CEwCnB,AetCY,EnBNE,ASsCT,CAAC,MZZe,CAAC,CAAC,AYYT,CZZU,AYYT,GZZY,CAAC,CAAC,CAAC,IYYL,CAAC,CUhCU,CAAC,CAAA,CnBNZ,CAAC,YAAY,CAAC,IAAI,CAAC,CAAA,CH0BgB,GAAG,CAAC,CAAC,iCAAiC,CAAC,CAAA;AT5BnH,AkBEA,AYLI,AtBKJ,ADAA,AgB3CkB,ApB0ClB,ADLK,AsBML,AzBDA,A8BCA,IfKC,IJwBO,ADDA,AKvBH,AiBEG,ClBmCL,AQHA,AS5CM0O,GENG,ArBmBA,ADqBA,ADDA,AsBrBA,ADZR,CENS,AtBwCA,AMgBT,AFxCM,CkBhBI,CAAA,CbqCV,ALrBS,AgBVGmB,EAAZ,CnBae,AFoBA,CUFX,CPzBa,CH2BC,AsBrBA,CpBCC,AFoBA,CEpBA,AFoBA,AsBrBC,CZmBX,CAAC,CTGa,EAAE,CSHX,oBAAyB,EAAE,KLrBS,CAAC;AdNvD,AkBEA,AYLIC,AtBKJ,ADAA,AgB7CqC,ApB4CrC,ADFC,AsBGD,AzBDA,A6BVE,ACWF,IfKC,AgBVGA,EFNE,CLlCH,CdyEK,AKvBH,ADqCH,AQFA,AS7CM,CENC,ArBmBA,AKqCN,AclDM,GpBkCG,ADDA,AIcN,AQFA,AUjCM,CtBqBC,AKvBH,ADqCH,AiB/CC,AFNK7Q,CEMT,ErBiCY,AG3BA,AEIH,CLuBI,AG3BA,AmBMA,CrBsBC,ADDD,AG3BA,AmBMC,CnBNA,ACyCL,CDzCM,AOyBd,ASrCC,ChBYa,AEID,CAAC,ADqCH,AQFA,AUjCM,CZmBd,AYnBe,CZmBd,CEckB,AOnDF,CdgBF,CAAC,EOmCO,CAAC,CREP,CMhBR,ALrBY,ADqCH,CMhBR,ALrBY,CAAC,EKqBV,ASrCnB,EAAoC,ClBwCC,CqBtBC,ErBsBE,ISHX,CAAC,GYnBkB,EZmBb,CAAC,AYnBe,CAAC,CAAA,GZmBX,CAAC,CAAC,CTGK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;AV9B7D,AkBEA,AYLG,AtBKH,ADAA,AgBrCG,ApBoCH,AqBCA,AzBDA,A6BVI,ACWJ,GCZiD,CnBoB7C,AGHH,CHGI,AWiBH,GUpCM,AvBuCA,AOiBN,AHFA,AQHA,CUjCO,EjBFD,AchBG,ClBwCC,AGcN,AQHA,CTvCO,AWtCH8D,EPkFD,CHFC,CAAC,CHdO,CWWL,CLKC,AGnBT,CHmBU,AOlFG,CAACU,CK0BG,CPmDJ,CAAC,CRGC,EHdQ,AGcN,CMjBR,ETGiB,AalEb,EbkEe,AWWN,AE7EGE,CS0BI,AtBwCD,AWWL,OE7EV,EAAsBE,CF6EF,KAAK,EE7EzB,CAAf,KF6EgD,IAAI,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,MZZY,IYYF,CAAC,EAAE;ArBzCnG,AkBEA,AYLEK,AtBKF,ADAA,AgBrCG,ApBoCH,ADHA,AsBIA,AzBDA,A6BVM,ACWN,ClBQC,CmBbCA,EdkDD,AMnBA,ApB9BGjE,CciDF,AclDG,AP3Da,CP6Gf,AO7GD,CP6GE,AclDG,CENC,AvBuCA,AKvBN,AiBEM,C7BXC,GQiCG,AE5BA,AEIN,ADsCH,AQHA,AUjCS,A7BXA,C0BPCd,CdgBL,AZTR,COgCe,CAAC,AIeT,CHdU,ASHZ,ANiBG,EmBtDW,AvBuCA,AG3BA,AmBMA,ADZA,CENC,AJAA,ClBwCC,AqBtBA,AHlBAmH,ClBwCC,ADDA,AYYT,CZZU,ECCE,AWWT,CXXU,AE5BA,CAAC,CoBZC,AtBwCA,CAAC,ADDA,AIeT,CQHC,AOnDR,CIAkB,AvBuCA,AYYT,AOnDSC,ClBwCC,AE5BA,AC0CT,CD1CU,AgBZpB,ChBYoB,CoBZE,AJAAC,CIAA,AtBwCC,AGcT,CHdU,AGcT,CetDf,CPmDiB,CAAC,AOnDSnF,IlBwCI,CAAC,AkBxChC,CAAiC,IPmDL,AOnD5B,ClBwCsC,AWWT,COnDUN,ClBwCC,CAAC,AGcT,EHdW,AGcT,CAAC,CHdU,GkBxC7C,CAAP;AjBqBN,AKoCA,AhB/CA,AkBEA,AYLI,AtBKJ,ADAA,AgBrCE,ApBoCF,ADHA,AsBIA,AzBDA,A6BVK,ACWL,Cb6CC,GdjDGb,C0BTA,GIEI,CpBYC,AC0CN,AQHA,ES7CQ,CrBiCC,AKvBT,AiBES,A7BXA,G8BPG,A9BOA,CQiCC,ADDA,AUFZ,ALrBG,AgBVSwO,ChBUR,AiBES,CpBEF,AoBFG,CDZP,CENS,AbqCZ,AW/BJ,A5BCJ,C8BPqB,CtBwCC,AIxBT,AiBES,CAAC,CjBFR,CkBhBU,AvBuCA,AUFZ,CarCa,AvBuCD,AUFX,ERjBW,CAAA,ADoBI,CSHX,ETGc,IAAI,CAAC,MsBxCM,CAAC,AtBwCA,CsBxCA,AtBwCC,CAAC,CAAC,CAAA,AqBtBC,OAAO,GAAG,CAAC,CAAA,EZmBH,EAAE;AHmBzD,AhB9CD,AkBEA,AYLG,AtBKH,ADAA,AJDA,ADHA,AsBIA,AzBDA,A6BVG,ACWH,Cb4CE,Ec3D+C,CEI7C,AnBsDH,AX/CGvO,C8BPC,AnBsDH,ESjBE,CVxBI,ASuCN,CUlCO,GtBqBG,CYaL,CTvCO,EF2BE,AIxBZ,AZTJ,CmB6CW,CZbO,AYaN,CZbO,CUFd,CEeU,CXZO,ADDA,AYaN,CPpCL,CFHa,AOwBf,AEeS,CZbO,CAAC,CG1BC,AEGZ,CAAC,AOoCM,CTvCO,CAAC,AOwBf,CEeU,EFfA,ETGU,ASHR,CVES,AUFR,CVES,AYaN,CXZO,ADDA,AYaN,CZbO,AG1BA,CH0BA,AG1BC,ISuCF,ETvCQ,ASuCN,CTvCO,ASuCN,CTvCM,ESuCH,IAAI,EAAE,CAAC,CXZO,CAAC,AWYN,EAAE,EXZQ,oBAAU,CAAC,OAAO,CAAC,CAAC,CAAA;AMiBnF,AhB/CA,AkBEA,AYLEiN,AtBKF,ADAA,AJDA,ADHA,AsBIA,AzBDA,A8BCA,ECLEA,EELS,AVoCG,ATkBL,AXhDLhN,IUMI,AmBKA,ECjBS,CAAO,CvBuCZ,AYYT,AS9CS,ChBUR,AiBES,CnBLC,AmBKA,ADZA,A5BCA,EQiCE,ADAA,AYYT,CnB7CU,C6BWC,A7BXA,C6BWC,A7BXnB,CiB8BK,ETGiB,AWYT,AUlCS,CnBLC,AOwBf,AYnBe,CZmBd,AYnBc,CrBsBE,AWYT,CTvCU,CoBZc,AhBuDb,CgBvDc,ApBYb,CAAC,ESuCP,CFfL,AEeM,CZZU,AOgBa,AGnB5B,AEeM,CCfC,ADeA,CZZU,AOgBa,AKJtB,CFfL,CapCqC,AVoCzD,CVxBqC,CoBZsB,ApBYrB,ASuCT,ERGP,AQHS,CFfL,AEeM,CLI+B,AGnBpC,CTGK,AGehC,CHfiC,AMgBgC,CJ3CpB,CAAC,AUwBrB,CVxBqB,CoBZ+B,AhBuDE,EgBvDA,AhBuDE,GHD1D,ImBtDyF,EtBuChE,CAAC,EYHA,EUpCsE,CnBsD5E,EGC2E,EAAE,INhB1D,EAAE,CMgB4E,oBNhBvD,CAAC,CAAA;AV9BvF,AkBEA,AYjBiD,AtBiBjD,ADAA,AJDA,AqBCA,AzBDA,A6BVE,ACWF,CCjBA,Gd8DC,EYxDKsG,EZwDD,AJ3CG,AC0CN,AkBpCM,IjBHL,ADuCG,AQFH,AUlCS,AHnBA,GAAG,ClBwCC,ADAA,AOgBH,AFxCN,AOqCA,GLGS,AFxCN,CJwBU,ASHf,ASrCH,EdgBW,AiBGS,ElBoCJ,AQFH,AUlCS,ErBqBE,AGeN,CCvCF,AOqCA,CPrCC,CKqBL,ALrBM,CAAC,CJwBU,ASHf,ALrBM,CJwBU,ASHf,CVGgB,AYaT,CXbU,ADAA,AYaT,KAAK,CAAC,GLGD,AKHI,CZbU,AOgBb,AKHI,CAAC,CZbU,CAAC,GAAG,EOgBX,EAAE,GPhBgB,GAAG,KOgBR,CAAC,CAAC,GJ3CgB,aH2Ba,CAAA;AT9BnF,AkBEA,AYJA3C,AtBIA,ADAA,AJDA,ADHA,AsBIA,AzBDA,A8BCA,Ib6CC,EcjDK,CAACoJ,CdiDF,AJ3CG,CVNC9M,EqBnCR,CS4BO,AlBgBL,ADuCA,AQDA,AUnCS,CtBqBC,COgBF,AJ3CG,EoBbF,AnBuDL,AQDA,CWtDM,AhBwDC,AFxCN,AiBGS,CAAC,ClBoCR,CHfU,ASHf,ALrBM,COsCC,AS/CZ,CCYsB,ADZAgO,CCYC,CVmCR,AnB/Cf,CiB8BU,ALrBM,AS5CVhK,CboEoB,AIxBT,AiBGS,C7BZC,C8BPH,AnBuDN,CmBvDO,ClBgBJ,ADwCjB,AiBjD0B,ChBSR,AgBTSjD,ClBMC,ASyCT,AUnCS,ClBqCzB,AQFiB,ELEC,AJ3CU,CF2BC,AMgBV,AFxCC,AS5C1B,CT4C2B,CAAC,AS5CVkD,CboEoB,CoBjCvC,CT+CgC,CREjB,AQFkB,AS/CS,EjBkDtC,CMpB4B,CAAC,ANoB3B,ED5C0C,ASyCT,AElFtC,CXyCgD,CWzClB,CS4BgB,AXsDL,CWtDM,ApBaI,ASyCT,CLEA,AJ3CU,ASyCT,CLEA,AKFC,AS/C7C,CEPmD,AnByDrC,CmBzDsC,AFOI,CjBmDpD,CGF4C,EAAE,GJ3Ca,AC6CrD,CD7CsD,CoBbH,ApBaG,CoBbF,EAAE,ADmBI,ErBqBE,CAAC,CGkBrD,EACd,GGH+D,CerCW,CfqCT,IerCc,CAAC,CAAA,CfqCR,CAAC,AHG5D,GHnB8D,AGmB3D,CHnB4D,AGmB3D,EACjB,IGJmF,CAAC,CAAC,AHI/E,GAAa,EHpBsE,AGoBpE,CAAC,CHpBqE,CAAC,CAAA;AV9BhG,AkBEA,AYJEH,AtBIF,ADAA,AgBvCE,ApBsCF,ADHI,AsBIJ,AzBDA,A6BXE,ACYF,ECJEA,EdiDD,CcjDI,C5BAG,C4BAD,A5BAEjE,CUMD,CI2Ca,AerCZ,EHpBEyG,CnB0CC,AKzBT,AD6CA,AQPA,CElFM,CXyCK,CVNN,C8BPI,AvByCI,AaNd,AT0BK,AQPA,CZbU,AqBlCAoJ,CPnCH3M,CPoFe,AFxCnB,AZTW,CQiCD,ADCA,AUJf,AjB9BiBjD,CciDD,AYzDnB,CICgB,AlBgBL,CKqBL,ALrBM,CcjBU,Cf8DR,CmB7DM,AtBwCI,ADCA,AUJf,AIjEF,CXyCkB,AkBNpB,APnCgBoE,CVyFJ,AQPA,CS/CU,CpBiCC,ADCA,AG5BA,CoBbH,AvByCI,AYaC,AElFvB,CS4BmB,AbqCX,AIjEWF,ArBmCxB,CiB8Bc,ANwBM,CJpBU,AIoBT,AXtDW,CQiCD,AWcC,CWtDJ,AtBwCI,AWcC,ECnB5B,EbM+B,EAAE,AOeb,AMrBhB,CVtB8B,AUsB7B,AC/DL,CPoFY,AJ3CuB,CoBbH,AT5BAC,CboEK,CAAC,AE3BA,CF2BA,AE3BC,EAAE,CAAC,IAAI,AUsB7B,AC/DjB,CD+DkB,AC/DzB,QXyC8D,CAAA,CI2CnC,EAAR,IAAQ,AMrBc,CAAC,CNqBb,CMrBc,4EUnCsG,CAAC,CAAA;AhCUpJ,AkBEA,AYJI,AtBIJ,ADAA,AgBvCE,ApBsCF,ADHQ,AsBIR,AzBDA,A6BXI,ACYJ,Qb4CM,AJzCE,AEEN,AiBIM,AHrBA,CdiBL,AgBTMuK,AFRAnI,GZwDC,AHMP,AQPA,AUlCS,CCpBH,CpBcK,CgBfV,CnB0CY,AYaT,CXdU,AGqBT,Ae9DS,EZwDA,CGlBZ,ANwBM,AiBtDP,GjBsDU,CAAC,AQPA,AS/CS,CrBkCC,AG3BA,ASwCT,AS/CS,CjBsDR,AiBtDSqJ,ErBkCE,AG3BA,CH2BC,AUJf,ANwBM,CJpBS,CYaP,CROC,AkBzCS,EVkCP,AUlCS,CVkCR,CLCT,AchDb,CT+CwB,OROO,CAAC,CD/CU,CAAC,GAAG,CAAC,AC+CT,EAAE,GAAG,GAAG,CD/CU,CAAC,CC+CR,EAAE,CD/CU,EC+CP,EAAE,EAAE,YD/CqB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAA;AZJlG,AkBEA,AYJG,AtBIH,ADAA,AJDA,ADHK,AsBIL,AzBDA,A6BXM,ACYN,GCPwD,EhBYtD,CAAC,EEuCD,AJzCM,EgBfE9Q,EIEF,ADmBI,CtBqBC,COcL,AJzCM,CIyCL,CgBtDG,AtBuCI,AGqBZ,AQPA,CFjBC,AYjBY,AHrBA,Cf8DX,AkBzCY,AHrBA2H,CZwDL,CAAC,CHML,CHrBa,AqBpBA,CAAC,GAAG,CCnBH,CAAC,AXqDR,CTxCa,ESwCV,CTxCa,AmBMA,ClByCX,CAAC,Ae9DhB,ClByC6B,CkBzCC,ElByCE,CWcX,CROC,AQPA,CTxCa,AC+CZ,GAAG,CAAC,AQPA,CTxCa,AC+CZ,AQPA,CAAC,EWrDU,AXqDR,CWrDS,GAAG,CAAC,CpBaK,EF0BT,AWcD,CXdE,AWcD,CTxCa,KoBbC,AtBuCP,AWcD,CWrDS,AtBuCP,EsBvCS,AXqDR,CAAC,CAAC,CAAC,OTxCmB,CAAC,GAAG,CAAC,IF0BP,GAAG,CAAC,CAAC,AE1BW,CF0BX,AE1BY,CAAA,UmBMW,oBAAoB,KAAK,CAAC,CAAA;AjBHjI,AdPA,AkBEA,AYJE1C,AtBIF,ADAA,AJDA,AqBCA,AzBDA,A6BXQ,ACYR,CfKC,CgBTCA,GR0BA,AQ1BG,EAAE,ClBQC,CmBKC,GfmCN,EYxDW,EIEF,AtBuCI,ASHZ,ANyBA,AQRA,CZZa,CmB3CC3E,CZwDR,AchDS,CX8BX,ANyBA,CJpBa,AOaT,AJxCS,CoBdH,AvByCI,AG3BA,AC+CZ,Ce/DI,CAAUiH,ChBgBC,AOsBZ,CapCS,AtBuCI,ADEA,AG3BA,AOsBZ,CTGa,AGsBZ,Ae/DD,CZwDK,AJxCS,ASuCZ,AOvDR,CZwDY,AKDH,CTvCa,AOsBZ,CapCS,AtBuCI,AGsBZ,CmB7DS,AtBuCI,ADEA,CIoBX,CJpBa,EOaP,AKDH,EAAE,CTvCa,ASuCZ,CTvCa,CAAA,IFyBK,CAAC,CAAA,MsBvCG,QboCM,EapCI,AboCF,0BapC4B,WAAW,CAAC,qBAAqB,CAAC,GAAG,CAAC,UAAU,CAAC,0BAA0B,CAAC,CAAA;AhCSjK,AkBEA,AYJI,AtBIJ,ADAA,AJDA,ADJItG,AsBKJ,AzBDA,A6BXO,ACYP,E3BLIA,EoB4BW,GMrCT,ChBkBE,AmBMA,E7BfI,C4BCD,APpCV,CPoFE,AJxCS,AmBMA,CCpBH,AXqDL,AnBhDW,A0BPF,GlByCG,ADEA,AqBnCA2O,CFRC5P,CZwDR,AdjDL,EciDO,AGlBN,ANyBA,IMzBI,ANyBA,Ae/De,CnB2CC,AmB3CA4H,CZwDR,CHOL,AiBvDD,APpCJvC,CduEqB,AqBnCxB,EjBuDW,CMzBC,ANyBA,CkBzCgB,EtBqBE,AULV,ANyBL,AkBzCe,CrBmBV,ADEU,AaRP,CZMF,ASHC,CPtBH,AOsBI,ANyBL,AU3FrB,CX4CuB,AUmBvB,CT4BuB,AU3FL,EbqEW,AkBzCjB,ClByCkB,CkBzCY,KNmCf,OZMgB,CAAC,CAAA,EEzBA,CAAC,IUmBM,EAAE,IVnBE,CAAC,EAAE,OUmBwB;AtBxBnF,AkBEA,AYJG,AtBIH,ADAA,AgBxCE,ApBuCF,AqBCA,AzBDA,A6BXQwC,ACYR,GCVwD,KRgCF,AMlC9CA,IIGA,AhBqDL,AJxCS,ASwCT,AUlCS,CrBmBC,ADEA,AcvEJ,EK4BM,CAACC,CGsBC,CVkCR,AUlCS,ARlDJ3D,CPoFJ,AKAA,CFlBL,CHkBO,AYxDJ,CGsBc,AHtBAoD,CIGH,ADmBI,CCnBH,AbmCX,ANyBH,CD/CmB,AgBhBjB,ChBgBkB,AmBMA,ARlDjB,CAAchC,CPoFJ,AKAA,CTxCU,CAAC,AC+ClB,AQPS,CAAC,CUlCU,ARlDvB,CV2FM,AU3FcF,CFoFJ,EFlBJ,EAAE,AEkBM,CCtByB,CVlBd,CUkBc,CVlBZ,CW5CjC,CAAP,CS+BuC,AnB4Dd,CmB5De,AnB4Dd,GmB5DiB,CAAC,CpBaK,CAAC,AC+ClB,CD/CkB,AC+CjB,AQPS,CACxC,ERMkC,GAAG,AQNhC,CWtD+C,AnB4Dd,CAAC,AQLvC,CWvDsD,AV+ByB,AT6BvC,SmB5DuB,CAAC,CAAA,AXuDpD,EACZ,CAAC,EACD,SAAS,EACT,EUvCuF,QVuC7E,EACV,UAAU,AUxCiG,CVyC3G,CAAC,GUzC+G,CAAC,CAAA;A/BXrH,AkBEA,AYJE8I,AtBIF,ADAA,AgBxCE,ApBuCF,ADLI,AsBMJ,AzBDA,A6BXO,ACYP,ECJEA,I5BFMjN,C0BRK,EhBkBJ,AS+CN,AUzCM,GCnBD,AtBsCI,AMeT,AchDS,CFRC,CEQC,GrBoCG,CPtCG,CAACG,CckDV,EAAE,CgBrDM,CAAC,AbmCd,ANyBA,CXzDF,CQmCsB,CRnCG,CWyDnB,CHtBmB,AMeT,CAAC,CGlBR,CAAC,ENyBE,IGPa,CHOR,GAAG,EAAE,CmB5De,CAAC,GAAG,CAAC,KbmCT,GAAG,CanCe,EAAE,EbmCZ,CAAC,OanCqB,CAAC,CAAA,CbmCZ,CAAC,QAAQ,CAAC,CAAC;AnB3BnE,AkBEA,AYZwD,AtBYxD,ADAA,AJDA,ADLQL,AsBMR,AzBDA,A6BXQ6G,ACYR,CCZA,G5BMQ7G,CmByDN,AUzCG,GnBLG,AgBjBA6G,CZwDL,AdlDU,CckDT,CAAC,CgBrDG,A9BGQ3G,G0BND,CIGH,AtBsCI,ADGA,AmB5CAyD,IIGA,AvByCI,CAAC,AUNf,AStCE,CAAc4C,E1BMM,C8BHP,A9BGQjG,A0BNrB,ClByCkB,ADGA,CAAC,CCHC,AGsBrB,EmB5DmB,AvByCI,CAAC,APtCf,C8BHY,AtBsCI,ARnCIN,COsCH,CImBpB,CAAC,EXzDE,CAAR,CWyDU,CAAC,EHtBuB,CAAC,SExBS,AC8CrB,CAAC,CHtBsB,CAAC,IAAI,CAAC,EGsBnB,CAAC,OHtB4B,CAAC,CAAC,IGsBjB,EHtBuB,AGsBrB,CHtBsB,EGsBnB,CAAC,CAAC,CAAC;AbpD/D,AkBEA,AYHA8D,AtBGA,ADAA,AJDA,ADLK,AsBML,AzBDA,A6BXO,ACYP,G3BRI,CmB4DH,AU1CG,CfkCF,Cc/CI,CAACoJ,ClBQC,CVXG,C6BgBD,CV0CF,CT/CI,CFwBC,CAAA,EsBtCD,CX6DE,CAAC,AU1CG,CnBLC,CH2BC,AUNf,CYhBgB,ADbrB,CENkB,AFMIkB,CX6Bd,CAAC,EYhBiB,CAAC,ClByCpB,CJnBsB,CqBnCC,CAACjN,CrBmCC,AG3BA,AOqBf,CanCY,AbmCX,CanCY,AnB4DjB,CAAC,CMzBO,CPrBgB,CH2BC,AsBtBA,CtBsBA,AImBpB,CAAC,AkBzCqB,ADbxC,CCawC,CDbE,CX6Bd,CAAC,CPrBgB,CoBdH,CAAC,GFM3C,EAAoD,KENC,CAAC,AnB4DjB,CmB5DiB,AnB4DhB,CAAC;AGNvC,AKQA,ArBtDA,AkBEA,AYHE+C,AtBGF,ADAA,AJDA,ADLQ/D,AsBMR,AzBDA,A8BCA,Cb4CC,AKQA,CSvDC+D,ECcE,A7BjBI/D,C4BGH,EAAE,ECcE,ERpDR,CbsEW,AExBA,EVXM,C6BiBH,CCpBH,CvByCK,AqBnCA4P,A5BHI,CAAC,C4BGf,A5BHC,CiBgCH,AYfe,CDdC,EENF,CDoBK,CnBNC,EoBdF,CAAA,AnB4DhB,CMzBO,AInELvL,CX8CqB,CFwBV,ASHJ,CTGK,ASHJ,KTGS,CAAC,AatE1B,CX8CsC,AmBMA,CRpDnB,CV4FA,AkBxCqB,GlBwClB,GAAG,GAAG,CAAC,CAAC,OHtBiB,CAAC,CAAA;AMiBjD,AKlFA,ArBmCA,AkBEA,AYHI,AtBGJ,ADAA,AgBzCE,ApBwCF,ADLK,AsBML,AzBDA,A6BZMiC,ACaN,MDbMA,EGwBE,ADdA,CAACsJ,EAAD,CpBgCI,AExBA,AgBlBA,CIIH,AThCA,CQoDK,CDdC,AFVA,ElB0CE,AoBhCA,CpBgCC,AatEJ5M,CK4BR,CTuCD,CTGgB,ADGA,AsBrBA,CrBkBC,EqBlBE,ADdA4M,ClBQC,AOqBf,ANyBH,CHtBmB,AoBhCT,APtCR,CAActL,CbsEK,EExBE,CkBRC,CTsD9B,EE5FQ,CAAsBD,IX8CQ,AmBMA,ADdxB,CCcyB,ADdhC,EpBgCkC,CAAC,CAAA,AoBhCCuL,APtCnC,CQoDoC,ARpD3C,CJmE+B,AYfa,ADdA,CX6BZ,AYfY,EDdG,CAA7C,EAAgD;ATwDpD,ArBtDA,AkBEA,AYHMA,AtBGN,ADAA,AgBzCE,ApBwCF,AqBCA,AzBDA,A6BZK,ACaL,IbkDC,EcrDKA,ECcE,ADdA,CpBgCC,EoBhCE,CENH,ApBcI,AmBMA,ADdN,IENM,GDoBO,CCpBH,AvByCI,AUNf,CYfgB,EZeb,EanCa,CvByCK,AUNf,CVMgB,AOkBd,EHAA,CJlBiB,AG3BA,CoBdH,ApBcI,EoBdF,AvByCI,AUNf,ANwBD,CJlBiB,AG3BA,AOqBf,CPrBgB,CI6CL,EAAE,CHAT,KJlBqB,AG3BA,AC6ChB,CJlBiB,AG3BA,CH2BC,CIkBf,CGAmB,CPlBD,CAAC,AOkBE,CPlBD,AIkBhB,CJlBgB,KIkBV,EGAgD,EAAE,CHA7C,GAAG,EAAE,GGAyE;AhBnD5H,AkBEA,AYHK,AtBGL,ADAA,AJDA,ADNI,AsBOJ,AzBDA,A8BCA,M3BPQ/P,EQqCA,AMoBN,GdzDW,CcyDP,AJ7CM,AmBMA,A7BlBEK,CcyDP,CNpBO,EsBvCF,CDoBK,CAAC,A7BlBd,EOwCgB,AUPf,AjBjCiB,E8BFJ,AhB2DF,AevCM,CAAC,CrBmBC,ADGA,AahBtB,CNiCiB,CevCO,CrBmBC,CGoBpB,CD7CsB,AOqBf,CVOgB,AG5BA,EmBME,CCpBH,AtBuCI,AEzBA,CH4BC,AOiBN,AJ7CM,CoBdH,AvB0CI,AOiBN,CgB3DE,CnB2Df,EJjBuB,CAAC,AIiBrB,AkBvCqB,ItBsBI,AahBtB,ATiCC,CHpBsB,AGoBrB,AkBvCqB,EnBNE,CAAC,EH4BE,AG5BA,EH4BE,MsBtBM,OrBmBH,CAAC,AqBnBU,CrBmBT,AqBnBU,CrBmBT,MAAM,AqBnBU,CrBmBT,AqBnBU,CrBmBT,CAAC,EqBnBY,CAAC,CrBmBT,AqBnBS,oBrBmBC,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,CAAA;AV/B/G,AkBEA,AVAA,ADAA,AJDA,ADNQE,AsBOR,AzBDA,A6BbI,ACcJ,GRoDG,CnB3DKA,IQqCA,AMoBN,CevCO,EHzBE+F,CZgEL,AJ7CM,CI6CL,AYhEM,ClB4CC,ARrCI,A0BPJlF,EIKF,CbmCP,CPrBa,CgBnBP,ClB4CS,AkB5CA,EIKF,ApBcI,CFyBC,AMoBN,CPjBO,AahBtB,AM/BS,ChBmBc,AC6ClB,CGAa,AYhEMN,EnB+CE,AahBtB,CbgBuB,GahBnB,CU1BmB,AV0BlB,CU1BmB,CJLnB,CZgEmB,AYhE1B,CZgE2B,KJ7CW,CFyBC,AEzBA,CFyBC,EsBvCF,AvB0CI,AG5BA,AUYtB,CU1BmB,ApBcI,AUYtB,CbgBuB,KahBjB,CZauB,AYbtB,CZauB,CAAA,CsBvCF,CAAC,CAAA,CpBcM,CAAC,CAAA,QUYb,CAAC,EAAE;ADoCnD,ArBtDA,AkBEA,AYJI,AtBIJ,ADAA,AJDA,ADNK,AsBOL,AzBDA,A6BbG,ACcH,KEWK,GrBmBG,AMoBN,CctDO+N,EPtCR,CP4FK,AJ7CM,CI6CL,AGxBH,CTIU,EsBvCF,ApBcI,AkBTZ,IlBSgB,AkBTAkB,ClBSC,CI6CL,ActDZ,CELe,CnB2Db,CGAa,EgB3DI,AnB2Dd,AU5FDnN,CSiCe,AvB0CK,AG5BA,AUYzB,CVZ0B,AC6ClB,CAAC,ED7CoB,CAAC,AS+CA,AE9FhC,CP4F2B,CNpBO,AMoBN,AJ7CM,AW/CnB,CX+CoB,EFyBE,EEzBE,IAAI,CH4BC,AG5BA,CH4BC,CAAC,CAAC,CAAA,AYmBoB,CCnC1D,IAAI,CAAC,EZa+B,AEzBW,CFyBV,IEzBe,CAAC,EFyBT,AEzBW,CFyBV,CAAC,CAAC,CAAA,KYbvB,CAAC,gBAAgB,CAAC,EAAC;AtBlBrD,AkBEA,AYJIiN,AtBIJ,ADAA,AgB1CE,ApByCF,ADNC,AHMD,A8BCA,IRqDC,AUzCG,ADhBAA,IpBkCI,AMoBN,ActDM,CAAC,CPtCH,CQsDK,ARtDJ,CP4FD,AGvBH,CapCM,AhB2DF,ActDC,CpBkCM,AoBlCV,ElBSY,AOsBT,AYfS,ARtDJ7M,CJqEJ,INuBF,CGAU,GPjBS,AOiBN,AMjChB,CC3DG,CbwEqB,GAAG,AaxEJ,GX+CO,CI6CL,AJ7CM,CI6CL,AO5FEC,KX+CS,CAAC,EOsBP,CAAC,CAAC,CIrElC,EAA0C,CbwEN,CAAC,IEzBe,CAAC,CAAA,CFyBT,CAAC,SWuBiB,KXvBH,CAAC,UAAU,CAAC,MAAM,CAAC,CAAA;AV/BhF,AkBEA,AYJG,AtBIH,ADAA,AgB1CG,ApByCH,AJAA,A6BbE,ACcF,GCXoD,Cd6DnD,AKGA,CLHC,GNpBM,CSHL,AYfM,AH1BAyD,GIKD,GDqBO,CnBPC,AmBOA,ClBsCX,EmB3DU,ADqBI,AH1BjB,CPmEe,CAAC,GW9DE,AvB2CI,AG7BA,AUYtB,CU1BkB,ApBcK,ASgDH,CAAC,CXvBP,AqBlBW,CrBkBV,AqBlBW,CnBPC,CH6BC,AG7BA,CH6BC,AsBtBA,CAAC,CAAC,CrBkBV,ADIW,CCJV,ADIW,CYmBX,CAAC,CXvBE,ADIW,AsBtBA,CrBkBV,AWuBD,CAAC,AUzCY,CnBPC,AmBOA,CnBPC,CH6BC,AsBtBA,CtBsBA,CsBtBE,CnBPC,AmBOA,CnBPC,EmBOE,ETKpB,EZaa,CAAC,CqBlBY,CnBPC,CAAC,CAAA,MFyBJ,EAAE,AqBlBW,CAAC,YrBkBC,CAAC,AqBlBW,CrBkBX,IqBlBgB,IAAI,CAAC,CAAC;A/Bb3F,AkBEA,AYJEzC,AtBIF,ADAA,AgB1CG,ApByCH,ADNA,AHMA,A6BbC,ACcD,CD1CA,CEsCEA,EdsDF,CctDK,EAAE,CELH,AtBwCI,ASHN,AEyBA,CW9DG,ADqBI,A7BnBA1D,GiBmCH,AEyBA,CThDO,AC6CT,AQGG,AUzCM,CrBmBC,AqBnBA,EVyCJ,CXtBO,ASHN,CYhBO,CAAC,ADhBA,A5BHnB,C6BmBmB,EVyCH,AnB5DM,CmB4DL,CZlBO,AOevB,AMjCC,ADoCgB,CAAC,GCpCb,EbkBwB,AYkBN,CZlBO,CalBrB,ADoCgB,CCpCf,ADoCgB,CZlBO,AYkBN,CZlBO,CCJV,CAAC,CDIY,CYkBL,CAAC,CAAC,EZlBQ,CAAA,CUPF,EAAE,GGXf,CZcY,AYdX,GAAG,CAAC,gBAAgB,CAAC,EAAE;ANiCpD,AerCA,A/BdA,AkBEA,AYJI,AtBIJ,ADAA,AJDA,ADNI,AHMJ,A8BCA,CbqCA,AAYC,AerCA,ICtBI,AhB2DJ,CdxDON,EQsCI,AWsBV,GSzDS,CXiCR,ANsBA,AQEG,CAAC,CnB5DH,EiBoCG,ANsBA,AiBvDS4O,A5BHE,CUWC,AC+CX,CQEI,CAAC,EFxBD,AEwBG,CFxBF,CWjCF,CrBwCa,AqBxCpB,EXiCa,ANsBA,ESlCd,CZc8B,AGoBb,IJfa,GAAG,EIeP,CAAC,IJfa,GAAG,CAAC,CAAC,EanBtC,EbmB0C,EAAE,AanBxC,CbmByC,AanBxC,GbmB2C,CAAC,AUPH,CVOG,CUPD,WGZ1B,CAAC,GAAG,CAAC,gBAAgB,CAAC,EAAC;ANoB1C,AetHb,A/BgFA,AkBEA,AYJG,AtBIH,ADAA,AgB1CE,ApByCF,ADNQ,AHMR,A6BZA,ACaA,GCdoD,CEKzC,AJJP9H,IlB4CQ,EsBxCK,ATjCX,AK6BI,CIIQ,CnB4Df,AQEA,COlEU,EL7BFhE,AK6BX,ChBiBgB,AOyBZ,ANsBG,GQEG,CTjDU,ASiDT,CXtBc,AE3BJ,ASiDT,EW9DkB,CAAC,AvB6CP,AUPZ,CVOa,AanBtB,CHYW,CAAC,CPzBa,CHgCC,AGhCA,AC+CT,CJfU,Ac9ExB,Cd8EwB,Ac9EH1C,GSiCsB,AnB4DxB,CD/CU,AC+CT,CD/CU,CC+CR,AU7FtB,CP8EoB,AJhCY,CAAC,CAAA,AW9CH,CAAlC,EAAqC,KQqDtC;AfuCD,AepCA,A/BfA,AkBEA,AYJE8M,AtBIF,ADAA,AgB1CG,ApByCH,ADNK,AHML,A6BZA,ACaA,ECJEA,EFTEnG,EG0BE,ECtBE,AtBwCI,CWsBT,GUxCS,ADjBA,APtCL,ESiCO,AFKA,CCiBC,CnBTC,AOyBZ,ANsBA,AehEJ,IhBiBoB,CAAC,EoBbE,CvB8CC,AanBhB,CHWK,CatCa,CtBwCK,CYbnB,ATiCI,GSjCD,EVdkB,EAAE,AUchB,CVdgB,CoBbE,CAAC,GvB8CG,CAAC,AanBhB,CAAW,SbmBe,CanBR,CbmBU,CAAC,GAAG,CuB9CC,CAAC,AV2BT,EAAE,CU3BU,CAAC,CvB8CC,GAAG,AanBT,MU3Be,CAAC,CAAA,evB8CgB,CAAA;ATtC3F,AkBEA,AYhBoD,AtBgBpD,ADAA,AgB1CI,ApByCJ,AJAA,A8BCA,CChBA,GdyEC,Ae5CG,ADfJ,IEPQ,AtBwCI,AWsBV,CAAC,EUxCQ,CCtBC,AtBwCI,AWsBV,CW9DO,AtBwCI,AE3BJ,AOyBT,AYhBS,ERvDJ,CV6FL,GU7FWnD,CbyES,AGoBhB,CHpBiB,ADMJ,AIcZ,AQEM,CW9DO,AX8DN,CAAC,CAAC,EW9DQ,ATjCtB,CSiCuB,AtBwCI,AGoBhB,GAAG,AU7FQ,KPmGb,AOnGkBd,CF+FD,EW9DQ,AX8DN,CW9DO,AX8DN,CAAC,ERFJ,CAAC,OGMK,AOnGhC,EPmGkC,AKJQ,AE/FE,CF+FD,CAAC,OW9Da,CAAC,GAAG,AhBkEE,CgBlED,ChBkEG,QgBlEM,CAAC,EAAE,MhBkE+B;AhB1D7G,AkBEA,AVAA,ADAA,AgB1CKc,ApByCL,ADPI,AHOJ,A6BbA3E,ACcA,M3BRQsB,C0BND,ClB6CK,AM0BV,AKJA,AUxCM,AH3BAyG,ChBkBC,AmBSA,EAAE,CCtBC,AhBkEN,AG3BH,AEuBG,AE/FDpD,CPmGE,AHNH,AQEG,AnB7DQ,GiBsCR,AjBtCWlE,A0BNlB,EPmEY,AUxCM,CCtBC,AX8DN,AUxCM,ARvDP,AK4BO,ET4CP,AEuBG,CFvBF,CavCU,CAAA,CvB+CE,CURR,AYjBS,A7BrBE,CAACS,CQuCG,CM0BT,AYvEK8D,GZuEF,AYvEP,EAAc,Q1BML,CAAxB,CiBsCqC,EAAE,CH2BF,CAAC;AhB1D1C,AkBEA,AYHAJ,AtBGA,ADAA,AgB1CK,ApByCL,ADPI7D,AHOJ,A6BbE,ACcF,E3BRIA,G6BqBC,CDhBC,AFXAiH,CEWCgG,CpBkCK,AM0BV,AJpDM,CoBdC,C9BCG,EciEN,AKJH,CLII,AdjEQ,CQuCG,ESDd,CNoBM,AX1DN,A0BNa,CAAClG,CPmER,CAAC,CFvBF,AEuBG,ASxDZ,CAAsBoH,ErByCE,GOmBH,GAAG,Ac5DM,AFXb,CEWcjN,AFX7B,EnBoD+B,AmBnD7B6F,GnBmDgC,IqBzCpC,ErByC0C,AqBzCA,CrByCA,AOmBL,CAAC,CYtEtB,GAAG,ET2CqB,CAAC,IPzBc,KkBRvD,CFV6C,CEUiB,CFV1D;A5BYJ,AkBEA,AYHE9C,AtBGF,ADAA,AgB1CI,ApByCJ,ADNI,AHMJ,A6BZEA,ACaF,ECHEA,AFVAA,EG2BE,CDjBC,AFVA,C1BMGzD,C4BID,CENC,AtBwCI,AM0BV,AJpDM,AgBlBAyD,CPkEL,AEnGA,ArBuCQ,CqBnCN,CK6BM,CIIC,AhBkEN,AJpDM,AmBSA,A7BrBElE,A0BNFmH,CIIC,AhBkEN,Ce3CO,EZgBV,ANoBA,CiBrDa6I,APvCLrM,ArBmCO,CAACtD,C4BIb,EpBkCkB,ADOJ,AqBzCA,CjBqDX,AU5FL,CV4FM,Ae/DH,CIIgB,ATjCL,ArBmCf,C8BFqB,AbuCZ,AS3CX,EhBkByB,AC6CZ,CAAC,CGOO,AJpDM,EIoDJ,CAAC,CgBlEO,EAAE,KnB2DP,CAAC,SAAS,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC,CAAC;AbnD5D,AkBEA,AYHI,AtBGJ,ADAA,AgB1CI,ApByCJ,AJAA,A8BCA,QnB+BY,AM2BV,AKLA,AUvCM,ADjBA,IENI,ApBcA,COyBR,EEuBK,ASxDM2P,APvCNzM,CX+CO,AC6CZ,AQGM,CZfO,AYeN,ASxDH,CpBkCc,CAAC,CGmBf,CAAC,CQGO,ASxDM,APvClB,CSiCmB,ATjCNI,CSiCO,CX8DL,AUvCM,CVuCL,CRHL,AQGM,CXtBW,AazE5B,CbyE6B,CGmBf,EQGQ,ASxDtB,ClBQ6B,ASgDN,CThDO,AkBRA,CpBkCK,CsBxCH,AnB2DZ,CGQO,AJrDM,AC6CZ,CmB3Da,AtBwCI,AE1BJ,CoBdA,AtBwCK,EGmBd,CAAC,ESpCH,AToCK,CAAC,CAAC,CD7Ca,CAAC,EAAE,eUSjB,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,gBAAgB,EAAE,cAAc,CAAC,EAAA;AtBfrG,AkBEA,AYHMqM,AtBGN,ADAA,AgB1CI,ApByCJ,ADPI,AHOJ,A6BbE,ACcF,IRqDC,CAAC,CAAC,ASxDGA,AFXA,CPmEF,AOnEGjJ,ClB6CK,AM2BV,Ae5CM,ADjBA,CENC,ADuBA,A7BtBCtG,E6BsBC,ADjBAyO,Cd6DL,AG3BH,AjBvCC,CO8CS,AOoBN,AHRH,AehES,C1BME,A0BNDhL,EhBmBE,AO0BT,CAAC,AS7CK,CG4BK,AH5BhB,CG4BiB,CH5BC,EhBmBE,AmBSA,ADjBhB,IpBkCwB,AE1BJ,GAAG,EIqDJ,GAAG,AG3BH,CAAC,CAAC,IH2BO,CAAC,KJrDW,CIqDL,AJrDM,CIqDL,EJrDQ,CAAC,CIqDL,CAAC,CAAC,MJrDY,CAAC,CAAA;AZN7D,AkBEA,AYHK,AtBGL,ADAA,AgB1CG,ApByCH,ADPQhE,AHOR,A6BbI,ACcJ,IRsDC,AnB9DOA,I8BDA,AtBwCI,AM4BV,Ae7CM,AH5BA,CT6CL,ANmBA,GJXS,AOoBN,AYzEMkH,GIKG,CvBgDC,AGlCA,AVbI,C6BsBH,CrBiBK,AkB7Cd,ClB6Ce,AqBjBJ,A7BtBIpH,A0BNJ,ChBmBC,CAAC,GVbb,CUaiB,ASiDH,CW/DI,ApBcA,CoBdC,AJLAkE,EZyEJ,CYzEJ,CZyEM,EJtDQ,AgBnBA,ChBmBC,CoBdC,CAAC,CvBgDS,AGlCR,CHkCQ,AGlCP,AgBnB9B,EhBmBgC,AUOjC,AM1BiC,ChBmBC,EF0BM,AE1BJ,AgBnBnC,ClB6CwC,CkB7CHmD,EIKE,CAAC,CJLxC,CAA0CL,OIKO,AtBwCI,AYnBrC,CUrBkC,AtBwCI,CsBxCJ,CVqB/B,EM1BnB,CAAJ,EAA6D,IN0BoC;AtBbrG,AkBEA,AVAA,ADAA,AJDA,ADPQhH,AHOR,A6BbM,ACcN,IGTI,AX+DH,AnB9DOA,C8BDH,GtBwCO,ASCV,AEsBG,CnB9DQ,C0BNHsH,EnBqDE,AOoBT,AG3BG,AYlBM,A7BtBI,CWyDP,Ae/DI,C1BML,EO+CQ,AmBrDAtI,CT8CL,CYlBO,EnBTE,AmBSA,EtByBU,CAAA,AmBrDP,ChBmBC,ASiDH,AOpEGsI,ChBmBC,CF0BK,CkB7CxB,KhBmB0B,CAAC,GAAG,CAAC,EAAE,AO2BJ,AEsBG,CTjDE,AUOrC,AD0CoC,CTjDC,EO2BD,CGpBhC,CAAC,GHoBoC,cGpBnB,EAAE,eHoBkD,EAAE,IH2BH;AhB5D5E,AkBEA,AYJI,AtBIJ,ADAA,AgB1CE,ApByCF,AJAA,A8BCA,IGRW,AX8DV,IXvBW,AWuBP,AS1DG0I,EEJS,AFIP,CEJQ,ATlCX/M,CdkFK,AOmBT,AG1BA,ANgBA,GiBrDY,CrB4CC,AOmBT,AG1BA,ANgBA,AkBnCS,ClBmCR,AkBnCS,EAAE,CnBTC,AkBTA0L,CXqCR,CH0BC,AOrGX,EX+CsB,CHmCC,AOmBT,AJtDS,ASiDH,AEhGD,CV2FJ,AkBnCS,CAAC,CVwCF,CXvBQ,ADSJ,AIST,AU3FlB,Cb0EO,CAAA,AM2Ba,CgBnEiB,AhBmEhB,CgBnEiB,AvBgDP,CISR,AkBnCS,CtB0BC,AIST,CGUC,CAAC,AJtDS,ASiDH,AS1DnB,CT0DoB,AS1D/B,ClBSmC,CAAA,AkBTC,GEJkB,AbyCtB,CGrBhC,GHqBoC,GGrB9B,EHqBmC,CAAC,CH0BD,AM/C/B,CN+CgC,CAAC,CG1BG,EGrB/B,CAAC,8BHqBqE,EAAE,uDGrBgB,CAAC,CAAC;AtBb7G,AkBEA,AYJM,AtBIN,ADAA,AJDA,ADRQ,AHQR,A6BdM5H,ACeN,IRsDC,EOrEKA,EIOE,AtByCA,AWqBH,GS1DM4H,A5BLI,CQ0CH,AM0BT,AHVA,AehES,CG6BC,A7BvBIxO,A0BNJ+D,EIOE,CvBgDC,AUPZ,ANgBG,AehEK,CZ0EJ,AJtDS,AC4CT,AehEF,ClBgDY,EkBhDE,CZ0ER,CAAC,CN1BU,AGgBT,AX1DC,CQ0CS,ASAZ,CH0BI,AKLM,CW9DI,AtByCA,AM0BT,AG1BH,ANgBG,AX1DazD,C8BCH,AbyCZ,CH0BI,AKLM,AS1DnB,C5BLE,EcoEc,AdpEa,C4BKHuP,AFXD,EZ0EN,Ac/DnB,GrB4C+B,AYcH,CRLL,AQKM,CRLL,CJTU,AOmBT,CPnBU,AOmBT,AM/C5B,Cb4BqC,KOmBH,CgBnEU,CAAC,AhBmET,CAAC,EgBnEW,CAAC,AhBmET,GAAG,EAAE,CAAC,EAAE,EgBnEW,AhBmET,CgBnEU,CAAA;AhCOhE,AkBEA,AYJM,AtBIN,ADAA,AgB3CE,ApB0CF,ADRY,AHQZ,A6BdQ,ACeR,IGRI,AX8DH,CW9DI,InByDF,AkBnCM,CRzDH,ArBkCU9P,CmB+DR,AS1DGwO,CpBqCC,AkBhDAnI,ChBoBC,EWhDFrD,AK4BI,CnBuDC,AOmBZ,AG1BA,CWrCE,CpBqCY,AkBhDAhE,EZ0EV,Cc/Da,CrB4CC,AqB5ChB,A5BLM,EAAkB,COiDL,AOmBZ,AG1BA,AShDY,CnBuDC,AmBvDAmG,CnBuDA,AYcF,CXrBI,AM0BZ,AKLS,EEjGvB,Cb4E6B,Ca5EH,AK4BV,CAAejE,CZ0EX,AKLS,CLKR,CAAC,CAAC,CAAC,AKLS,AOrEjB,CPqEkB,AOrEGlC,CN2BpC,GD0CqC,CC1CjC,CAAC,CM3BU,EAA8B4B,SAA9B,CAAV,CPqEgD,CAAC,CAAC,CXrBI,AYrBrC,AD0CkC,CXrBI,AYrBrC,AD0CkC,KAAK,CC1CjC,ID0CsC,CC1CjC,CD0CmC,EAAE,GC1C/B,EZqB4B,CAAC,CYrBzB,YZqBsC,EAAE,CAAC,CAAA,CYrBxB,CAAC,MAAM,KAAK,OAAO,CAAC;AtBbpF,AkBEA,AYJM,AtBIN,ADAA,AgB3CG,ApB0CH,ADRgBZ,AHQhB,A6BdQ2G,ACeR,IGDY,AnBkDX,CAAC,GQKA,AUxCM,A7BvBQ3G,A0BNR2G,EIcU,CAAC,AFHRmI,CpBqCC,AWqBN,CZdO,AUPT,AI5EIzL,EK4BO,CZ0EX,Ae7CY,AH7BAI,ChBmBG,CF6BD,AqBnBA,CDlBZ,Cd+DE,AOtGL,ArBkCyB,C4BKP8E,APvCL,ArBkCatI,A0BNrB,ClBgDc,AkBhDA,CIcS,ET1CXwC,Eb4EO,CAAC,AM0BZ,AKLM,AS1DhB,CAAuB,Ed+DV,AKLM,AnB/DG,CAAZ,CAAyBjC,A0BNjC,EAA2BwD,CL5BnB,ArBkCA,CqBlCgBtB,Cb4EM,AkBhD9B,ClBgD+B,AoBrCAqN,CpBqCA,AkBhDC3I,EEWX,CPvCb,AK4BR,CN2BJ,AQhBwC,APvCzC,CDuDE,AM3BwCf,EPqEJ,CLKL,AKLM,AOrElC,CZ0E6B,IKLU,CLKL,CAAC,AKLM,CLKL,AKLM,MC1C5B,CAAC,MAAM,KAAK,MAAM,IAAI,OAAO,iBAAiB,CAAC,OAAO,KAAK,QAAQ,IAAI,OAAO,iBAAiB,CAAC,OAAO,KAAK,QAAQ,CAAC;AtBb3I,AkBEA,AYJQ0J,AtBIR,ADAA,AgB3CG,ApB0CH,ADRa,AHQb,A6BdO,ACeP,IhBkDQ,GepEF,CIiBE,AXuDN,AS1DMA,CpBqCC,EoBrCE,CXsCR,AEoBG,AUxCM,ADlBA5P,CCkBC,EAAE,Cf6CX,AJvDY,CHmCG,AULX,CWtCA,CEGW,CAAC,AhB4DZ,CPpBe,AqB3CF,ClBQC,AmBUA,CAAC,GDlBGsO,Cd+DX,Ae7CY,CCfC,AXuDN,CAAC,CZfS,CuBxCD,ApBKA,GHmCK,AGnCF,CoBLC,AhB4DZ,GKLS,EZfU,AOoBd,EPpBgB,AGnCF,CAAC,AO8BP,AWtCf,CXsCgB,AGtBjC,CAAC,AQhBwCsB,Gd+DT,AHTP,AiBtDmB,CAACxM,EjBsDhD,CGSuC,Ec/DnB,ElBQmC,AkBRAwM,ClBQC,CSkDJ,CS1DM,Cd+DX,AKLO,AS1DK9F,CEGjB,AnBmDb,CmBnDc,AVatB,CAAC,AQhBF,ClBQ2C,AkBRxD,Cd+D6C,AJvDY,CIuDX,AJvDW,EIuDT,CM/C3B,ATsCiB,EAAE,GStCd,OAAO,IAAI,ATsCsC,OStC/B,iBAAiB,CAAC,OAAO,KAAK,QAAQ,CAAC,EACtF;AtBdL,AkBEA,AYJQ,AtBIR,ADAA,AgB3CE,ApB0CF,ADRS,AHQT,A6BdK,ACeL,KDrBI,GlBsDI,AGiBN,CkBpCO,EH7BE,CIcO,AboCf,ANeG,AQIH,CS1DUuE,CpBqCC,EDME,AGnCA,AO+BT,GWvCC,Cd+DH,CGxBO,CAAC,EWvCWuB,ClBQC,CAAC,AO+BT,ANeG,CGSR,Ac/De,Cd+Dd,AKLM,AS1DS5P,CjBsDL,EQID,CWvDgB,AhB4DrB,CgB5DsB,AhB4DrB,Cc/DV,GrB2C6B,AGnCA,GHmCG,AGnCA,CHmCC,CuBxCe,AvBwCf,CIWJ,CmBnDqB,AVctD,ATqCkC,CMfI,EAAE,ANeH,AQIH,CRJI,AQIH,ECzC7B,CVTyC,CAAC,EUStC,GDyCkC,CWvDgC,AnBmDrC,AQIM,CTlDU,CAAA,GUSpC,CAAC,CTqC0B,WGSW,GAAG,KAAK,GAAG,MAAM,GAAG,QAAQ,GAAG,IAAI,CAAC,CAAC,uFM9C8D,CAAC,CAAC;AtBdlK,AkBEA,AYJO,AtBIP,ADAA,AJDA,AJAA,A6BdM0G,ACeN,MDfMA,CEQA,CpBwCM,AqBnBJ,CVwCL,AS1DM,GjBsDN,AejES,CEQN,AFRO7C,EG6BE,CtByBC,AGnCA,AO+BZ,ASlDQ,CG6BK,AH7BX,ETkDC,ANeG,CGSL,AGxBG,ASlDY,EnBsDE,EUJV,CVIa,AUJZ,ENeK,CAAC,CJXU,CAAA,AUJX,CAAC,CSlDY,ChBmBE,AgBnBA,ChBmBC,AgBnB5B,ETkDkB,CP/Ba,AO+BZ,ANeG,CD9CU,AO+BZ,ANeG,GSrCzB,ITqCgC,CAAC,CD9CU,EAAE,EAAE,AC8CT,CGSL,CHTO,OD9CgB,AC8CT,CAAC,CD9CU,EC8CP,CAAC,CAAC,GD9CY,EAAE,IAAI,OAAO,EAAE,CAAC,EF6BM,CE7BH,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,CAAC,EAAE,CAAC,CAAA;AZLhH,AkBEA,AYJK,AtBIL,ADAA,AJDA,ADTQ/D,AHSR,A6BdK,ACeL,I3BVQA,IQ2CI,AGiBV,AQIA,CRJC,CAAC,CAAC,CQIC,AUxCM,CtByBC,AsBzBA,C7BxBK,C6BwBH,CnBVC,AO+BZ,CjB7CiB,CAAC,CAAd,C8BQQ,AhB6DX,EN1BqB,AqBnBJ,CAAC,CChBH,ApBMI,CoBNH,ApBMI,AO+BZ,GEmBS,CLKR,AJvDe,ASkDN,AUxCM,CnBVC,MoBNE,CAAC,EXwDA,CCzCxB,CVTgC,CAAC,ESkDJ,IAAI,ECzCvB,ADyCyB,CTlDO,CAAC,CAAA,AUSjB,MUfoB,CAAC,GAAG,CAAC,MVeR,CAAC,EUfgB,CAAC,EAAE,CVeb,KAAK,MAAM;AtBdtE,AkBEA,AVAA,ADAA,AJDA,ADTQM,AHSR,A6BdG,ACeH,I3BVQA,GAAG,CQ4CC,AGgBV,CkBpCO,AR1DR,CrBkCaT,EmBgEX,CTlDU,AO+BT,EjB7Ce,CAACK,COgDD,AOqBd,IPrBkB,AclFL,CrBkCV,E8BQY,InBoDE,CAAC,AQIH,CWxDM,AvBwCM,EYgBT,EWxDO,AvBwCM,IIYJ,CmBpDG,CAAC,AvBwCM,CIYP,CJZS,AIYR,CAAC,CSrCjC,CAAC,CAAC,EDyCiC,CAAC,ICzC3B,IZqBgD,EWoBX,CAAC,EWxDO,QVe5B,CUfqC,AVepC,OAAO,KAAK,GUfuC,KVe/B,SUf6C,CAAC,CAAC,CAAC,0BAA0B,cAAc,IAAI,CAAC,CAAC,CAAC,EAAE,kCAAkC,CAAC,CAAA;AhCCvL,AkBEA,AYLIwP,AtBKJ,ADAA,AgB5CE,ApB2CF,ADTK,AHSL,A8BCA,ICLIA,IpBuCQ,AGgBV,AkBpCM,ADnBA,ClBSC,ASkDN,AS3DM,GXwCN,CYrBU,ADnBL,APvCC,COuCL,CjBuDK,AkBpCM,CtBwBC,AOqBZ,AGxBG,EI/EO5M,CV8FD,CGSL,AHTM,CmBpDG,AhB6DR,AGxBG,CAAC,IAAI,ANeG,CAAC,EU9FnB,KV8F0B,CAAC,EJZQ,EOqBV,CPrBa,AOqBZ,CPrBa,CAAA,CUHD,EHwBP,AGxBS,CHwBR,EM9C7B,CN8CgC,AM9C/B,CAAC,KTqC0C,EHhBY,AMyBhB,AHTM,CGSL,SHTM,KAAK,EAAE,EAAE,MSrCtC,CAAC,iBAAiB,CAAC,OAAO,EAAE,2BAA2B,CAAC;AtBd/E,AkBEA,AYLG,AtBKH,ADAA,AgB5CE,ApB2CF,AJAA,A6BfE,ACgBF,GCnB8D,KpBqDlD,AE7BJ,ASiDN,COtEO8D,GfkEN,AQIG,AUxCM,Cf6CR,EY3EW,CnBsDC,AUHZ,ASnDY7C,CG8BC,EZqBV,ANeG,AkBpCS,AH9BJ,CIeC,AboCR,ASnDN,EnBsDoB,EuBvCF,AboCR,CVGa,AUHZ,GEmBS,CZhBO,AUHZ,AEmBM,CZhBM,AUHX,CapCS,AboCR,GapCW,KXuDG,ERJD,CAAC,EQIK,CWvDG,CAAC,EVcrC,ADyCqC,CCzCpC,CAAC,ADyCqC,MRJG,CAAC,QAAQ,CHhBc,AGgBb,CSrCjC,CUdwC,AVcvC,ATqCkC,CmBnDM,CnBmDJ,EmBnDO,AnBmDL,CmBnDM,ApBMI,AC6CT,CAAC,CSrClB,GTqCsB,EAAE,CAAC,CmBnDM,AnBmDL,CmBnDM,CAAA;AhCA/E,AkBEA,AYLED,AtBKF,ADAA,AJDA,ADVI/D,AHUJ,A6BfC,ACgBD,CDhCA,CE2BE+D,A5BNE/D,G4BMC,EAAE,CpBuCK,AE7BJ,AC6CN,CGSC,AHTA,CAAC,CAAC,CD7CO,ASiDT,CZhBU,CPjDG,EiB8CZ,AYrBY,C7BzBG,EUgBA,AkBVA,CEIH,ADeI,C7BzBhB,C6ByBkB,ECfF,CboCP,IP9BgB,ASiDT,EWvDO,CXuDJ,ETjDW,IoBNA,IpBMQ,CoBNH,CVcnC,CAAC,CVRyC,AUQxC,EDyCiC,CAAC,IWvDS,ApBMI,EoBNF,IXuDD,CAAC,ETjDW,KAAK,QAAQ,IAAI,AUQxD,CAAC,MVR8D,WUQ7C,CAAC,MVR8D,CUQ7C,EAAE,EVRgD,QF6BY,AE7BJ,kBUQ5B,CAAC,CAAC;AtBd3F,AkBEA,AYNqB,AtBMrB,ADAA,AJDA,ADVID,AHUJ,A6BbA,ACcA,E3BXIA,EW6DH,CAAC,GHhBU,AM0BV,CKNC,CnBjES,C4BKgB,ClBWhB,CO8BR,AjB9CW,G4BKkB0O,CrB2Cd,CPhDf,E6ByBgB,CAAC,EAAE,CCfH,GhB6DC,Ge9CS,CCfH,ADeI,ErBoBM,AoBxCT,CEKE,AFLT,CCoBc,KTD5B,CUd8B,CAAC,QVcrB,CUd8B,CAAC,CAAA,AVc5B,CAAC,OAAO,IAAI,CAAC,QAAQ,CAAC,MVRuC,OUQ1B,KAAK,UAAU,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,gBAAgB,CAAC,CAAC;AtBdzH,AkBEA,AYPqD,AtBOrD,ADAA,AJDA,ADVI7O,AHUJ,A6BbA,ACcA,E3BXIA,C4BX0D,CjByErD,CQGP,GXnBU,AMyBV,GO3LD,CP2LK,AJvDM,AO8BT,IVEa,AUFT,CYrBU,A7BzBE,CAACU,GiB8CR,CAAC,CIlKFkE,CS8HS,ChB6DD,AdvEA,CiB8CF,AjB9Cb,EcuEkB,CO3LrB,CXoI6B,CWpIX,GP2LS,CgB7DG,AhB6DF,AJvDM,CoBNH,CvBsCK,EOuBJ,CPvBO,AOuBN,AM9C9B,CbuBqC,CAAA,CUFD,CHyBF,AJvDM,AC8ClB,CGSa,AGzBG,CP9BI,CC8C7C,GSrCqB,CAAC,OUf+B,CAAC,CVevB,EUf0B,CAAC,AhB6DF,AM9CtB,CN8CuB,CAAC,GAAG,CAAC,GgB7DK,EAAE,KhB6DN,AM9Cb,CAAC,CUfyB,CAAC,CAAA,KhB6DL,IAAK,OAAA,qBAAqB,CAAC,CNzB0B,sBMyBH,CAAC,SAAS,CAAC,EAAxD,CAAwD,CAAC,CAAC;AhB7DxI,AkBEA,AYPEyI,AtBOF,ADAA,AgB/HE,ApB8HF,ADVC,AHUD,A6BbA,ACcA,ECPEA,ET6DD,IXnBW,AMyBV,AHTA,AQGG,ILMC,AJvDM,AC8CN,AiB1DM,CCqBC,AR7IJ,COwHK,ErB4CE,AUFZ,AEmBS,GTjDM,AO8BZ,AEmBS,CFnBR,CapCS,CvBsCK,CYiBF,CFnBR,ANgBM,CJdO,AOuBN,AGzBN,AIlKS,CP2LF,AJvDM,CF8BK,AE9BJ,AC8CI,EHftB,ADCoB,AUFZ,ANgBgB,CJdJ,AUFX,ANgBgB,CMhBf,AEmBS,CXlBhB,AMwBc,CKNI,CAAC,EXlBf,CMwBe,CAAC,EAAE,AJvDM,AUSjC,IAAI,CVTkC,EF+BlB,AYtBb,CZsBc,GYtBV,CAAC,EVTmC,CAAC,CAAA,SUSvB,CAAC,CZsBG,CAAC,OAAO,CAAC,AYtBF,CAAC,KZsBO,EAAE,GYtBC,EAAE,UAAU,CAAC,CAAC,IZsBM,EAAE,CAAC,CAAC,CAAA;AVrC9E,AkBEA,AYxB8D,AtBwB9D,ADAA,AgBhIsB,ApB+HtB,AJAA,A6BbA,ACcA,CCxBA,GT8EC,IXjBO,AGcN,AQGG,CTjDI,GIuDN,AHTG,AkBrCM,CtBuBC,GUFT,AEmBS,EUxCK,CVwCF,CWtDA,ADcI,GVwCA,CWtDA,AnBmDF,CMhBL,ETEG,AGce,CHdd,CGcgB,CAAC,CmBnDP,EtBqCL,CAAC,CMuBG,KNvBG,AYvB1B,CZuB2B,CAAA,AarKjBvM,CSgI0B,AXsDC,CAAC,CAAC,CEtLpB,CFsLsB,GWtDE,CXsDE,CWtDA,CXsDE,QCxCzC,OAAO,CAAC,ADwCiD,EAAE,CCxChD,CAAC,IAAI,CAAC,CDwCkD,CAAC,CCxChD,CAAC,GDwCoD,CAAC,MCxC9C,UAAU,CDwCqD,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC;ArBvD1I,AkBEA,AYNAkD,AtBMA,ADAA,AgBjIalD,ApBgIb,ADVA5B,AHUA,A6BbA,ACcA,IRuDC,ES7DK,CAACkO,A5BLA,CQgDC,AE/BA,AC6CN,AQIG,AnBlEGvM,EqBtHKC,EduKD,AOsBT,AHTG,AQIG,CFpBL,CIpKkB,CFwLV,CZjBI,AOsBT,Ae9CS,A7BzBhB,CcuEQ,EKLQ,AnBlEG,E4BKnB,CAAsBwN,EEMF,AnBmDF,GHdF,AGce,CHdd,CGcgB,AX9DJxO,CW8DK,AiBzDJ,CEMH,AFNIuB,C5BLZ,CQgDG,AqBvBW,CCdH,AtBqCP,ARhDW,CmBkEF,CAAC,CZjBI,GuBtCD,AhB4DL,AKLM,AS7DrC,ErB4C0C,AqB5CA,CrB4CC,AOsBT,EPtBW,EuBtCF,AhB4DL,CgB5DK,AhB4DJ,EclEvC,EAAoD,GpB2CR,CAAC,CAAA,GWkBY,CAAC,CAAC,EAAE,IAAI,CTjDI,kBSiDgB,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;ArBxDhG,AkBEA,AYNE8C,AtBMF,ADAA,AgBlIsB,ApBiItB,ADVI,AHUJ,A6BbA,ACcA,ECNEA,ET6DD,CS7DI,C5BLGrD,C4BKD,CpB2CC,AE/BA,AC6CN,CGSC,AKLG,CnBlEM,EUiBA,AO6BT,ANgBG,CD7CO,ASiDH,AnBlEK,CmBkEJ,EZjBK,AUHT,AYrBS,CVyCF,AUzCG,A7BzBEC,CmBkEJ,CUzCI,ADpBA,CT6DF,CFpBL,CVGU,AUHT,AjB9CE,COiDQ,AYiBH,AnBlEKC,C8BWL,AnBmDF,EMhBD,AEoBM,AUzCG,CrBuBV,AGce,AkBrCJ,CrBuBV,CGcgB,CJbH,AIaI,AkBrCJ,EtBwBE,APjDE,CQgDZ,ADCW,APjDET,CQgDZ,CsBrCQ,CAAC,AvBsCI,EGhCZ,CAAC,AVjBA,GmBkEc,AnBlEK,CmBkEJ,AnBlEzB,CAAX,COiDyC,AUHJ,CVGI,CCDT,ASFO,CTEN,CAAA,AWkBS,EAAE,CC1C5C,AD0C6C,GAAG,CC1C5C,EUb8C,AXuDC,CWvDA,CpBMT,ASiDW,CTjDV,ASiDW,CWvDA,CAAC,AXuDC,EAAE,MTjDL,CoBNW,ApBMV,EoBNY,ApBMV,OoBNiB,CAAC,CAAA;AhCD9E,AkBEA,AYPqB,AtBOrB,ADAA,AJDA,AJAA,A6BbA,ACcA,QnBsCQ,AGcN,AQGA,GS9D0B,CpB6ChB,AEhCA,AC8CN,AQGA,CZjBO,AOqBJ,Ae7CI,ElBsCI,CMjBb,AEoBM,AS9DuBqO,CjB4D9B,ED/CgB,AO6BZ,AEoBM,CFpBL,ANkBM,CmBrDG,CnBsDd,AiB7DyB,CAAP,CX0CT,ANmBC,CMnBA,CP7Ba,ACiDvB,CDjDwB,GO6BT,CTGa,ASHZ,CP7Ba,AO6BZ,ANoBH,CDjDgB,ACiDf,CHjBgB,AEhCD,CFgCE,AWiBN,CAAC,CXjBO,AWiBN,CAAC,CAAC,iBC1C5B,sBAAO,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,gBAAgB,CAAC,EAAC;AtBd5D,AkBEA,AYR0C,AtBQ1C,ADAA,AgBnIG,ApBkIH,ADXI,AHWJ,A8BCA,GCToD,G5BH5C5N,EWoEN,AQDA,CTjDO,AmBQA,GrBwBG,AMqBT,AKJG,CRCC,AQDA,EE1LG,ArBuHO,CiB+Cb,ANqBM,AXpEQT,COkDD,CCAC,CGkBL,AQDA,AE1LCwC,CSoIE,AnBuDF,AQDA,CAAC,CRCC,AXpER,CmBmES,CWtDG,ChB0DJ,AGxBH,ANqBM,AXpEQ,CcuEV,AdvEb,CmBmEiB,CRCC,AQDA,AnBnEQ,EcuET,AO9LX,CSoIiB,AtBqCI,AazKL,CP8LH,AHHG,CGGF,AHHG,AQDA,CXjBO,CWiBL,CWtDG,EtBqCM,CGkBL,AQDA,CWtDG,AnBuDF,AQDA,CE1LPQ,GSoIa,EnBuDA,EAAE,AU3LhB,CbyKuB,CAAC,AazKdC,CSoIW,AnBuDF,CQDC,CC1CzC,CT2C2C,AQDA,EE1LtB,CV2LyB,CmBvDG,AXsDF,AE1LRM,CV2LS,AQDA,GRCG,CmBvDG,CnBuDD,EAAE,AU3LlC,EF0LoC,AE1LL,CbyKC,CAAC,AWiBK,CWtDG,EAAE,ItBqCH,CAAC,AWiBK,CAAC,KXjBA,AWiBK,CAAC,CXjBJ,GWiBQ,CAAC,UAAU,CAAC,EAAE,QXjBG,AWiBK,CAAC,CXjBJ,IWiBS,CAAC,IAAI,CAAC,SXjBI,CAAC,AWiBK,CXjBL,AWiBM,CAAC,CAAC;ArBxDlI,AkBEA,AYREuJ,AtBQF,ADAA,AgBnIIvM,ApBkIJ,ADXQ,AHWR,A6BdA,ACeA,ECREuM,GT+DA,AUzCG,GnBPG,CVnBK,CqBvHTvM,EbyKQ,AMqBT,AHHA,AiBhES,CX2CR,AjB/CaG,CUmBH,ACiDT,AiBhES,AP3HN,ArBuHU,CqBvHTC,CdyKO,CIkBR,AXpEa,CQkDH,ARlDV,CqBvHJ,CdyKgB,AczKN4C,ArBuHU7C,COkDH,AIkBT,AXpEa,CWoEZ,CDjDU,CoBNH,A9BbQD,CcuEZ,CAAC,AJpDS,ECiDP,AU3Lf,CV2LgB,EmBvDO,CtBqCK,AE/BA,CIoDR,AdvEa,CAACT,CQkDH,AMqBT,AHHA,CGGC,AHHA,CHlBU,CAAA,ADAC,CIkBR,CJlBU,AIkBT,AXpEvB,CWoEwB,CXpEcU,CUmBH,AVnBI,CUmBH,CVnBpC,EAA2C,KoBwB7C,IVLkD,CAAC,EUK5C,KAAK,EAAE,CVL+C,CAAC,CAAA;AZRpE,AkBEA,AYXoD,AtBWpD,ADAA,AgBnII2D,ApBkIJ,ADXY9D,AHWZ,A8BCA,CCXA,GTmEC,AUzCG,E7B3BQA,EUoBJ,EmBOE,ARlJN8D,ArBuHY,CmBoER,AnBpES3D,CQkDL,AMqBT,AGxBA,ANqBA,AkBzCS,A7B3BM,GmBoEN,AnBpES,CQkDL,AMqBT,AGxBA,AItKG,ArBuHM,CQkDC,AMqBT,AdvEI,GQkDQ,ADAA,AYkBH,AnBpESD,CQkDL,ASHT,AEqBM,CXlBG,ASHR,AItKT,EV2LW,CAAC,CMrBC,EalCO,AnBuDL,CAAC,AQAM,AnBpES,CAACC,CmBoER,AE3LdH,ArBuHqB,CWoEZ,AXpEX,EWoEa,CmBvDM,AnBuDL,AU3LtB,ESoI6B,AvBqCI,AczKjB0D,CdyKkB,CYkBF,CLGL,CKHO,AE3LlC,CAAqBjB,CP8LS,CgB1DqB,CvBqCV,AYkBH,CZlBI,AUHJ,AEqBC,CZlBG,AOqBR,AKHM,CFrBA,CItKxC,EAA8BC,EP8LU,CAAC,EM/CxC,CC/ID,KP8L+C,AM/CxC,IAAI,KAAK,CAAC,GN+C2C,CAAC,IAAI,CAAC,KAAK,CAAC,cAAW,CJnDe,CImDb,EAAE,CAAC,CAAC,gBM/CvB,gBAAgB,qCAAgC,UAAU,2BAAsB,KAAK,CAAC,OAAS,CAAC,CAAC;AD6CvK,ArB1DA,AkBEA,AYPAQ,AtBOA,ADAA,AgBnII,ApBkIJ,ADXS,AHWT,A8BCA,CRwDC,KS/DK,CAACoJ,ClBeC,AmBOA,Cf4CL,AOjMO,CAAP,Eb4KS,AE9BA,ACgDT,AkBzCS,EAAE,ErBuBE,ASHZ,CVGa,EUHV,CP3Ba,AO2BZ,CW1CR,ClBesB,AkBfAkB,EX0CV,ANqBG,CMrBF,ANqBG,CHlBU,EsBrCF,AnBuDL,CHlBU,AGkBT,CHlBU,AoB7CA,CpB6CA,AoB7CCjN,CjB+DR,EmBvDO,AnBuDL,CMrBF,ANqBG,CmBvDM,AbkCR,IW1CxB,CX0C6B,CalCgB,AbkCf,AW1CY,KX0CP,CAAC,CAAC,CAAC,GGvBjC,AQnBL,EAAuD;ATiEvD,ArB3DA,AkBEA,AYPE8C,AtBOF,ADAA,AgBnIG,ApBkIH,ADXK,AHWL,A6BhBA,ACiBA,ECPEA,EdkED,CAAC,AclEG,EAAE,APjIL,EKuHOwB,GlBuDG,AE9BA,ACgDT,AkBzCS,ItBuBI,AUHZ,ASpDJ,CGgCiB,AHhCAT,ElBuDE,AE9BA,AmBOA,ADtBA,CpB6CC,AkBvDpB,EnBuDsB,AmBvDAuC,ClBuDC,ADAA,CIkBR,CmBvDM,AbkCR,ANqBG,CmBvDK,ApBOK,AgBzB1B,ChByB2B,CCgDR,AezES,CfyER,CJlBU,EAAE,AG9BA,ACgDT,CJlBU,AG9BA,CAAA,ACgDR,CAAC,CJlBU,CAAC,KCAK,EAAE,EDAE,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE,qBAAqB,CAAC,CAAC,CAAC,GAAG,MAAM,CAAA;ATvC3F,AkBEA,AYRqB,AtBQrB,ADAA,AgBnIE,ApBkIF,AJAA,A6BhBE,ACiBF,Ib4DQ,AKEP,KTtDQ,EkBhBmB,CjBgEzB,CMrBC,GTGY,ADCA,AsBxBA,ADvBiByH,CCuBhB,EAAE,ECdF,CtBqCK,CDCC,CIiBR,AiBhEa,CjBgEZ,CkBzCU,ADvBiB3O,CpB8ChB,AqBvBA,ClByCR,CAAC,CHlBU,AqBvBA,ElByCP,AiBhEF,EjBgEI,CAAC,KHlBc,EAAE,CAAA,CDCE,GAAG,CAAC,EAAE,EOqB1B,GAAvB;AhB7DD,AkBEA,AYTmD,AtBSnD,ADAA,AJDA,ADZIL,AHYJ,A6BhBE,ACiBF,E3BbIA,C4BGmD,GFPjDwH,C1BIG,CcyEP,AJnDM,ASqDN,AnB3EQxG,C0BJD,GZ6EH,AGxBH,ANqBA,AQKG,AnB3EF,A0BJQ,CZ6EL,AKEA,AU/CM,A7B5BE,GQmDC,ASFT,ANqBA,CXtEYC,CUsBD,ACgDT,CGGI,AJnDM,CoBRH,AtBqCI,ADEA,CUJR,AjBjDG,CcyEC,AGxBH,AjBjDWrB,CWsEV,EHnBW,AWwBN,AnB3EJ,COqDW,AUJT,CanCM,AnBwDL,AXtEWgB,CQmDD,AMsBN,AKEA,CLFC,AJnDM,ACgDT,AQKG,CZtBO,AYsBN,CW7DG,ApBQI,AVtBhB,C8BcY,A9BdvB,COqD6B,EOoBJ,CAAC,IAAI,AJnDM,CF6BC,AMsBN,AJnDM,CF6BC,ADEA,AOoBN,AJnDK,CF6BE,EAAE,CAAC,ADEA,CCFA,ADEC,CAAC,Ca9B5C,CAAC,Cb8B8C,Aa9B7C,Cb8B8C,Ca9B9C,KH0BiD,EAAE,aVIgB,GAAG,CAAC,CAAC,CAAC,CAAA;ATzC/E,AkBEA,AYTEuM,AtBSF,ADAA,AJDA,AJAA,A6BhBI1F,ACiBJ,ECTE0F,EFRE1F,IZ6EF,AJlDM,ASoDN,AO/EM,EAAE,EZ6EJ,AKEA,AU/CM,ADxBA,AFTA,CZ8EL,AKEA,CSvEO,ClBmBC,CoBTH,AtBqCI,AE5BA,AO0BZ,ANqBA,CmBxDS,GtBqCO,ADGA,AG/BA,AO0BZ,ANqBA,AkB1CY,CnBLC,CAAA,ASoDL,AU/CM,CrBuBC,AGmBZ,EQKQ,CXxBO,ADGA,AULZ,ANqBA,CJhBa,AIgBZ,AQKM,CAAC,CLFC,AGxBC,CNqBN,CMrBQ,CHwBA,AGxBC,CNqBN,CJhBa,CIgBX,CJhBa,AOmBN,CPnBO,ECHE,CAAC,ADGA,CCHC,ADGA,ECHE,CAAC,CAAA,ADGC,GAAG,CAAC,AOmBN,CACxC,EAAE,CPpBgD,COqBlD,EPrBqD,EOqBjD,CAAC,CPrBoD,CAAC,CAAC,CAAA,YOqBtC,iBAErB,CAAC,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,CAAC,CACnC,CAAC;AhBlEJ,AkBEA,AYZuD,AtBYvD,ADAA,AJDA,ADbI,AHaJ,A6BhBIC,ACiBJ,CCZA,Gd6EC,AJvDG,AgB3BAA,CZkFF,AJvDG,CAAA,AVxBG1H,CUwBF,CAAA,ASoDJ,GnB5EW,A0BHF,CP+EL,AnB5EQK,C8BcD,AX8DN,AO/EMsH,GlBuDG,ASFZ,AYrBY,CAAC,C7B7BT,CiBkDD,AYrBY,CrBuBC,ADIA,AUNZ,ANqBH,EQKW,CnB5ES,CiBkDb,AjBlDJ,CiBkDK,AE0BM,CRLR,AkB1Ce,CAAC,C7B7BG,CWuEhB,AXvEiB1H,CQoDD,AqBvBA,CrBuBC,ASFZ,AE0BM,CF1BL,AE0BM,CF1BL,ANqBH,CAAC,GXvEf,CmB4E4B,CAAC,AnB5EQ,CoBgBtC,ATuDsB,CJfgB,AIef,EQKW,CAAC,CZpBO,AYoBN,CZpBO,CAAA,AIed,CAAC,CSjD3B,CAAC,CTiD6B,EHnBiB,CGmBd,CHnBgB,AGmBf,CAAC,CAAC;AD9C1C,AZZA,AkBEA,AVAA,ADAA,AJDA,ADbQN,AHaR,A6BnBY,ACoBZ,CjBUC,CAAC,CgB9BA,CZsFM,AJxDJ,ASoDH,AnB5EOA,A0BRoB,ChBgCxB,ASoDF,AO9EA,OIgBU,CDeC,C7B7BK,CAACY,CiBkDf,CVMa,GCJG,AGmBf,IAAI,CmBzDgB,AtBsCA,ASFZ,AjBlDK,C8BcQ,A9BdlB,CiBkDO,CTEa,ASFZ,ENqBD,KmBzD4B,AnByDvB,GHnBkB,AGmBf,CHnBgB,CY9BpC,ATiDsB,OSjDf,CAAC,IAAI,CAAC,CN0DU,GAAzB,MN5B8D,CAAC,KAAK,CAAC,CAAA,CY9BnC,CAAC,gBAAgB,CAAC,CAAC,CAAC;AVIvD,AZbA,AkBEA,AYTA6N,AtBSA,ADAA,AJDA,ADbK,AHaL,A8BCA,IR+DQ,ILGN,Ac3EM,CAACjN,GCwBG,CtB2BC,EOwBJ,AenDM,CCfC,AboCZ,CYrBa,CDxBjB,Cd2Ea,Ac3EM+O,CESC,AtBsCA,AM4BN,CG9BL,ETEc,CGmBjB,EHnBoB,CoB/C1B,CTwEa,ESxEiB,CESC,AX+D9B,CW/D+B,ItBsCI,AM4BN,AHTZ,CHnBmB,AM4BN,AHTZ,GAAG,AiBlEkB5J,CX6CT,AE2BjB,CF3BkB,AW7CF,CjBkEL,CAAC,AiBlEkB6J,CjBkEjB,CQMA,ERNG,CiBlEA,EAAqB,EESE,CAAC,EnByDhB,CmBzDmB,AnByDlB,CmBzDmB,GtBsCG,CAAC,GAAG,CAAC,CsBtCC,AtBsCD,CsBtCE,EAAE;AhCDtE,AkBEA,AYTEA,AtBSF,ADAA,AgB7DArM,ApB4DA,ADbC,AHaD,A6BhBE,ACiBF,C3BzBA,C4BgBEqM,C5BHF,Cc8EC,CAAC,CO/HI,AK4CArP,CEQC,APpDA6D,CF4HL,ESxEQwL,ErBoDE,AYoBN,CZpBO,EqBpDE,AFRA,CTqDX,AYrBY,AHhCA9P,ClBuDC,ADKA,AYoBN,AUhDM,CtB4BC,CAAA,AUPX,AYrBY,ADxBA,CESC,CT7DpB,CJiGU,AE2BM,AE5HMwC,AK4ChB,CEQJ,CjBkEI,EQMc,AUhDM,AHhCA,CIiBC,ADeA,AHhCzB,CTqDc,AE2BM,CF3BL,ASrDY2E,CGgCC,ECfE,AJjBA,CIiBC,AT7DA,AK4CAI,CL5CCzG,EVsHhB,CmBzDmB,AnByDlB,CmBzDmB,AJjBT,Ef0EP,Ce1EmBL,Ef0EhB,AUtHzB,CVsH0B,CAAC,AUtHkBsC,GVsHf,CmBzDmB,CAAC,AJjBA,CAAC,CL5CC,AK4CF,CL5CGjC,AK4CxB,Gf0ES,CAAC,KUtHvC,SS6DuE,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAA;AhCDvF,AkBEA,AVAA,ADAA,AgB5DAlC,ApB2DA,AJAA,A6BhBE,ACiBF,IbmEC,EO/HK,AK2CA6B,CL3CC5B,EduGE,GYoBN,CUhDU,CR3Eb,CK2Ce,ClBuDC,ASFZ,ASrDYmB,CIiBC,AT5DAwC,EF2HP,CAAC,CAAC,COhFN,Ef0EA,CMrBO,CSrDa,CAAxB,CL3CF,CK2C6B2E,ClBuDC,CAAC,CkBvDC,CAACK,ElBuDE,CAAC,AGmBlB,CAAC,Ee1EU,Cf0EP,Ee1EoB/G,Cf0EjB,CAAC,CAAC,GAAG,GAAG,Ae1EkB,Cf0EjB,Ae1EkB,CAAD,CAAtB;A5BgB7B,AkBEA,AYVE,AtBUF,ADAA,AgB5DA7B,ApB2DA,AJAA,A8BCA,GjBWG,GWvEG,COkDC,APlDAC,CdwGC,CYmBL,ESzEQkR,CEUC,ADeA,CCfC,AboCT,CVQU,AcxGd,CAAexL,CQ2EC,CDzBC,CrBsDC,AsB7BA,ErBuBE,AoBhDA,CrBsDC,CcxGrB,CbkGuB,CGmBjB,CiBnEmBoK,APlDAnM,EdwGE,CAAC,CavCzB,CAAC,CAAC,EbuC4B,AqBtDb,CrBsDc,CAAC,AqBtDAwN,CjBmEjB,AUrHlB,CdwGqC,AIalB,EiBnEjB,CjBmEoB,CiBnEmBD,EjBmEhB,CJbmB,AIalB,CAAC,EJboB,AqBtDA,CrBsDC,AIalB,CJbmB,CAAA,CIahB,CAAC,AiBnEkB,IAAlD,GAAyD;AlBsB3D,AZbA,AkBEA,AYVI,AtBUJ,ADAA,AgB3DAnR,ApB0DA,ADbA,AHaA,A6BjBE,ACkBF,MjBWM,AWtEA,AKyCA6I,CZqFF,AO9HG5I,CduGC,AYmBN,ASzEMgM,CEUC,A9BdAjK,C8BcC,CAAA,CvB4CE,AURT,AW9CS,CrBsDC,AYmBN,AnB7EP,CqB7CA,ArB6CcrB,C4BICwQ,APjDAzN,AKyCA,CTsDR,AE2BG,AUhDM,AHjCA4E,CGiCC,A7B7BjB,CUyBkB,CmBIC,A7B7BArG,CQoDC,ADMA,AmB9DL,CnB8DM,AGjCA,AOyBT,ANqBN,AQMS,ASzEM,AFRnB,ChB6BoB,AOyBT,AE2BG,ASzEMgK,CFRC,CnB8DC,AavCtB,ApBnBF,CQoDyB,AE3BA,COyBR,AYrBS,ADzBtB,APjDJ,ArB6C0B,CUyBC,AmBIA,CtB6BC,AavCtB,CbuCsB,AavCrB,AChEsBvI,EQ0EE,EVgDJ,EAAE,CAAC,IE1H9B,MDgEwB,CAAC,GAAG,CAAC,MH+ByB,EAAE,QG/BX,EAAE,IAAI,CAAC,CAAC;AtBNrD,AkBEA,AYVI2N,AtBUJ,ADAA,AJDA,ADbI,AHaJ,A6BjBI,ACkBJ,IGAI,AhBmEY,AJxDZ,AkBrBAA,CEUC,E9BdI1Q,CO2DD,AYkBN,ETpDQ,AVzBN,EO2DQ,AYkBN,CZlBO,AP3DEA,EUyBA,AkBrBA,CX8CX,AYrBY,ADzBA,A5BJZ,CmB6EO,CTpD4B,EF2BnB,AE3BqB,AOyBjC,AE2BM,ASzEC,ClBqB0B,AmBIpB,CDzBC0G,CrBuDC,AsB9BA,CTVrB,AD0DgB,ASzEH,CjBkEH,AQOO,CXzBO,ADOA,AqBvDA8J,CX8CX,CTEa,CGkBZ,CJXc,AUTP,CTEQ,ADOD,CUTL,AW9CV,CX8CW,CTEQ,AWyBN,ASzEMD,CjBkEZ,AQOO,IXzBU,AoBhDxB,CjBkEY,AQOO,ASzE9B,CTyE+B,CAAC,CRPN,ESnDtB,ATmDwB,IGWO,AM9D3B,EAAA,CN8DX,UAAuC,KAAa;AhBpErD,AkBEA,AYVIC,AtBUJ,ADAA,AJDA,ADbI,AHaJ,A6BjBI5I,ACkBJ,IGeI,ApBJA,AkBrBA4I,AFRA5I,G1BIKtG,A0BJF,CIiCQ,AvB8BP,AOsBN,AKJA,AOjFM6G,EhB6BE,AkBrBA,ErBuDE,AYkBN,AnB7EF,C4BISmD,EEyBS,AhBoDb,AdjFQhK,CiBkDb,CE2BO,ASzEP,CFRA,CPiFS,CXzBO,AM6BN,AG/BN,AYrBY,A7B7BhB,CciFW,AepDM,AHjCAqG,EGiCE,ClByCjB,CHlBmB,AkBxDrB,EhB6BuB,CIwDL,CPtBO,AOsBN,CJxD+D,AmBIxD,CtB8BC,AsB9BA,CZqBX,CVSa,CGlCyD,AOyBpE,ENoBJ,CAAC,EkBzCoB,ClByCjB,CD7C2E,EAAE,AC6C1E,CD7C0E,AC6CzE,CAAC,GAAG,QAAQ,CAAC,aGWyB,EAAE,MAAM,CAAC,CAAC,gBPtBsB;AT9ChG,AkBEA,AYVG,AtBUH,ADAA,AJDA,ADbC,AHaD,A6BjBG,ACkBH,GDrBE,CZwFD,AJxDG,CIwDF,GgBpDM,ApBJA,CgB7BC,GIiCG,AvB8BA,AYkBT,CWhDU,AJjCAA,GnB+DG,CuB9BC,AtBuBA,ADOA,AsB9BA,AHjCR,CIiCS,AtBuBA,CAAA,AWyBR,AOjFS,CTsDd,IGjCH,ATqDI,AQOS,CTpD4C,ASoD3C,CTpD2C,COyB/C,CAAC,CVSgB,EuB9BE,CvB8BC,CuB9BC,AVZrB,CAAC,ETqDK,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CJXmB,CAAA,CUTb,ANoBH,CAAC,EMpBK,KAAK,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;AnBrClE,AkBEA,AYVC,AtBUD,ADAA,AJDA,AJAA,A6BjBI,ACkBJ,CCjBA,GdsFQ,AJ1DJ,KSoDD,CTpDO,EoBIE,AvB8BA,CCPC,AqBvBA,GCAG,AvB8BA,CuB9BC,AvB8BA,AGlCA,AOyBZ,GPzBe,GAAS,CUR3B,ATqDI,CD7CyB,GURzB,CAAC,CUYuB,GAAG,GnByCf,CAAC,GAAG,CJXmB,EIWhB,CJXmB,AIWlB,CAAC,CSrDH,CAAC,CTqDK,KSrDC,CAAC,CNkEL,CHbW,CAAC,CGatC,EgBtDkD,CAAC,IAAI,CAAC,CvB8BU,CAAA,AOwBvC,EMlEoB,CAAC,CAAC,EUYe,CAAC,CAAA,ChBsDrB;AhBtE7C,AkBEA,AVAA,ADAA,AJDA,ADdAtG,AHcA,A6BjBI/B,ACkBJ,I3BfI,A0BHAA,C1BGCiC,GcoFH,AJ1DM,ASoDN,CWhDO,AvB8BA,AsB9BA,EHjCE,ClBwDC,AM+BN,AYvFM6G,CPiFL,CTpDO,AV1Bd,CAAetH,CiBmDX,AE2BM,EAAE,AnB9EZ,CiBmDO,AStDH,ChB6BgB,AOyBZ,AStDY8G,CZuFL,AdpFM,CmB8EL,CTpDO,ASoDN,AOjFb,CTsDQ,AGjCV,ATqDI,CMpBO,AStDYD,CZuFL,EJ1DQ,CAAC,AgB7BzB,CZuFoB,AJ1DM,CF2BV,AE3BW,CF2BV,AM+BK,AJ1DK,AOyBX,CAAC,AjBnDY,CiBmDX,CE2BO,CRPX,AQOY,CXzBJ,AGkBP,CHlBQ,EGkBL,GAAG,CAAC,CAAC,CSrDlB,ETqDqB,ESrDjB,CTqDoB,CSrDnB,ATqDoB,WHlBkB,CAAC,CAAA;AVvCrD,AkBEA,AYVA,AtBUA,ADAA,AJDA,ADdI,AHcJ,A6BjBG,ACkBH,GDjC4B,CnB8ExB,AmB9DF,CnB8DG,EP5DI3H,C8B8BD,ApBJA,ASoDN,AUhDM,CDzBC0Q,C5BLL,CAASlP,CQqDD,AM+BT,AJ1DS,ASoDN,CTpDO,ASoDN,AUhDM,ECAE,ADAA,CZqBX,AjBnDA,CAAe,E8B8BA,AtBuBA,AM+BT,AJ1DS,CoBIC,AFzBpB,ClBqBqB,AC6Cf,AiBlEgB8M,A5BLlB,CmB8EY,CAAC,AnB9EQ,EiBmDZ,AW9Cb,EX8Ce,AW9Ca5H,CX8CZ,AE2BM,AnB9EQpF,CmB8EP,ASzEvB,EAAgCqP,CTyEN,CWhDO,A9B9B7B,C8B8B6B,CFzBjC,ETyE+B,ASzEOJ,CTyEN,ELMD,CAAC,Cc/EhC,EAA6C,iBd+EO,CAAC;AhBtErD,AkBEA,AYVE,AtBUF,ADAA,AJDA,ADdC,AHcD,A8BCA,CpB6CC,AP9DD,G8BgCI,CAAC,CFzBCF,ETyEJ,CLMC,Ac/EM,GlBqBG,ASoDN,AUhDM,ADzBAM,CTyEL,GXzBS,ASFZ,AW9CY,CAAC9M,ElBqBC,EOyBT,CE2BO,ASzEd,CTyEe,ERRL,GQQU,AUhDM,CVgDL,CXzBO,AqBvBA,EVgDJ,KAAK,CAAC,IF3BA,CAAC;AVWjC,AThDA,AkBEA,AVAA,ADAA,AJDA,AJAA,A8BCA,IGgBiB,IhBqDf,AKNA,CZjBO,AGnCA,GI0DH,GKNG,CW/CoB,AtBsBb,ASFZ,AYrBY,CCCc,AhBqDnB,AetDM,EZqBV,AYrBY,CfsDL,AKNA,CXzBO,AWyBN,CF3BL,CTEa,CM+BL,AHdZ,CGca,CPvBO,AsB/BA,CCCsB,AvB8BlB,AsB/BH,EZqBV,CAAC,CHiCO,CPvBqB,AOuBpB,EPvBsB,CAAS,CISvC,AkBxCkB,CrBuBC,AGiBlB,GAAG,CGca,CAAC,CAAC,AHdZ,CAAC,CAAC,GAAG,MAAM,CAAC;AbxDrC,AkBEA,AYXE,AtBWF,ADAA,AJDA,ADfAzE,AHeA,A6BlBE,ACmBF,IpB8CI,AYiBH,CC/DC,AD+DA,CS1EIwR,AFRAtJ,C1BGC,CO8DC,AOuBN,AJ1DM,AV3BA7F,GO8DG,COuBL,CetDO,AD1BA,A5BLb,CO8Dc,AqBzDA6M,CrByDC,CCRC,ADQD,AUVX,AjBpDY,CcqFL,AYxFM,CEQJ,AFRK1G,CZwFL,CchFOyI,CFRC,CAAClI,ClByDC,AoBjDV,CjBkEP,AiBlEJ,CpBiDuB,AE3BA,AOyBZ,AjBpDb,C4BK0B,ElBsBE,CF2BC,GkBzDZ,CAAf,EAAiCP,Cf0EjB,CAAC,Ce1EmB,CAACO,Cf0EjB,GAAG,CAAC,CAAC,CD5CmB,CAAC,CC4CjB,Ce1EK,GAAiB,ChB8BC,CAAC,AC4ClB,CD5CkB,AC4CjB,Ee1EF;A5BkBnC,AkBEA,AYXI0I,AtBWJ,ADAA,AJDA,ADdAzR,AHcA,A6BlBE,ACmBF,IpB8CI,Aa7CH,AD+DO,AS3EJyR,EFREvJ,CEQC,A5BJA,CO6DC,AGnCA,AkBtBAgH,A5BJA5M,GAAR,C8B8BQ,AvB+BI,AOuBT,AetDS,AD1BL,CpBiDM,ASFT,CTES,AE3BC,AkBtBAiP,A5BJA,CO6DC,CP7Df,C0BJiB,CIkCH,AF1BP,AFRW/I,CZwFR,AchFN,CrByDgB,CAAC,AmBjEA,ChB8BC,AgB9BAI,EZwFP,AHdT,CmBxCe,AhBsDL,AJ1DS,EHmCE,AmBjEV,CIkCO,AvB+BG,AmBjEzB,CGkC2B,CHlCCJ,CGkCC,EHlCE,CIkCH,AXiDX,AOnFeI,Ef0EhB,CAAC,AQSlB,EOnF6B,Cf0ER,ED5CoB,AgB9BA,ChB8BC,AC4ClB,Ae1EK,Cf0EJ,CmBxCe,AnBwCd,CmBxCe,ApBJI,CAAC,CC4CjB,KD5CuB,CAAC,AC4ClB,CD5CkB,AC4CjB,GmBxCiB,CAAC,UAAU,CAAC,CAAA;AhChBlE,AkBEA,AVAA,ADAA,AJDA,ADdA5I,AHcA,A6BlBE,ACmBF,IpB+CI,EmBlEEkI,C1BIC,CO8DC,AGpCA,ASqDN,AnB/EM3F,CQqDC,AM+BN,GgBtDK,AvBgCI,AUVT,AjBpDH,GmB+ES,AnB/EM,CU0BC,AO0BT,AYtBS,CtBgCC,AGpCA,AO0BT,AjBpDR,A0BJiB,CnBkEC,AmBlEAiG,CIkCH,AXiDF,CWjDG,AvBgCI,AYiBN,COnFO,CAACK,ChB8BC,CC4CjB,EmBxCyC,EAAE,AJlChC,CPmFM,AOnFrB,CPmFsB,COnFOL,EIkC0C,ADAxC,CHlCC,CIkCiD,AXiDtD,AOnFMK,Cf0EjB,AQSY,CWjDuD,AnBwClE,AQSY,CAAC,CAAC,CTrDO,AC4ClB,CD5CmB,AgB9BV,ChB8BU,CC4ChB,CMlBU,ANkBT,Ae1EkB,CTwDR,ANkBT,CMlBU,ENkBP,Ce1EC,Kf0EK,CAAC;AbxDrC,AkBEA,AYZI,AtBYJ,ADAA,AJDA,ADdA7I,AHcA,A6BlBE,ACmBF,IRgEC,CAAC,COnFIkI,CNoBF,ApBhBG,CQqDC,ADSA,AOsBN,AJ1DM,AkBvBA,A5BHA1F,CiBoDL,AWjDM0M,IdiFF,AcjFM,CAACU,CpBkDC,ADSA,AP9Df,C8B8BY,AvBgCI,AOsBN,AetDM,CtBgCA,AsBhCC,AHlCA,CnBkEA,AP9DC,A0BJApH,ClByDC,AqBvBA,CrBuBA,AM+BL,AdpFd,CcoFe,AHdT,Ae1Ee,CIkCH,A9B9BI,A0BJAS,EIkCF,CpBJK,AkBvBZ,ClBuBa,AmBIA,AD3BtB,CE2BmB,ADAI,CD3BC,CE2BH,CDAK,EtBgCC,AGpCC,CAAC,EoBIF,AJlCd,CAAf,CIkC+B,CJlCKT,ChB8BC,CoBIH,ApBJI,CAAA,AgB9BC,CIkCH,AJlCIS,CZwFL,CAAC,CgBtDG,MAAM,CAAA,ChBsDA,CAAC,CAAC,AYxFX,GAAoB,IAApB;A5BkBtC,AkBEA,AYZMgI,AtBYN,ADAA,AJDA,AJAA,A6BlBE,ACmBF,InBsCI,AYrCI,ADgER,CX3BK,ADSA,CqB3DCA,AFPAzI,EZwFJ,AJ1DM,AO2BN,CWlDO,AFPA,CAACK,EZwFJ,AG/BA,AWlDMiF,CdiFL,AJ1DM,AO2BN,AYvBM,CnBJC,EoBIF,AJlCV,EAAgBtF,CZwFL,AJ1DM,ASsDlB,CWlDe,AhBsDF,AHdT,CD5CgB,AkBvBf,AFPe,ChB8BA,AgB9BCE,CIkCH,AnBwCX,EAAE,CAAC,EmBxCa,AbuBF,CavBG,AhBsDF,AG/BA,ASzDL,CZwFM,AG/BA,CavBG,CJlCKQ,CZwFL,KAAK,CAAC,GMpEN,GAA1B,GMpBiB,ONoBU,SAAiB,EAAE,eAA2B,EAAE,iBAA+C,EAAE,UAAgC;ADgE7J,ArBlEA,AkBEA,AYZK,AtBYL,ADAA,AJDA,ADfAlJ,AHeA,A6BlBE,ACmBF,CRiCA,AA+BC,GXzBU,ADQP,CUTF,AE0BD,EnBhFM,CcqFL,AJ1DM,AUXuC,ApBhBvCyC,C6B+BC,AHlCA0G,EnBkEE,GAAG,COsBL,CdrFT,CO+DiB,AIQZ,EHhBqB,ARvDP,C8B+BH,AtBwBW,AM8Bb,AYxFM,CnBkEC,AOsBN,AdrFf,A0BHqBX,EnBkEE,CmBlEH,ClB0DY,AE5BP,CoBIH,AJlCIxC,EIkCF,ApBJI,CgB9BR,EAAWwC,ChB8BC,CAAA,CgB9BE,CAACI,EIkCF,EAAE,CVfY,AMnB3B,CAAlB,CNmB6C,GUeN,EAAE,GAAG,OAAO,CAAC,GVfoB,SUeR,CAAC,GAAG,EAAE,KAAK,CAAC,SAAS,CAAC,CAAA;AXkB3E,ArBlCb,AkBEA,AYZG,AtBYH,ADAA,AJDA,AJAA,A6BlBC,ACmBD,IbqEC,AG9BA,CH8BC,GN9BM,ADQA,AGpCA,AO4BH,AGxCuE,ASgBpE,IrBwBI,CGgBR,CJRU,CGpCC,AmBIA,CZwBF,CTAI,ADQA,AGpCA,AO4BH,AYxBG,CnBJA,EoBID,AvBgCI,ECRE,CSAF,CVQI,CuBhCH,AvBgCI,CuBhCH,EbwBG,AEPJ,CFOK,CVQI,CCRC,ADQA,AURH,CVQI,CCRC,EDQE,EuBhCF,CvBgCK,EuBhCF,EvBgCM,AahDkC,CbgDjC,CahDiC,EUgBlC,AvBgCI,CuBhCH,AvBgCI,CAAC,CAAA,GuBhCA,EAAE,CAAA,aVhByE;ADkE3H,ArBlEA,AkBEA,AVAA,ADAA,AJDA,ADfA,AHeA,A8BCA,IbsES,AJ3DL,CAAC,CAAA,CAAA,CHoCG,AURN,AGzC2H,CTyD1H,AXvEMlG,GQsD0B,ADSvB,AURN,AYxBM,CZwBL,AjBvDP,GAAgB,CO+DC,AP/DC,CO+DA,CCTwB,CsBvB1B,ADAI,CtBgCC,CAAC,AsBhCA,GCAD,CAAC,AvBgCI,CAAC,EAAE,CCTwB,CAAA,GSCzB,CaxBG,AbwBF,AGzCgG,CHyC/F,CGzC+F,CUiB3F,SAAS,CAAA,MVjBkH,INwE9H,GAA9B,UAA+B,SAAiB;AhBvEjD,AkBEA,AYbE,AtBaF,ADAA,AJDA,AJAA,A6BnBAxC,ACoBA,IjBYI,ASkEH,CFvCC,CWpDI+Q,CFPC,CZ0FL,AMxEA,AT0DA,Ae5EMxK,ClByD+C,AoBlDrD,ElByBS,AkBzBA,CrB4DC,AOuBN,AJ1DY,EAAqB,CUd9B,AT0DA,Ae5ET,CnBmEgB,AGnCyB,AmBGzB,CCAH,CpBH8B,AgBhCzBA,CnBmEC,AajDN,ADgFA,CChFC,EbiDQ,AOuBN,CPvBM,EOuBH,AY1FnB,EPkG+B,AO/F/B,EZuFuB,AKQU,CLRT,GMxEG,ASiBM,CTjBL,GDgFmC,EAAE,IAAsB,GLR/C,CAAC,MMxEM,CAAC,ENwEE,CAAC,CAAC,KMxEK,EAAE,eAAe,EAAE,iBAAiB,EAAE,UAAU,CAAC,CAAC;AtBC3G,AkBEA,AYbIa,AtBaJ,ADAA,AJDA,ADfAtH,AHeA,A8BCA,IVwCC,AG1CA,AQXGsH,CRWF,CQXI,CAACzG,A5BHA,CQqDC,AMiCN,AJ1DM,ASkEN,AnB9FM8B,CO+DC,CP/DT,CiBwDQ,AWrDJ,CpBkDQ,AMiCN,AHdH,AQsBG,AS3FMwO,CT2FL,AnB9FMzO,CiBwDF,CAAC,CaxBA,ADDI,CrBsBC,AGmBT,AkBzCS,AD5Bb,A5BHJ,EWwEU,AkBzCS,AD5BAuO,GE6BD,AtBqBI,AWyCN,AS3FM,CAACxM,CE6BH,CX8DD,CXzCO,AqBtBA,CAAC,CrBsBC,AoBlDxB,CdmFmB,CevDO,AD5BAwM,CjBqER,CGcI,AHdH,CQsBI,AS3FM,CT2FL,AS3FM9F,CE6BH,ChBsDD,AHdH,CmBxCM,AhBsDF,AHdH,AiBrExB,EjBqE0B,AiBrES+D,CE6BH,AnBwCL,GiBrE3B,EE6BqC,CAAA,CpBJM,UI0DI,CAAC,SAAS,CAAC,CAAC;AG7B/D,AnB1CA,AkBEA,AYbG,AtBaH,ADAA,AJDA,ADfAlP,AHeA,A6BjBAyG,ACkBA,CVwCC,GG1CD,GpBdO,A0BFA,CZwFL,AJ1DM,ASkEN,AnB9FM7D,A0BFAiG,IlBsDsB,AMkCxB,AJ1DM,AC4CT,AQsBG,CZhCS,AYgCR,AU/DM,CHjCb,EIkCY,CpBJK,AC4CT,Ae1ES,ChB8BC,ASkEN,CX1CyB,AExBlB,AUdlB,AT0DS,AXxEV,CU4BoB,CI0DL,AKQA,CW9DG,A9BhCInG,EcsFJ,CNlCyB,AExBlB,ASkEN,CX1CwB,AW0CvB,AnB9FpB,CU4B2B,CI0DL,CAAC,EgBtDI,ApBJI,AC4CT,CAAC,EmBxCO,EnBwCH,CAAC,EAAE,CAAC,GGcM,CAAC,CgBtDG,CAAC,EpBJM,EAAE,CoBIH,EAAE,CAAA,AhBsDD,CAAC,SAAS,CAAC,CAAC;AG3O5D,AGmKA,AtBCA,AkBEA,AYbC,AtBaD,ADAA,AJDA,ADfA1C,AHeA,A6BjBE,ACkBF,CPzGA,AAsGC,IAAA,EpBbM,CcuFL,AKOA,AnB9FM6C,CQmDqC,AqBpBpC,CHjCE,CAAC,CnBgEA,AGlCA,AC4CT,AQsBG,AnB9FN,A0BFW,CPgGJ,COhGQ,CnBgEA,AOyBN,AdvFMH,C8BgCH,AJlCD,Cf0EH,Ae3ES,CnBiEC,COyBL,AHfH,AXxEV,C8BgCgB,CAAC,AvB8BI,CUPpB,AEuCe,EZhCQ,CAAC,AYgCN,CZhCM,GGlCI,CoBIH,ApBJI,CC4CR,CmBxCM,AhBuDF,AHfH,CGeI,AKOA,CAAC,ETlEQ,AC4CT,CAAC,CD5CU,CAAA,AC4CR,CAAC,EGeK,EAAE,UAAU,EAAE,iBAAiB,EAAE,SAAS,CAAC,CAAC;AG9BhF,AGlJa,AtBwGb,AkBEA,AVAA,ADAA,AJDA,ADfA1C,AHeA,A6BjBE,ACkBF,IbuEC,CAAC,AexDG,E7B/BE,CQmDC,AW2CN,AnB9FM8C,CO8DC,EP9DT,CQmDY,AEvBA,AC4CT,AQsBG,AOhGO,CPgGN,AOhGO,C1BEAJ,A0BFD,EAAI,ClBqDA,AGqBT,CD5CU,AV5BlB,A0BFa,Cf0EH,AQsBG,AOlGI,CIoCD,EX8DA,EAAE,CAAC,CW9DG,CAAC,CV1HF,CZ6IQ,CEvBC,CC4CR,CAAC,CD5CU,GoBID,AnBwCL,CAAC,CmBxCM,CAAA,AnBwCJ,CAAC,SHrBQ,CEvBW,CFuBT,AEvBU,GAAG,CAAC,EAAE,CAAC,CAAA;AUiF7C,AtB9Fb,AkBEA,AYbA0M,AtBaA,ADAA,AJDA,ADfApP,AHeA,A6BjBE,ACkBF,IbwEC,AGxBA,AE8BA,AU9DG,CtB8BC,AYgCH,EnB9FK,CoB4GM,AQzGL,A5BHA+C,CWwEL,AiBrEMZ,CjBqEL,CkBxCO,CrBkBgC,AEtB/B,CmBIC,ET4EO,AM9GJ,CAAC,CAAD,CN8GqB,AQzGrC,CpB+CkD,AoB/C/BsH,AFLC,CIkCJ,CJlCA,C1BEhB,A0BLiB,ElBuDsC,CAAC,ARlD/B/G,C4BGzB,CE6BuB,EpBJM,AOoChB,AW7DgB,A5BH7B,CU4B8B,CoBIH,CAAA,AtBkBoC,CAAA,EScpC,CPpCS,CAAC,EAAE,AkBzBA4E,ClByBC,AUgFa,CVhFb,AUgFc,AQzGzB,EAAc6J,ERyGe,CAAC,EQzG9B,EAAqB;A9BYlD,AkBEA,AYbEA,AtBaF,ADAA,AJDA,ADfAnR,AHeA,A6BjBE,ACkBF,ECbEmR,ErB4DE,AISH,AQGc,CRHb,EiBrEK,A5BHA,CiBgEL,AYhCM,A7BhCAnO,CQiDyD,AqBjBxD,CD7BCmO,CC6BC,CnBJC,AOoCN,CAAC,ASlEO,CAAC,CEKA,AFLD,EIkCD,ApBJI,AgB9BC,ChB8BA,AmBIA,CZgCL,AYhCM,AD7BA,AFLL,CAJG,ETsED,CPpCO,AkBzBrB,ElByBuB,CAAA,AmBIC,A7BhC1B,EiBgEsB,AEWW,CFXV,AjBhEMzO,EmB2E5B,EnB3ED,QmB2EkC,MAAiB,gEZZ4D;AThD/G,AkBEA,AVAA,ADAA,AJDA,ADfA1C,AHeA,A6BjBE,ACkBF,IpB+CI,AIUI,GXzED,CQiDC,ASeN,AEWA,AU3CM,A7BhCAiD,GO+DG,AmBjEC,ChB8BA,AOoCN,AjBhEN,A0BFa,CTkEN,CVDO,AmBjEF,ClBmDG,AW0BN,AnB3EMP,C8BgCH,AbgCF,AYhCM,AHlCC,CnBiEA,AGnCA,CHmCC,AGnCA,AmBIA,AHlCN,CTkEC,AEWA,AnB3Eb,A0BPiB,ClBwDG,ASeN,AEWA,CX1BO,ASeN,CahCG,AvB+BI,AGnCA,CHmCC,AGnCA,CoBIH,CpBJK,CHmCC,AGnCA,CAAA,EFqBG,CDcC,CCdC,CsBjBH,AtBiBG,EsBjBD,CvB+BK,CAAC,IuB/BA,CnByCd,AQEa,CW3CG,AvB+BI,AYYN,ERFnC,CmBzCwC,CvB+BK,KAAK,CAAC,AYYN,CAAC,CW3CG,AnByC3B,CmBzC2B,AvB+BK,CAAC,GAAG,AYYN,CZZO,AIUtB,AQEgB,CZZO,AYYN,CRFf,AQEgB,CZZO,KIUR;Ab1DvD,AkBEA,AYdE,AtBcF,ADAA,AJDA,ADfA1C,AHeA,A6BjBE,ACkBF,InBiCI,AW0BH,CX1BI,AW0BH,ELaE,ActFG,A5BFA,CO+DC,AUCN,ANSA,AXzEMkD,E0BFG,CnBiEA,AqB7DAkO,AFJC,ChB8BA,AOoCN,ANSA,AkBzCM,CtB+BC,AUCN,ANSA,AkBzCM,AHlCF,CnBiEE,CsB/BE,AHlCC,CIkCJ,AbgCF,CNSC,AiBvEM,AFJN,Cf2EC,AejFK,CTwEJ,CW9DO,EE8BF,ADAI,CCAH,ADAI,A7BhCvB,CU4BwB,CAAC,AOoCN,AW9DMpB,CX8DL,AjBhEMtN,CWyEL,EAAE,CD7CO,AV5B9B,C8BgC2B,ApBJI,AmBIA,CCAH,ApBJG,AOoCL,CAAC,AW9DP,EE8BW,AF9BIgP,EE8BF,CAAC,CF9BhC,EAAuCN,GE8BD,CAAC,EF9BM,CE8BH,GAAG,CF9BK,IAAlD,GE8BqD,AF9BI,CE8BH,CAAA;AhCjBxD,AkBEA,AYdI,AtBcJ,ADAA,AJDA,ADfApR,AHeA,A6BjBE,ACkBF,InBkCW,AMsCF,AKZM,CZbV,EP/DE,CiBgEL,AW9DM2R,A5BFAxO,CU4BC,AmBIA,EHlCG,CTkEN,ANSH,AiBvES,AFJC,CTkEN,CSlEK,CEIGiO,CE+BH,AJnCK,CTkEN,CSlEC,ClBoDc,AGuBhB,AelFO,ClB2DU,AScb,CAAC,AW9DM,CX8DL,AW9DMO,CE+BH,AnBwCL,CAAC,CHvBiB,CoBhD5B,CE+BmB,A9BjCvB,C8BiCwB,EnBwCH,AXzESjP,CWyER,AQGc,EW3CP,CX2C5B,AnB5ED,UmB4EqC,MAAyB,ELYrC,GAAxB,UAAyB,KAAa;AhBzEvC,AkBEA,AYdI4O,AtBcJ,ADAA,AJDA,AJAA,A6BjBE,ACkBF,IpB+CI,AqB7DAA,IpBgDI,AMsCN,AJ5DM,AOoCN,AEYA,AU5CM,ClByCL,Ce3EQ,CAAC,CZ0FN,AGxBA,CTdO,AMsCN,AGxBA,AYhCM,AHlCF,EP8EF,AU5CM,AD9BA,AFJC,ClBoDA,AoBhDA,CX8DL,ASlEA,CZ0FC,AYlGK,EI2CD,AhBuDF,AGxBA,AW9DC,CE+BE,Ab+BF,Ca/BG,Ab+BF,AW9DMhK,EpBgDE,AoBhDT,CpBgDU,CsBjBH,AF/BI8J,CE+BH,GtBiBO,EAAE,AoBhDjB,EpBgDmB,AoBhDAD,CpBgDC,CAAA,EW0BH,CAAC,AS1ElB,CAAX,KT0EmC,CAAC,CAAC,CW3CG,CAAC,CpBLK,KoBKC,CAAC,iDvB8BqD;AThDzG,AkBEA,AYdIC,AtBcJ,ADAA,AJDA,ADfApR,AHeA,A6BjBE,ACkBF,IpB+CI,AUCH,AEYA,AS1EGoR,CX8DF,AEYA,EnB5EK,CQkDC,ADaA,AGnCA,AC8CN,AX1EMhO,E4BEE,AFJC,CnBiEA,AmBjEC,ClBoDA,AMsCT,AJ5DS,AC8CN,AkB1CM,CrBkBC,AoBhDAuO,AFJF,CnBiEG,CAAC,AmBjEC,EhB8BC,AkB1Bb,A5BFJ,A0BFW,ChB8BO,AC8CN,AerFK,CnB0EE,AOyBT,CgBvDM,AhBuDL,AHdG,AX1EM,C8BiCH,AtBiBI,AMsCT,CgBvDM,AtBiBI,EDaE,CAAC,AGnCA,CoBKH,ApBLI,CoBKH,AtBiBI,CAAC,ADaA,AGnCA,AmBIA,CtB+BC,AGnCA,CFsBC,AqBlBA,A7BhCAtO,IO+DI,AGnCA,AV5Bd,CU4Be,CAAC,AV5BA,C6BgCC,CnBJC,AmBIA,CtB+BC,CAAC,CsB/BC,ECCF,AvB8BI,CuB9BH,EvB8BM,CAAC,CAAC,EuB9BF,AvB8BI,CuB9BH,CAAA;AhClB/C,AkBEA,AYdG,AtBcH,ADAA,AJDA,ADhBsC,AHgBtC,A6BjBE,ACkBF,IVgDA,AEyBQ,IZ1BA,COyBL,AexDM,A7BjCoC,EOgElC,APhE2B,A0BD1B,CImCJ,AtBgBwB,AErBpB,AC8CT,Ae5EU,CImCJ,AvB8BI,CuB9BJ,AvB8BI,AmBjED,Ef4EL,Ae5EU,ClBmDoB,AErBpB,CAAC,AgB9BN,CAVK,ClB6DuB,CAAC,CAAA,AErBnB,AC8CT,CD9CU,CC8CR,CD9CU,CAAC,AOoCzB,CPpCyB,IS6DP,GAAlB;AFzBD,AnBjDA,AkBEA,AYdC,AtBcD,ADAA,AJDA,ADjBiD,AHiBjD,A6BjBE,ACkBF,CV+BA,AAgBC,AWpED,A5BGA,IOiEK,AUAJ,AY/BI,GCCD,AhBuDF,AKCA,CWxDG,AtBesC,AEpBlC,GI4DH,CAAC,AY1FO,CAAC,CP2FN,CRfL,Ae5EU,CZ0FH,CAAC,AY1FO,CP2FN,CAAC,AO3FA,CAXG,EfuFN,IAAI,CAAC,CQeO,CAAC,URfI,CGcO,AHdN,AQeM,ELDE,AKCA,CAAC,ERfJ,CAAC;AMmDnC,AnB9GA,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BjBE,ACkBF,IpBgDI,AYyBH,AUzDG,CCAC,AXyDH,GXzCM,AEpBA,CgB9BE,CAAC,CnBkEA,COwBR,AY1FO,ClBkDG,AG0BT,CJVU,AGpCA,AgB9BC,CnBkED,AsBhCC,CrBgBC,AkBlDN,CGkCO,AH9CA,ChB0CC,EFoBE,CAAC,AEpBA,GFoBG,CAAC,AEpBA,KFoBK,EAAE,AEpBA,CFoBC,AEpBS,CFoBR,AEpBS,CFoBT,AMwCR,EJ5DoB,EAAE,EAAE;AHsClD,ATnDA,AkBEA,AYdA+L,AtBcA,ADAA,AJDA,ADjBApP,AHiBA,A6BjBE,ACkBF,CpBiDC,GuBhCW,AboGX,AE3CO,GnB5FD,CQkDC,AqBhBA,AD9BA,A5BJAsD,C6BkCC,AD9BAnB,EC8BE,CfwDR,AJ5DS,AgB9BC,CAAC,ElBkDC,ARlDf,A0BAa,Ef2EH,Ae3EQ,CGkCA,AD9BlB,A5BJkB,Cc0FR,AexDS,AD9BA8D,AFJN,CImCe,AtBeR,AMwCT,CgBvDkB,AtBeT,AMwCR,EctFZ,GAA0B,CE+BmB,ADDlB,C7BlCC5C,CU8BC,CAAC,CS8DX,CnB5FD,CU8Be,CAAC,AS8DjC,AnB5FiC,EU8BE,EAAE,AkB1BA,GlB0BG,CAAC,CAAA;AHuC1C,ATpDA,AkBEA,AYdE,AtBcF,ADAA,AJDA,ADjBI,AHiBJ,A6B/BiB,ACgCjB,CDhCA,EAgBA,ClBgDI,CAAC,GsBfG,ApBLA,AOyGN,AE3CA,AU1DM,A7BlCE,Cc0FP,AJ5DM,AkB1BA,ClB0BC,CAAA,CoBKE,AboGN,AjBvIQ/C,C8BmCD,AboGN,CWnIO0P,CTwFL,CWzDO,AnBwCZ,CX3EM,COoEK,AUmEH,AYrGM,A7BlCE,CmB4FP,CAAC,AU1DM,CZqGL,CapGO,AF/Bb,CE+Bc,AnBwCZ,CiBvEa4B,CXmIL,CAAC,CN5DL,CJPU,AIOT,CmBxCa,AvBiCJ,AYwBF,CAAC,CSxFf,CE+BuB,CAAC,CAAA,AF/BC1G,GAAzB,CAA6B,EjBuEV,CAAC,KAAK,CAAC,CiBvEa2G,CAAV,EAAa,C5BJzC,CAAN;AFiBJ,AkBEA,AYdI,AtBcJ,ADAA,AJDA,ADjBC,AHiBD,A8BCA,CnBgCC,ARpDD,GmB8FC,CAAC,GWzDM,AhBuDN,AJ5DM,AOyGN,GWnISA,CE+BC,AhBuDN,AG6CA,AYrGM,AD9BA,CdsFL,AG6CA,AN5DH,AiBvES1G,GdsFH,ActFN,GE+Be,AboGN,AYrGM,EfwDJ,AexDM,CCCC,AhBuDN,AG6CA,CAAC,CAAC,CAAC,CapGO,CAAA,AhBuDL,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC,kBJ5DwB;AF/I5E,AVkIA,AkBEA,AYdG,AtBcH,ADAA,AJDA,AJAA,A6BhBA1E,ACiBA,GChBS,CT2FD,CSzFH,EFHE,CIkCC,AhBuDN,AJ5DM,AOyGN,AStIM2C,Cf0EL,AiBzEM,CAAP,CEiCS,ChBuDL,AJ5DM,AOyGN,CH7CC,AJ5DM,AOyGN,CH7CC,AYzFR,EZyFU,AG6CA,AYrGM,CAAC,AHjCA,ETsIJ,AYrGM,CZqGL,CAAC,CAAC,GE1CH,CU3Da,CAAC,CV2D1B,ET/D6B,EAAE,EFmB/B,AqBfiC,IV2DpB,SAAiB;AX1C/B,AVlCA,AkBEA,AYdC,AtBcD,ADAA,AJDA,ADjBApJ,AHiBA,A6BhBE,ACiBF,CClBA,M5BAO,CiBuIL,AE1CA,AnB7FMuD,GAAR,C8BmCY,AhBuDT,AJ5DS,AOyGN,AE1CA,CF0CC,AN7DE,AQmBF,AU3DM,AHjCA,C1BDC,GiBuIH,AE1CA,CX3CI,AW2CH,CW1DO,ApBLA,AgB9BF,CTuIH,CPzGO,AOyGN,CapGO,ApBLD,AOyGL,CAAC,CE1CC,CAAC,CnB7FO,GQkDA,CAAA,EMwCH,OKGU,CAAC,OW1DI,CAAC,CX0DI,CAAC,EAAE,EW1DD,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;AhClBnD,AkBEA,AVAA,ADAA,AJDA,ADlB4B,AHkB5B,A6BhBE,ACiBF,QVqHE,CapGO,ApBLA,AV/B0B,Gc2FhC,AG6CG,AN7DH,AQmBA,AU3DS,A7BnCgB,A0BEhB,CTsIL,EYrGQ,ClBwCR,AQmBA,CW1DU,AboGN,AE1CH,AU3DS,CCCC,ChBuDR,CAAC,AG6CG,ASxIG,CZ2FL,AG6CG,CAAC,AN7DH,CM6DI,AE1CH,CRnBC,AQmBA,CW1DU,IAAI,CAAC,GX0DN,CW1DU,AX0DT,CW1DU,EAAC,AX0DR,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;ArB5ExD,AkBEA,AYdA6L,AtBcA,ADAA,AJDA,ADnBwC,AHmBxC,A6BhBE,ACiBF,C3BpBA,GiByIC,CAAC,GapGM,ApBJA,AkB3BA,CdsFL,AKGA,ASzFMjN,IFHI,EIkCE,ApBJA,CC2CX,AkBxCY,CAAC,CD9BjB,ClB2BmB,AmBGA,AD9BA2P,ClB2BA,CgBjCF,CIqCK,CAAA,AnBuCX,EiBtEX,CC8B0B,ClBwCX,AkBxCY,ClBwCX,AiBtEY,MC8BM,MlBwCN,AiBtEY,CjBsEX,KAAK,CAAC;AbzDnC,AkBEA,AYdE,AtBcF,ADAA,AJDA,AJAA,A6BhBE,ACiBF,IGiBI,ApBJA,AOyGH,CarGI,ApBJA,CAAA,CAAA,CI4DH,AKEA,CSzFO,GduFH,CHjBF,AkBxCS,CD9BC9B,CTyFL,AO5FM,IP4FF,CLFC,AKEA,COhGG,CEOR,CduFQ,CcvFO4B,ETyFJ,CLFC,AKEA,CLFC,GcvFb,GXoIE,AWpIuB1G,ETyFJ,CF2C7B,AE3C8B,ASzFtB,CTyFuB,ASzFM,QduFE,CAAC,AG6C7B,CH7C8B,AcvFM2G,CduFL,AcvFL,CduFM,CAAC,AcvFM,CduFL,GG6ClB,CH7CsB,CAAC,CAAC;AJ3DpD,AZfA,AkBEA,AYdI,AtBcJ,ADAA,AJDA,ADpBA7R,AHoBA,A6BhBE,ACiBF,CjBaC,CAAC,EoBKU,ApBLR,AS8DH,CT9DG,AS8DF,EnBhGK,Cc8FL,AG6CA,AjB3IMwD,C6BwCC,CHpCC,CEGCqO,CduFL,AcvFM,CduFL,AcvFMpN,A5BPb,EiB2IS,CjB3IO,A0BDC,Cf6EP,CiBrEN,GduFW,EAAE,EgBvDgB,CAAC,A9BvCRhB,GAAV,EAAe,C8BuCmB;ApBHlD,AZhBA,AkBEA,AYdG,AtBcH,ADAA,AJDA,ADpBI,AHoBJ,A6BhBE,ACiBF,GChBS,CT2FT,CUrDK,ADpCA,GEgCG,A9BvCE,C4BKD,ClB8BC,AkB9BR,ClB8BS,CoBIC,AhBuDT,AG6CA,AjB3IWnD,A0BIF,CImCC,GAAG,AnBqCZ,AQoBH,CnBhGS,CAAU,Cc8FV,AYhGO,CZgGN,AG6CA,CH7CC,CgBvDU,AboGT,CapGU,AnBqCZ,EDzCc,CAAC,CAAO,ACyClB,CAAC,CmBrCa,ApBJyB,COwGjC,CPxGmC,CoBIxB,CAAC,ApBJyB,CoBIzB,MnBqCL,CAAC,KAAK,CAAC,GX5EzB,CAAN;AmBgGJ,ArB5EA,AkBEA,AYdC,AtBcD,ADAA,AJDA,ADpBC,AHoBD,A6BhBE,ACiBF,CRsCA,AAoCC,AS5FD,A5BLA,GUqCI,AmBSA,CVmDH,GWxDO,ApBJA,CI2DL,CY1FO,CGwCC,CCLC,AboGT,CN/DC,AkBhCS,GZ+FN,EAAE,CapGU,AJ1CF,GI0CK,AboGT,CAAC,GapGY,CAAA,AboGR,EPxGW,GAAG,KAAK,CAAA;ASwBxB,ArBvCb,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BhBE,ACiBF,IjBcI,IoBII,AhBwDN,AJ5DM,AmBSA,ClBgCL,AkBhCM,ECLE,ADKA,CZ+FR,GH5CM,CG4CF,EAAE,AY/FS,CAAC,GnBTG,AOwGT,AEjFK,CLqCD,AG4CH,CH5CI,CJ5DO,CmBSC,CZ+FR,EPxGW,CAAA;AS6D7B,ArB5EA,AkBEA,AYdA8O,AtBcA,ADAA,AJDA,ADrBApP,AHqBA,A6BhBE,ACiBF,Ib0EC,AJ5DG,ACyCH,CGmBC,AHnBA,AkBhCG,E7B7CE,C4BQC,A5BRA0D,CiB4IL,AWpIMvB,CXoIL,EapGQ,AJnCA,ChB+BO,AVpCnB,GmBgGuB,AnBhGP,CmBgGgB,CWxDd,AFhClB,CTwFkC,ASxFfwO,CEgCC,AXwDuB,ISxF3C,GlB4BiC,AkB5BN,C5BRA,E8BwCG,EAAE,OFhCO,EEgCE,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;AhCnB9E,AkBEA,AYdE,AtBcF,ADAA,AJDA,ADtB6B,AHsB7B,A6B1BiB,AC2BjB,CD3BA,GZuGS,AG0CR,AN/DD,AQmBC,AUlDG,CZ8FF,CWpII,ETwFD,CAAC,AnBjG8B,C6B+C1B,A7B/CmB,C4BSlBb,CEgCC,AXwDH,AUlDG,CVkDF,EAAE,CWxDI,EFhCV,KjBqEL,AiBpEK,GE+BoB,EF/BfE,CE+BkB,CAAC,EAAE,IF/B1B,CADA,IAEA,KAAKA,QAAL,EdwFuB,AcxFR3O,GdwFpB,Gc1FC,EAE2B,KdwFC,SAAiB;AHrB/C,AbxDA,AkBEA,AYZI,AtBYJ,ADAA,AJDA,ADvBwC,AHuBxC,A8BCA,ChB5GA,AAkKC,AX9ED,GiB8IA,CNhEC,GGsBC,AKFA,AUlDM,CAAC,ADpCA2O,ECoCE,CfoDL,AJ/DE,CI+DD,EKFE,CWxDO,AhB0DN,AKFA,CAAC,AStFP,ClByBU,AS6DF,AUlDM,CAAC,ADpCAvG,CXkIlB,GapGsB,CpBLH,CI+DD,AepDM,CCNC,AhB0DN,AcxFhB,ClByBmB,AkBzBI,ElByBF,CAAC,CI+DD,CgB1DO,AhB0DN,KcxFWwH,ElByBF,CAAC,AkBzBT,EE8Be,AF9BA,EE8BE,CAAA,CpBLF,CAAC,CAAA,KI+DI,CAAC,0BAA0B,CAAC,CAAC;AG0C5E,ANlOa,Ab2Gb,AkBEA,AYZM,AtBYN,ADAA,AJDA,AJAA,A6BfA,ACgBA,CV4FA,AAyBC,IAAA,AE3CC,GLEA,AepDM,CHxCC/H,EEIE4G,CdwFL,AJ/DE,CI+DD,CAAC,AepDM,ECNE,AhB0DN,AJ/DE,AmBWI,EDpCV,EAAcmB,GE8BG,AF9BA,CAAC9F,CFJxB,CIkC0B,AJlCAxE,CEIpB,EAAuBsK,AFJ7B,EAA+B5H,CEIC,CAAC5E,EE8BE,CnB/HV,CD0HQ,CkBzB3B,EE8BkC,AJlCxC,CIkCyC,ApBLJ,CgB7BK,KhB6BC,KAAK,cAAc,EAAE;AO0GhE,ANzDA,Ab/DA,AkBEA,AYZK,AtBYL,ADAA,AJDA,AJAA,A6BfE,ACgBF,IR0EC,CSxFG,CFFE6E,CEIC,CTsFF,CAAC,ESxFF,AFFO,CZ4FR,AKFM,AUlDG,CVkDF,AUlDG,CHxCC7C,CP0FF,AUlDG,CnBXH,IoBKQ,CAAC,AJlCA,CIkCC,ADMA,AHxCA2C,CGwCC,IlBqCI,Ce7Eb,CIkCe,AJlCAC,CGwCC,GfoDa,CHfC,GDhDX,CgB7BnB,CAAZ,ChB6BkC,KAAK,CAAA;AZdzC,AkBEA,AYZG,AtBYH,ADAA,AJDA,AJAA,A8BCA,IhB6DC,IQaC,CLEC,AepDM,ElBqCD,IAAI,AQaH,CT7DG,AS6DF,CAAC,GWxDS,CAAC,CAAC,CpBLJ,QoBKa,KAAK,AnB2Cb,CmB3Cc,AnB2Cb,OAAO,CAAC,CAAC;AACjC,Ab/DA,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BfE,ACgBF,ChB6DC,EMyDE,EE5CD,AUlDG,CHxCCC,EZ4FJ,GY5FA,EhB6BO,AgB7BI,GZ4FH,CAAC,CAAC,CAAC,CAAC,EAAE,EgB1DQ,CAAC,CAAC,OAAO,GAAG,KAAK;AbqGzC,ANxDA,AbhEA,AkBEA,AYZE,AtBYF,ADAA,AJDA,AJAA,A6BfI,ACgBJ,IR0EC,AUjDG,GDrCG2G,ITsFC,AUjDG,AHzCA,CZ4FR,AJ9DK,AS4DC,AStFP,CTsFQ,AUjDG,GnBXD,AkB1BI,CdwFR,GcxFYpK,ElB0BF,COwGK,AWlIP,AFJOY,CIkCC,CAAC,AF9BvB,CE8BwB,AhB0DT,AHdgB,AiBnFM,CASb,EXkIoB,CStIhB,CTsIkB,AStIjBoC,Ef8EiB,CDhDlB,CoBIK,ApBJJ,AOwGgC,EPxG9B,AgB9BV,ChB8BW,AgB9BIS,EIkCE,ApBJJ,CoBIK,EJlClB,EAAsB,CAAtB,CAAZ,GAAuC,GAAvC,GAA6C3C,GAA7C,GACA,SADA,GACYF,OAAO,CAACoC,MAAR,CAAeS,KAAf,EAAsB,CAAtB,CADZ,GACuC,GAD9C;AP2FJ,ArB5EA,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BdG,ACeH,CR0EC,EO5FC,CTwID,ANxDA,IMwDI,ANxDA,AkBrCG,CZ6FF,ANxDA,Ae7EG,Gf6EA,CkBrCI,CZ6FF,CY7FI,CfmDX,AJ9DQ,ACgDC,CMwDC,IAAI,CAAC,MapGS,CAAC,CAAC,ApBJJ,GAAG,GCgDN,CmB5Cc,AnB4Cb,EGcsB,AJ9DX,CoBIK,ApBJL,ICgDJ,CAAC,CAAC,GmB5CgB;AXgDjD,ArBnEA,AkBEA,AYbE,AtBaF,ADAA,AJDA,AJAA,A6BdI,ACeJ,IVsHC,ANxDM,CAAE,CAAC,CiB3EH0G,CXmIF,CAAC,CNxDQ,Ce7EHrJ,CZ2FR,AenDS,CZ6FF,ANxDO,AkBrCJ,CHxCT,CGwCW,ADtCb,ClB2BU,CI8DJ,EczFW,CjB2EK,CAAC,CkBrCH,CAAC,ADtCA2I,CTsFtB,CLGe,CenDU,ECPE,CAAC,CAAC,AF/BX,CXmIe,CAAC,AWnIjC,CAVqC,CAUN,GE+BI,ApBJJ,CoBII,EpBJD,IAAI,CAAA;AS6DxC,ArB5EA,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BdG,ACeH,IVsHC,ANxDA,IMwDI,CAAC,AY7FG,ElBqCD,CAAC,CmB5CI,AnB4CH,EMwDE,CH1CR,AJ9DQ,EAAE,AOwGC,CPxGA,AOwGC,AE5CU,CF4CT,AE5CoB,CF4CnB,CE5CqB,CAAW,KT5D1B,CAAC,MAAM,EAAE,CI8DY,KJ9DN,CAAC,CAAA;ACiDxC,AbhEA,AkBEA,AYdE,AtBcF,ADAA,AJDA,AJAA,A6BdC,ACeD,ChB8DC,GMwDA,AE5CA,GSxFMI,CXoIF,AE5CA,AUjDG,CCPC,AboGH,AE5CA,GLEH,AG0CM,CPxGA,AkB5BP,CTwFS,CF4CC,CAAC,AY7FG,CCPC,AhB0DT,AG0CM,AWpIG,CEgCC,AboGH,AE5CA,AUjDG,ADvChB,CAXqC,CAWpB,ETwFA,CAAC,CLEL,CgB1DU,GXwDA,CWxDI,CAAC,EXwDD,EWxDK,AXwDH,CWxDI,EAAC;AnBwCpC,Ab3DA,AkBEA,AYdC,AtBcD,ADAA,AJDA,AJAA,A8BCA,CC1BA,GXgJC,IapGO,ApBJJ,AOwGC,AE5CH,CT5DG,AOwGC,GY7FM,CZ6FF,AY7FG,ECPE,AXwDN,AUjDM,CfmDX,AG0CS,AE5CH,CF4CI,AE5CH,CF4CI,CAAC,GapGM,ADOA,CCPA,ADOC,SAAS,KfmDY,OHf3C;AAED,AbhEA,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BbA,ACcA,IGkBI,AboGH,CapGI,ApBLA,AS6DH,GF4CG,CAAC,AY7FG,AHvCA/G,GZ0FN,CG0CO,GAAG,CH1CL,AG0CM,CAAC,CAAC,ANxDU,GAAe,Ce5EzC,CAAwBhC,GAAxB,EAA6B0C,GZ0FN,MY1FvB,EAAwC;A5BaxC,AkBEA,AYdA+F,AtBcA,ADAA,AJDA,AJAA,A6BbE,ACcF,IjBcI,AOyGH,ANzDA,AQYA,ET5DK,CAAC,COyGF,AE7CA,AUjDG,ADvCA,ClB4BC,AS4DH,ASxFGjN,AFAAwE,ChB4BC,AS4DH,CRZO,CQYL,AOxFP,ETqIS,ANzDO,CAAC,CGcf,AenDY,CZ8FF,CY9FI,ADvClB,ClB4BmB,ACgDI,AiB5EJoL,CjB4EK,CDhDH,EOyGD,AWrIpB,CXqIqB,EWrIK,IXqIC,CAAC,IPzGO,CAAC,CAAA,CkB5BE,Md0Fa;AgB3KhC,AnB8JnB,AbhEA,AkBEA,AYdE,AtBcF,ADAA,AJDA,AJAA,A6BbC,ACcD,ChB8DC,GDhDG,AOyGH,EPzGK,CAAC,COyGF,AE7CH,CLEC,AJ9DM,AkB5BA,ClB4BC,COyGF,CY9FI,CAAC,CZ8FF,AWrIG/B,CTwFL,AUjDM,CViDL,CAAC,CAAC,EF6CK,CAAC,CY9FI,ADvCb,CCuCc,CnBXQ,AOyGV,AWrIG9E,CXqIF,CPzGW,AmBWP,CnBXQ,AkB5BzB,CAAmB,GlB4BU,EoB9GE,ApB8GA,GoB9G6B,EFkF/B+F,ClB4BiB,CoB9GkB,CpB8GhB,AkB5B7B,EElFgD,ApB8GjB,AkB5BhB,EElFmC,CAAA;AAC3D,AnB2JnB,Ab7DA,AkBEA,AYdI,AtBcJ,ADAA,AJDA,AJAA,A8BCA,IVuHC,CE7CC,GLEA,AJ9DM,AOyGH,AWrIG,CCuCC,ADvCAO,EXqID,CPzGI,EI8DJ,AG2CG,EWrIK,CAAC,Cd0FL,AJ9DM,EOyGD,CAAC,AWrIF,Ed0FC,AJ9DM,AkB5BAP,Cd0FL,AG2CG,CAAC,CWrIN,CAAZ,ElB4ByB,AkB5BA,CjB2E5B,GD/CgC,CoB9GQ,GAAmC,EpB8GrC,EoB9GyC,GAAG,ApB8GvC,EoB9GyC,CAAA,IpB8GlC,EAAE,cI8DQ,CAAC,CAAC;AgB3K5C,AnB8JnB,AbhEA,AkBEA,AYdM,AtBcN,ADAA,AJDA,AJAA,A6BZA,ACaA,Ib4EC,AG2CA,AE7CA,CLEC,GG2CG,AE7CA,AUjDG,CViDF,AOvFG1H,CPuFF,ET5DK,AOyGH,AE7CA,AUjDG,CDvCC,CCuCC,CZ8FF,KSpIZ,CToIkB,ASpIGrH,CToIF,IPzGO,AOyGH,ASpIvB,CToIwB,CPzGI,AgB3BA,ChB2BA,IoB9GY,GAAwB,IAAI,GAAG,EAAE,CAAA;AACtD,AhC8FnB,AkBEA,AYdQ2P,AtBcR,ADAA,AJDA,AJAA,A6BZE,ACaF,IbUgB,AG6Gf,ANlDA,EelFKrI,EToID,AE7CH,ASxFMqI,ClB4BC,AkB5BA,CFCC,CEDCZ,CXqIF,AY9FG,CAAC,AHtCA,CEDC,CXqIF,AE7CH,AUjDM,ADvCA9F,AFCb,CPuFQ,CAAC,CSzFE,GXsIK,CAAC,AY9FG,CAAC,GZ8FA,CAAC,AY9FG,MCzHa,GAAwB,IAAI,GAAG,EAAE,CAAA,AhB0GrC,GAAG,IAAI,aAAa,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;AgBMhE,AhCjBT,AkBEA,AYdQ6G,AtBcR,ADAA,AJDA,AJAA,A6BXE9P,ACYF,EDZEA,EZqEc,AJ3CZ,AO0GH,CP1GI,AS4DH,CT5DI,CAAA,AgB1BC,CfiFL,AiBnFM8P,AFEAvI,CGqCC,ADvCA,EAAEwH,CjBmFL,CAAC,CiBnFO,CAACxM,AFEb,CAAc,GfiFH,CiBrFA,EjBqFG,EAAE,CAAC,CejFMiF,GAAT,EAAcC,GI2BV,AJ3BJ,EAAmB,UToIQ,MH/DD,GAAG,2CAA2C,CAAC;AhB1DzF,AkBEA,AYdQlJ,AtBcR,ADAA,AJDA,AJAA,A6BXI+I,ACYJ,Ib0EA,AJ3DI,AOyGH,AE9CA,AOtFGA,IToIC,ANnDH,AQKG,AUjDG,ADvCA/I,AFEA,CEFC,AFEAiJ,EEFEuH,CjBmFL,AQKG,AOtFD,CfiFD,AejFH,CToIe,AWtIL,CXsIM,AE9CR,ASxFGgB,CTwFF,AUjDG,AHrCA,CPsFF,CT3DI,AmBUA,ADvCP,ElB6BS,AgB3BhB,ChB2BgB,CkB7BEhB,CTwFF,CRLF,AQKG,CSxFI,CAACT,CjBmFL,KGKpB,AHLyB,AiBnFJ,CjBmFK,GiBnFS,CAAzB;AlB8BX,AZjBA,AkBEA,AYlBa,AtBkBb,ADAA,AJDA,AJAA,A6BXG,ACYH,Cb1DA,AAmIC,AJ1DA,CAAA,CAAC,AgB7BA,ChB6BA,AOyGD,AE9CA,CLDA,EG+CG,AW1IE,CjBuFJ,AQKG,IRLC,AQKG,AUjDG,ClB4CL,AkB5CM,EViDD,AUjDG,CViDF,CAAC,GRLA,EkB5CQ,ClB4CL,AQKG,AUjDG,CViDF,GRLA,CAAC,IkB5CU;AfkDhC,AhB5EA,AkBEA,AYdK,AtBcL,ADAA,AJDA,AJAA,A6BVE,ACWF,IR0EC,IF8CC,ANnDA,AQKG,COrFIhH,GTmIH,ANnDA,AQKG,AUjDG,ClB4CL,AehFL,ETmIO,EE9CK,EF8CD,CY/FO,CViDF,CF8CF,AY/FM,CViDF,CF8CF,GNnDG,GAAG,IAAI,CAAC;AbtE7B,AkBEA,AYdG,AtBcH,ADAA,AJDA,AJAA,A6BVC,ACWD,GCtBS,Cd2GR,CcnGI,GjBmFH,AQKA,CShGO,EAQEoI,CXsIR,ANnDG,CAAC,AQKA,GUjDS,CViDL,AUjDM,CViDL,AShGH,CX8IC,AY/FS,Ef4DN,AKXE,ASxFMM,CTwFL,EF8CD,AE9CG,CF8CF,ANnDG,AQKA,CF8CF,AY/FS,CAAC,AD/ClB,Cd2GwB,AHhBX,AQKA,ASxFM,EdmGO,EKXT,CF8CF,CE9CI,CAAC,AUjDM,EViDJ,CSxFOC,CTwFL,ASxFL,EAAa,IdmGiB,EAAE,iBAAwC,EAAE,UAAyB,EAAE,iBAAsD;AhBtFvL,AkBEA,AYdI,AtBcJ,ADAA,AJDA,AJAA,A8BCA,QbqFE,CGmCC,EWtIQA,CdmGL,AHhBH,AQKA,ASxFC,CdmGG,Ae5DM,GViDN,CRLC,EAAE,AQKA,GAAG,CRLC,KQKK,CAAC,CAAC,CAAC,CAAC,CAAC,ELWK,AKXH,CAAC,CAAC,CLWI,AKXH,CAAC,CAAC,CAAC,CLWI,qBAAqB,CAAC,eAAe,EAAE,iBAAiB,EAAE,iBAAiB,CAAC,CAAC;AhBtFjH,AkBEA,AYdG,AtBcH,ADAA,AJDA,AJAA,A6BTA,ACUA,GCxBS,CAAP,Id8GA,AGmCA,CYhGO,AHnCAhJ,GZgGH,AHjBH,AQKA,CLYI,CGmCC,EE/CD,CF+CI,ANpDH,EAAE,AQKA,CLYI,AYhGd,CAAqBX,EZgGJ,AGmCA,ANpDH,CGiBI,AGmCA,AE/CH,AOpFf,CZgGmB,AKZH,CLYI,AYhGM/D,CPoFR,IOpFlB,EAAiCmF,CTmIL,CAAC,GAAG,CAAC,CAAC,KSnIlC,EAA+C;A5BS/C,AkBEA,AYdC,AtBcD,ADAA,AJDA,AJAA,A6BTE,ACUF,CC1BA,ICmDK,Gf6DH,AGmCA,IHnCI,AGmCA,ANpDH,CGiBI,GKZH,CRLI,CMoDI,CNpDF,IAAI,AQKH,CLYO,EKZJ,CLYO,AKZN,CLYO,CAAC,QGmCM,IAAI,MAAM,2BAA0B,IAAI,MAAM,6BAA2B,EAAE;AnB1HxG,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BTE,ACUF,IE0BI,If4DF,IAAI,AGmCH,ANpDA,AkB3CS,Cf4DL,AKZH,CUhDU,GlB2CN,EAAE,IAAI,EGiBK,GAAG,EAAE,CAAC,EGmCD;AnB1HxB,AkBEA,AYdAwF,AtBcA,ADAA,AJDA,AJAA,A6BTE,ACUF,MDVM5G,EZgGJ,Ae5DM,ADxCA,CjBmFL,AQKA,AUhDM,ADxCArG,AFIA,Cf+EL,Ae/EM8G,CGoCC,Cf4DL,AGmCH,CHnCI,EGmCD,EAAE,CAAC,AY/FS,ADxClB,CCwCmB,ADxCAmJ,GCwCG,CHpChB,GEJN,CFKM3N,EELuB,CdoGL,EYhGlB,CZgGqB,EAAE,CAAC,AY9FxBoF,KENmC,KFMzB,CAACpF,KAAK,CAACgC,OAAP,CAFV,IAGA;A5BMN,AkBEA,AYdE,AtBcF,ADAA,AJDA,AJAA,A6BNMhC,ACON,EDPMA,Ef4EL,CAAC,Ee5ES,CZ6FT,AKZA,AUhDM,AHjCIgC,CEPH,GdoGH,AGkCI,CHlCH,CcpGOuJ,CTwFL,AOjFH,CT+HQ,AE9CJ,AUhDM,CVgDL,CF8CK,AY9FE,CZ8FD,CS/HO9P,EEPf,CAAP,IFO6B,CAACuG,GZ6FP,GAAG,CYjGtB,IAKA,YZ4FuC,CAAC;AhBvF9C,AkBEA,AYdC,AtBcD,ADAA,AJDA,AJAA,A6BLM,ACMN,CChBA,GjBsFQ,Ae5EAhC,CPgFN,GLYA,CY5FW,CAACqF,EZ4FR,AGkCH,AY9FS,Cf4DL,QAAQ,AGkCH,AS9HJ,GZ4FU,CY5FWrF,IGgCA,CHhCK,CAACqF,IZ4FN,AHhBjB,CGgBkB,EHhB7B,Ie5E4B,CZ4FQ,AY5FU3H,EZ4FR,GHhB1B,CGgB8B,CAAC,CAAC,CHhBd,Ae5EF,KAAgCsC,KAAvD,CANJ,EAMmE;A5BKrE,AkBEA,AYbA,AtBaA,ADAA,AJDA,AJAA,A6BLI,ACMJ,IR0EC,ILaC,AHjBA,Ae5EMsF,CT8HL,EE9CK,AOhFG,CZ6FL,AHjBA,AkB5CM,Cf6DL,AHjBA,AkB5CM,CHhCCtF,CPgFF,AUhDG,GVgDA,CRJF,Ae5EM,Cf4EL,Ae5EMgC,EPgFD,AUhDG,CVgDF,AUhDG,ClB4CL,CAAC,Ee5EL,CAAcmD,Cf4EL,CAAC,CGiBC,AHjBA,CkB5CO,Ef6DJ,EAAE,CAAC,GY7FjB,EAA4BpB,GAA5B,CAAV;APiFJ,ArB5EA,AkBEA,AVAA,ADAA,AJDA,AJAA,A8BCA,CR0EC,OLaC,AGkCA,ANnDA,CkB5CO,Gf6DH,AGkCA,ANnDA,CAAC,KMmDK,IHlCI,EAAE,AHjBA,GAAG,IAAI,CAAC,SMmDO,EAAE,ANnDE,IAAI,IAAI,CAAC,SAAS,CAAC;AQlBxD,ArBrDA,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BNI,ACOJ,IhBsEC,CAAC,GkB5CM,AHjCA,CAACjC,GZ8FN,AGkCA,CY/FU,EAAE,Ef6DW,AY9FT,CAACwD,GAAD,CTgIJ,AShIT,EAAoB,GZ8FyB,EAAvB,CKdzB,ILcyB,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAvB,cAAuB,EAAvB,IAAuB,EAAE;AKZnD,ArB5EA,AkBEA,AYfAqF,AtBeA,ADAA,AJDA,AJAA,A6BNMrF,ACON,IhBuEQ,Ee9EFA,EERE,CAAC5H,AFQA,GTgIN,AY/FS,AHjCAgH,GTgIN,CHnCE,CGmCA,CAAC,AY/FS,ADzClB,CAAmB1C,CdqGL,Ae5DM,GHjCG,CAAC+B,EERxB,CFQuB,CZ6FD,CcrGO,AFQAuB,GAAN,EAAWH,GZ6FZ,CHfP,CiBtFwBkB,CAAV,CjBsF5B,CiBtFyCvC,IAAb,AFQN,CAAjB,CER0C,GjBsFhC,IAAkB;AbxElC,AkBEA,AYfE,AtBeF,ADAA,AJDA,AJAA,A6BNK,ACOL,IRkFC,ESjGK5B,EjBsFJ,CiBtFO,GXuIC,ANjDJ,AiBtFM,CjBsFL,GGeH,AGkCU,AY9FE,CAAC,CZ8FD,CAAC,ANjDJ,AkB7CM,Cf4DT,AHfI,IiBtFZ,ECyCwB,ClB6CL,AkB7CM,Cf4DT,AHfI,GGeD,CHfK,CAAC,CAAC,AQWf,CUxDsB,SVwDJ,EAAE,SLIE,CAAC,EKJmB,EAAE,ILIb,EAAE,GKJ4B,EAAE,MLInB,CAAC,CAAC,EKJmC,EAAE,UAAkB;ArBnFlH,AkBEA,AYfE,AtBeF,ADAA,AJDA,AJAA,A8BCA,MCfM0L,EjBsFJ,AQWA,IFqCgB,ANhDZ,AQWA,ASjGM,CjBsFL,AQWA,ESjGQ,CdqGX,AGiCkB,AY7FN,GZ6FS,CAAC,AWtIxB,CdqGwB,AGiCC,EErCV,CRXC,AkB7CM,EVwDJ,AUxDM,ClB6CL,IGea,AHfT,CAAC,CGeA,GKJI,CAAC,MRXM,IAAI,IAAI,CAAC,EGeZ,EAAR,KHf6B,CAAC,gBGetB,EAAR,IAAQ,EAAE;AhBvFpC,AkBEA,AYdE,AtBcF,ADAA,AJDA,AJAA,A6BPI,ACQJ,IhBuEC,CAAC,CiBrFIC,ETgGJ,AShGM,GAAG,AFMAvI,CT+HR,AErCG,CAAC,CO1FH,EENY6F,IdmGP,Ae3DW,CZ6FR,AY7FS,EAAE,Cf2DR,CKHI,EShGR,CTgGW,AShGpB,ECwC4B,Cf2DR,Ae3DS,QAAQ,CVwDL,CAAC,OLGb;AhBtFtB,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BPG,ACQH,GDvB+C,Cf+FvC,Ae9EN,IPwFA,CFqCC,GErCG,CAAC,IUxDU,Gf2DZ,EKHW,ELGP,CAAC,AKHS,SAAS,CAAC,ERVf,GAAb,GGa2B,CAAC,IAAI,CAAC;AhBtFlC,AkBEA,AYfE,AtBeF,ADAA,AJDA,AJAA,A8BCA,MCfM0C,EXuIJ,ANhDA,AQUA,ASjGA,EAAQ,ETiGJ,CAAC,AUxDM,ElB8CJ,IAAI,CAAC,GQUG,CLGX,CGmCa,CNhDC,AQUA,CRVC,IGaR,EAAE,AHbY,CAAC,EQUE,CAAC,GLGT,CAAC,OAAO;AhBtF9B,AkBEA,AYfI3L,AtBeJ,ADAA,AJDA,AJAA,A8BCA,IhBwEC,AiBvFGA,CjBuFF,EiBvFK,CXuIL,AEtCA,GSjGS,CTiGL,AUxDM,CVwDL,CFsCC,MY9FY,EAAE,CVwDL,CLGX,EKHc,ELGV,EAAE,GcpGR,GTiG0B,CAAC,GLGT,CAAC,QAAQ,CAAC;AhBtFhC,AkBEA,AYfI0L,AtBeJ,ADAA,AJDA,AJAA,A6BPE,ACQF,IhByEQ,AQSP,ASjGGA,CXuIF,AEtCA,CO1FIrI,IEPI,GXuIA,AWvIG,EFOE,CGkCC,CZ8FF,AY9FG,ADzCb,CFOcC,CTgIF,AY9FG,Ef2Db,CAAC,CAAC,Ge3DkB,CAAC,MHlCM,CAACzB,CGkCC,EHlCF,EAAM/D,CfiFtB,GAAhB,CejFgC,CAA/B,QfiFgB,KAAa,EAAE,SAAiB;Ab1ElD,AkBEA,AYfG,AtBeH,ADAA,AJDA,AJAA,A8BCA,IVyHC,AEtCO,IFsCH,ANhDH,CMgDI,GNhDA,CkB/CO,EZ+FD,CNhDF,CGYL,AHZM,CMgDI,GAAG,CAAC,CNhDF,CAAC,KAAK,CAAC,CAAC,MAAM,GQUlB,ERVuB,CQUnC,QRV4C,EAAE;Ab1E/C,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BRE,ACSF,IVyHC,ESlIKuF,ETkID,AEtCH,CFsCI,AY/FG,GlB+CN,CGYC,AGoCM,EEtCD,AO5FP,CTkIW,CSlII,EP4FJ,CFsCI,CAAC,QNhDE,UQUa,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;ArBpFxH,AkBEA,AYfE,AtBeF,ADAA,AJDA,AJAA,A6BRI,ACSJ,IVyHC,AEtCA,CAAC,CSlGIoG,EXwID,AY/FG,Cf2DL,AGoCG,AWxIG,EFMEpG,CfkFR,AiBxFS,CXwIF,GAAG,ANhDN,CAAC,AkB/CS,ADzCAyF,ECyCE,CZ+FF,AWxIL,AFMR,CTkIc,AWxIhB,GjBwFa,GAAG,IAAI,CAAC;Ab1EvB,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BRG,ACSH,GD9B+C,CZmH9C,AGqCA,AEtCc,AO3Fb,CZ4FA,GGqCG,INjDF,AkB/CS,CAAC,CZgGF,CYhGI,ClB+CR,CAAC,KkB/Cc,CAAC,GAAG,GlB+CN,CAAC,GQWE,ERXG,CQWzB,ERX4B,IMiDQ,ANjDJ,CAAC,CMiDK,EEtCf,GAA0B;ArBrFlD,AkBEA,AYhBE,AtBgBF,ADAA,AJDA,AJAA,A8BCA,IbsFQ,EctGFW,EX0IJ,AEtCA,CU1DO,AD1CA,GjByFN,AQWG,CAAC,ASpGMA,GjByFN,AQW2B,ASpGlB,CjByFR,CQW4B,CAAC,ESpGhBC,QjByFD,AiBzFlB,CjByFmB,CiBzFU,IjByFL,GGaF,AHbK,GGa5B,CGoCmC,ANjDH,CAAC;Ab1ElC,AkBEA,AYhBI,AtBgBJ,ADAA,AJDA,AJAA,A8BCA,KE0BK,Gf4DH,AGoCA,AEtCA,ASpGMgC,IdsGF,AGoCA,ANjDH,CGaI,AGoCA,AEtCA,CSpGH,EjByFG,AiBzFS,CX0IL,ANjDH,AQWG,CAAC,GAAG,CAAC,EAAE,GAAG,ERXD,CAAC,AQWG,GAAG,CFsCO,AEtCN,CLEC,AGoCM,ANjDT,CGaI,EHbD,EQWK,ERXD,AQWG,CRXF,AQWG,GAAG,GAAG,EAAE,CLEC,AKFA,ELEE,AKFA,CLEC,CKFC;ArBrFlD,AkBEA,AYhBM1L,AtBgBN,ADAA,AJDA,AJAA,A6BRE,ACSF,CE0BC,CAAA,Ef4DA,CAAC,CctGIA,AFOAV,EToIJ,CW3IO,CFOC,CToIL,CNlDF,AQWA,CFuCI,AEvCH,ASpGS,AFOAnB,CToIL,AEvCH,CAAC,CRXC,AQWA,ASpGD,CjByFE,EQWE,AO7FS,CAACmB,EP6FP,CAAC,CAAC,AO7FF,CP6FG,AO7FSxB,CP6FR,GRXG,CAAC,AelFR,CP6FS,AO7FpB,EP6FsB,CAAC,CRXC,GAAG,IAAI,CAAC;AkB7ClC,A/B7BA,AkBEA,AYhBK,AtBgBL,ADAA,AJDA,AJAA,A6BRE,ACSF,IbuFQ,EYhGFyF,ETmIG,CEtCN,AUzDM,GZ+FI,ANjDV,CkB9CU,CZ+FE,AY/FD,CZ+FE,CNjDT,CAAC,AelFS,GAAGX,GfkFN,CAAC,GkB9CsB,ElB8CjB,AkB9CmB,ClB8ClB,CAAC,AelFS,CAACtD,CGoCW,GAAG,AHpCf,CAA7B,GfkF6B,CGcJ,AHdK,CkB9CoB,Ef4DnD,MHdwC,CAAC,CAAC,EGcf,KAAa;AhBxFzC,AkBEA,AVAA,ADAA,AJDA,AJAA,A8BCA,IE2BI,If4DF,AGoCA,AEvCA,CRXC,CkB9CO,CZgGL,IHpCI,AKHA,AUzDM,CVyDL,CAAC,CUzDO,Cf4DL,CAAC,We5DiB,CAAC,KAAK,EAAE,CAAA,Ef4DH,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;AhBxFhE,AkBEA,AYjBIU,AtBiBJ,ADAA,AJDA,AJAA,A6BRE,ACSF,IbuFC,AHdA,AQWA,AUzDG,AD5CAA,CdwGF,AHdA,AQWA,CO7FI6B,CERC,EFQE,CGoCC,AHpCAO,CERC,CX4IR,EYhGW,EZgGP,CYhGU,EZgGP,CSpIR,CGoCmB,CAAC,AHpCA,CToIR,EW5IWsG,CX4IR,CYhGU,CZgGR,AYhGS,CAAA,AD5CC,CAAC5I,OAAL,CAAa2J,GAAb,EAAkB7H,IAAlB,CAArB;A9BgBJ,AkBEA,AYjBI8J,AtBiBJ,ADAA,AJDA,AJAA,A6BRIpM,ACSJ,IbwFQ,AHdA,AQWA,AU1DJ,AD5CAoM,AFQApM,IGoCI,AHpCA,EERE,CFQCnB,CGoCC,CD5CC,CC4CC,EZgGV,CW5IA,AFQa,CAACqF,KToIP,KAAK,CAAC,CAAC,KHnCG,EGmCI,ASpId,CZiGV,AHdc,AenFuB1F,GfmFrC,EenFU,CAAP,MP8FmB,CRXP,EQWf,KRXqC,EAAE,GQWhB,GRX+B,EAAE,KQWf,CRX8B,CQW5B,SAAiB,EAAE,UAAkB,EAAE,UAAkB;ArBtFrG,AkBEA,AYjBG,AtBiBH,ADAA,AJDA,AJAA,A6BRG,ACSH,GDtC+C,CA+B7C,IZ8FD,AHbC,AQWA,AU1DM,IlB+CF,AQWA,CFsCF,ANjDG,EkB/CQ,CV0DL,CRXC,AQWA,CRXC,CkB/CO,CAAC,Kf4FlB,EKlCmB,ERXE,CQWC,CRXC,EkB/CQ,EAAE,IAAI,CV0DL,AU1DM,EV0DJ,EU1DQ,IAAI,CAAC,CAAC,IAAI,IAAI,CAAA;A/B5B1D,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BNE,ACOF,KE2BK,Gf4DH,IAAI,AGqCH,ANlDA,AQWA,CLEI,GHbA,CGaI,AHbH,CGaI,AGqCH,CEvCC,CAAC,CFuCC,ANlDA,CAAC,CQWC,CAAC,GFuCG,CAAC,CHrCI,AHbH,EGaK,AHbH,OMkDO,CAAC,GAAG,CAAC,CAAC,EEvCE,CAAC,CAAC;ArBtFvC,AkBEA,AYjBE,AtBiBF,ADAA,AJDA,AJAA,A8BCA,IE2BI,ED5CE+L,GTsGH,EU1DQ,Cf4DR,AGqCA,AW7IS,GX6IN,AYjGS,AD5CA,CdwGR,AHbH,AkB/CW,Cf4DP,AGqCA,CAAC,ENlDD,AiB3FYX,OjB2FL,AiB3FA,CdwGI,AcxGjB,EjB2FgB,CGaI,EAAE,CAAC,AHbH,CAAC,MAAM,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,MAAM,EAAR,CAAQ,CAAC,CAAC;AkB9CjD,A/B7BA,AkBEA,AVAA,ADAA,AJDA,AJAA,A8BCA,CE2BC,Wf4DE,AGoCO,CEvCD,GFuCK,ANjDV,EMiDY,CAAC,CNjDT,CAAC,OAAO,GAAG,uBGa0B;Ae1D7C,A/B9BA,AkBEA,AYlBE,AtBkBF,ADAA,AJDA,AJAA,A6BRE,ACSF,ME4BM,AD9CAW,AFSApG,KGqCK,Cf2DR,AGqCA,AExCA,AStGD,CFSW,CGqCC,AD9CA,AFSA3F,EZgGP,AGqCA,AExCA,CAAC,CUxDU,CAAA,AHrCL,CfmFR,AenFC,ETqIO,GSpIHwB,EfkFE,AQUM,ELGE,AHbN,AelFA,CP4FO,AO5FNoE,EZ+FQ,IAAI,CAAC,AY/FlB,CAAa,EP4FQ,CAAC,ILGI,AGqCF,CHrCG,AHbN,CMkDK,ANlDJ,AelFtB,KAA2B,CAA3B,CfkF6B,CAAC,CGaO,CAAC,AY/FNpE,IAAI,CAACoE,OAAL,CAAa,aAAb,KAA+B,CADnE,CAAJ,EAC2E;AGqC7E,A/B9BA,AkBEA,AYlBI,AtBkBJ,ADAA,AJDA,AJAA,A6BPI,ACQJ,ME4BM,ED9CEgI,CTsGL,EUxDQ,AHpCA/H,CZ+FR,Ee3DW,AD9CV,EdyGG,AGqCH,AW9IY,EC8CE,ElB8Cb,CkB9CgB,CAAkB,AHpCjB,CAAC7F,CGoCkB,ClB8C/B,EAAE,AkB9CgC,CHpCtB,CZ+FF,Ae3D0B,AHpC1C,EZ+FkB,AHbN,CAAC,CMkDI,AYhG6B,EAAE,CAAC,CAAA,ClB8C9B,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,MAAM,EAAR,CAAQ,CAAC;AkB7C1C,A/B9BA,AkBEA,AYlBMkC,AtBkBN,ADAA,AJDA,AJAA,A6BPG,ACQH,GD5C+C,CAsC7C,EEZIA,ETsGJ,CUxDc,AD9CP,IAAI,GdyGT,AGqCA,AW9IE,GX8IC,CNlDF,CGaI,AGqCA,CAAC,GHrCG,Ae3DmB,CAAC,KAAa,ClB8C7B,EAAE,CGaI,IAAI,EHbD,WGac,EAAE,gDKHsD;ArBrFhG,AkBEA,AYlBK,AtBkBL,ADAA,AJDA,AJAA,A8BCA,IE4BI,IVwDF,AUxDM,CAAC,GVwDH,EUxDQ,CAAC,CZ+FJ,CNjDN,CAAC,AkB9CY,CAAC,Cf2Dd,AGoCU,CEvCA,CFuCE,CAAC,CY/FM,CAAC,EAAE,Uf2DL,CAAC,GKHa,CLGT,CAAC,AKHU,WLGC,EAAE,UAAU,EAAE,aAAa,CAAC,UAAU,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;AhBxFrG,AkBEA,AVAA,ADAA,AJDA,AJAA,A8BCA,QE4BQ,IVwDL,CRVC,AkB9CS,CAAC,EZ+FV,AEvCG,CLGF,AKHG,AUxDS,CAAC,KAAK,EZ+FV,AY/FY,CVwDR,GAAG,AUxDS,CAAC,KAAK,CAAC,EVwDP,CAAC,EUxDW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;A/B7BlD,AkBEA,AYnBIA,AtBmBJ,ADAA,AJDA,AJAA,A6BPE,ACQF,ICnBIA,CC+CC,CHpCCV,CEXC,ETuGJ,CO5FO,CEXC,AFWA5E,CfkFR,CGaC,AGoCA,ISnIE,EfkFI,GelFY,CfkFR,AelFZ,CfkFa,CelFU,GEXGgO,GjB6FN,CAAC,AiB7FS,CAAC5I,OAAL,CAAa+J,MAAb,EAAqBjI,IAArB,CAAxB;A9BkBJ,AkBEA,AYnBI8J,AtBmBJ,ADAA,AJDA,AJAA,A6BPI,ACQJ,IE4BI,AD/CAA,ITuGF,AO5FMxI,CfkFL,CiB7FO,CC+CC,Cf4DR,AGoCA,AExCG,CSvGO,GX+IN,AYhGS,CAAC,AD/Cb,CFWc,CAACpF,CGoCC,CAAC,CZgGR,AExCG,EO5FE,CAAd,CGoCsB,CVwDL,AUxDM,AHpCA,CP4FL,AUxDK,EVwDH,oBFwCe,EAAE,mBHpCqB;Ae3D9D,A/B9BA,AkBEA,AYnBG,AtBmBH,ADAA,AJDA,AJAA,A6BPM,ACQN,CE4BC,SHpCSpB,EZgGP,AKJA,CRXM,CejFK,EZgGP,AGoCH,AExCG,CAAC,AO5FSoB,GZgGN,CAAC,CYhGU,CAACpB,IP4FL,AO5FD,GP4FI,AO5FS,MToIN,CSpIaoB,EZgGP,CKJC,CLIC,AKJA,CO5FU,CAACpB,IAA1B,GAAiC,EAA5C;AG+BN,A/BxBA,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BPM,ACQN,SRoFG,GRXA,CejFUmF,GZgGT,AGoCA,ANnDG,AejFS,CfiFR,AejFSE,GZgGT,EGoCE,ESpIG,CAAY,IfiFL,GAAG,OGeI,AYhGYrF,GZgGT,CYhGL,CGmCxB,Ef6DiC,AYhGY,CZgGX,EYhGtB,EAAsC,SAAtC,CAAP,IZgG+C,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;AhBzF1F,AkBEA,AYnBE,AtBmBF,ADAA,AJDA,AJAA,A6BPK,ACQL,MCnBMiN,ETuGJ,ASvGM,GAAG,CTuGL,CFwCF,GHpCA,AHfA,AiB5FYX,Id2GR,CHfC,CQWO,CRXL,IAAI,AQWM,CRXL,AQWM,EAAE,GSvGb,CAAT,Kd2GyB,CHfC,CGeC,AHfA,KAAK,IAAI,CAAC,MAAM,KAAK,KAAK,IAAI,MAAM,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;Ab1E1H,AkBEA,AVAA,ADAA,AJDA,AJAA,A8BCA,SV4HG,GExCA,IRXC,AQWG,CFwCI,AExCH,GLIH,CGoCU,ANnDN,EMmDQ,ANnDN,IAAI,AQWG,CRXF,EQWK,SLIG,CAAC,AHfG,AQWG,CRXF,AQWG,KRXE,CGeF,CAAC,EHfK,CAAC,MAAM,CGeZ,IHfiB,KAAK,IAAI,KGeR,CHfc,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;Ab1EzH,AkBEA,AYpBE,AtBoBF,ADAA,AJDA,AJAA,A6BRI,ACSJ,MCpBMW,EXiJJ,AWjJM,AFWA/F,CP6FL,GFyCG,AWjJM+F,CXiJL,CWjJO,EjB6FV,AelFY,CAAC7L,CTsIL,CWjJOyL,EXiJJ,ANpDN,CelFO,CfkFL,AelFP,CZiGE,CYjGmB,ETsIJ,ANpDN,CGeL,AGqCY,ANpDN,EiB7Fd,EAA8B,KXiJD,CAAC,ENpDJ,CAAC,CMoDO,CAAC,CHrCX,EHfQ,CGeL,EGqCc,CNpDL,CAAC,CGeN,AGqCa,CHrCZ,AGqCa,EAAE,ENpDJ,CMoDO,GAAG,CAAC,ANpDN,CMoDO,CAAC,ENpDJ,IAAI,CGeN,AGqCa,CHrCZ,AGqCa,INpDF,KAAK,KAAK,CAAC,CAAC,CAAC,CGeN,CAAC,CAAC,CHfQ,CMoDO,ANpDN,EMoDQ,UAAC,CAAC,EAAE,ANpDG,CAAC,CMoDF,KNpDQ,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;Ab1EzH,AkBEA,AYpBI,AtBoBJ,ADAA,AJDA,AJAA,A6BRM,ACSN,IRoFC,CAAC,GSxGMmC,IXiJL,CStIU7J,CEXT,EjB6FA,AiB7FY,AFWA,CAACE,ETsID,ENpDP,EAAE,CGeL,AYjGO,CTsIU,AStIEN,CTsID,CNpDT,CGeL,AHfM,GelFe,CAACjG,OTsIK,CAAC,ANpDV,CAAC,AelFJ,CAAiBqI,EZiGhB,EAAE,AHfM,EMoDY,CAAC,CNpDT,AelFb,CTsIwB,ANpDV,AelFY3J,ETsIA,EAAE,AStI5B,CTsI6B,AStIE4D,CTsID,ANpDV,CMoDW,GStI/B,CfkFyB,AelFrC,EAAmD,EfkFV,IAAI,EelF7C,CAAP,GfkF0D,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;Ab1ExH,AkBEA,AYpBMkC,AtBoBN,ADAA,AJDA,AJAA,A6BRK,ACSL,IRoFA,ESxGMA,EXiJJ,CAAC,AWjJM,CXiJL,CAAC,ENpDD,AiB7FS,CjB6FR,EiB7FC,EXiJM,CAAC,QAAQ,CHrCd,CGqCgB,EEzCtB,CLIU,OGqCa,CHrCL,AGqCM,EAAE,CHrCL,CGqCO,eHrCS,CAAC,iBAAiB,CAAC;AKJzD,ArBrFA,AkBEA,AYpBK,AtBoBL,ADAA,AJDA,AJAA,A8BCA,CRqCA,AA8CC,IAAA,OF0CE,ANpDA,IAAI,IMoDI,EAAE,ANpDA,EMoDE,ANpDA,IGeR,IAAI,QAAQ,EAAE;AKnDR,ArBtCb,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BTI,ACUJ,QDVQ8D,MAAM,CAAChG,CTuIX,ANpDA,IAAI,AenFM,CTuIL,ASvIL,EAAmB,CTuIX,CAAC,CAAC,ANpDA,EAAE,IGeR,CGqCa,GAAG,CAAC,YHrCA,CAAC,EKpDO,GLoDH,CAAC,WAAW,EAAE,QAAQ,EAAE,gBAAgB,EAAE,KAAI,EAAE,gBAAgB,CAAC,CAAC;AKAhG,ArBzFA,AkBEA,AYrBIkC,AtBqBJ,ADAA,AJDA,AJAA,A6BTM,ACUN,ICrBIA,GAAG,IAAI,EFWE6B,GTuIT,ASvIY,CAACE,GfmFZ,CMoDI,GSvII,CTuIA,ASvIYgC,CTuIX,CAAC,ANpDH,CiB9FgB2E,Cd6GpB,AYlGqB,CAAClN,CfmFd,CAAC,AiB9Fe,CAACsE,CXkJX,IAAI,CAAC,ASvIF,CEXG,AFWY+D,CEXC,GjB8FZ,CAAC,CiB9FgBkF,EFWrB,CAAwB7O,CfmFd,CAAC,CiB9FK,CAAb,AFWH,CAA6B4D,CEXC8D,IAA3B,AFWH,CEXrB,AFWS,EAAiD,MAAjD,CAAP;A5BSN,AkBEA,AYrBI8J,AtBqBJ,ADAA,AJDA,AJAA,A6BTK,ACUL,IR6FC,ASlHGA,MAAM,GAAG,GXkJT,CNpDC,AiB9FD,IXkJK,GAAG,CHrCL,AGqCM,CAAC,IE/BZ,GF+BmB,GAAG,CAAC,CE/BO,EAC9B,qBAAkD,EAClD,QAA+B;ArBjGjC,AkBEA,AYrBG,AtBqBH,ADAA,AJDA,AJAA,A8BCA,QR8FE,QF+BE,IHrCC,CAAC,AGqCG,ANrDE,CGgBJ,CAAC,CGqCI,CAAC,CAAC,OAAO,IAAI,CAAC,QE/BxB,EAAA,0BAAkD;ArB/FpD,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BVI,ACWJ,QR8FE,AOzGMjI,OAAO,CTwIX,ASxIY3F,CZmGX,GHhBA,CMqDI,ASxIM,CAAX,ETwIQ,ASxIY,CTwIX,CAAC,CNrDF,IAAI,CAAC,CMqDI,AE/BnB,EAAA,EF+BuB,CAAC,MNrDG,CAAC,GQsBG,ERtBE,CAAC;AbzEpC,AkBEA,AYrBE,AtBqBF,ADAA,AJDA,AJAA,A6BVM,ACWN,MCrBM8N,EToHJ,IAAI,CLPF,AKOG,AO1GMjI,CEVC,EXkJV,CNrDC,AiB7FY,IXkJR,CE9BO,ASpHd,EXkJU,ASxIY,CTwIX,AE9BM,AO1GM7F,CTwIX,ISxIU,CAAlB,ETwIe,AE9BM,CAAC,GF8BH,CAAC;AnB9H1B,AkBEA,AYrBE,AtBqBF,ADAA,AJDA,AJAA,A6BVK,ACWL,OCrBOuL,CToHL,ILPC,AKOG,CRvBF,AQuBG,ESpHL,Cd6GK,AGqCH,CHrCI,Ac7GSvG,IXkJR,GAAG,AWlJV,CXkJW,AWlJY,CXkJX,EHrCK,CAAC,IAAI,AGqCH,CHrCI,CKOI,ASpHM+I,EXkJV,CAAC,AE9BM,CSpHP,EAAgB,Gd6Gf,EAAE,EAAE,EAAE,IAAK,KKOgB,CAAC,CLPjB,EAAE,CAAC,QAAQ,GAAG,EAAE,CAAC,QAAQ,EAAzB,CAAyB,CAAC,CAAC,CAAC,mBAAmB;AhBzFpF,AkBEA,AYrBI,AtBqBJ,ADAA,AJDA,AJAA,A6BVG,ACWH,QR+FE,ASpHMD,Cd6GL,GKOG,CAAC,GF8BH,AWlJA,CjB4FM,CiB5FQ,GXkJT,CE9BO,EF8BJ,CAAC,AE9BM,CF8BL,OAAO,AE9BM,CAAC,GF8BH,CAAC;AnB9H1B,AkBEA,AYrBM5L,AtBqBN,ADAA,AJDA,AJAA,A8BCA,IR+FC,CAAC,CSpHIA,Ed6GJ,Cc7GO,Gd6GH,Cc7GO,Gd6GH,AGqCN,ANtDA,CGiBO,GHjBH,AiB5FF,GXkJK,CAAC,CAAC,CNtDC,EGiBQ,AHjBN,CGiBO,EGqCJ,CAAC,GHrCS,GGqCH,EHrCQ,AGqCN,CHrCO,EAAE,sBGqCgB,CAAC,CAAC;AnB9HvD,AkBEA,AYrBK,AtBqBL,ADAA,AJDA,AJAA,A6BVE,ACWF,IRgGgB,CSvHZ,CFYEgE,IAAI,CEVC,Cd6GR,CGqCC,ASxIS,EAAX,IZmGQ,CHjBL,GGiBS,CAAC,GHjBH,IAAI,CAAC,GGiBS,CAAC,GKQO,GAAjC,ERzB4B,CAAC,KAAK,CAAC,CQyBD,GAA2B;ArBjG9D,AkBEA,AYrBM,AtBqBN,ADAA,AJDA,AJAA,A6BXE,ACYF,MDZiBzI,ETyIf,AE7BA,CLRC,AGqCA,CAAC,AWlJMmQ,CXkJL,ASzIiB,CP4GhB,EO5GmB,CP4GhB,CAAC,ASrHJ,CjB4FD,CiB5Fa,CFShB,GP4Gc,KAAK,CAAC,EAAE;ArBjGxB,AkBEA,AYrBQ1L,AtBqBR,ADAA,AJDA,AJAA,A6BZE,ACaF,KV8HE,CS3I8BiE,EZqG9B,Ac7GMjE,GAAG,CTqHR,AO7GmC,GZqG7B,Ac7GM,AFQ0B,CAAC,GZqG7B,AKQH,AO7G+B,CZqG3B,Ac7GN,CjB2FG,AenFoC,CP6GlC,CAAC,CO7G2B,CAAvC,CAvD6C,CAyD7C,IZmGuB,CAAC;AhBzF1B,AkBEA,AYrBO,AtBqBP,ADAA,AJDA,AJAA,A8BCA,IbwFC,CAAC,IGqCM,AE7BL,IF6BS,MAAM,CNvDb,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CMuDa,EAAE;AnB9HnD,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BXE,ACYF,IbyFQ,EYrGFkE,ET0IJ,AE7BA,GAAG,CF6BC,AE7BA,CF6BC,AS1IM,CAACpG,EP6GJ,CF6BC,ANxDN,AQ2BM,EO7GE,CAAX,CP6Ga,CAAC,AO7GM,YZqGF,GAAnB,EKQgC,CAAC,CAAC,MLRE,AGqCU,CAAC,MHrCe;AhB1F/D,AkBEA,AYtBM8N,AtBsBN,ADAA,AJDA,AJAA,A6BXIrQ,ACYJ,IDZIA,EEVEqQ,Ed+GJ,AGqCA,AE5BA,CO9GO,ET0IJ,CHrCC,AYrGM,CT0IL,ANxDH,CGmBI,AGqCA,AWpJM,CTwHL,CO9GL,CZqGO,Ac/GM,Cd+GL,AKSA,CAAC,CLTC,Cc/GR,Gd+GY,CAAC,WAAW,CAAC,CAAC;AhB1FhC,AkBEA,AYtBM5L,AtBsBN,ADAA,AJDA,AJAA,A6BXIiE,ACYJ,IRkGC,AO9GGA,CP8GF,CSxHIjE,Ed+GJ,AGoCO,CNvDN,AiB5FM,CFUC,EZqGJ,AGoCO,CWnJA,AFUA,CTyIE,ASzID,CTyIE,ESzIH,CZqGD,Cc/GN,AFUa,EZqGJ,CYrGF,CAAT,KZqGkB,CAAC,EAAE,CAAC,CAAC;AhB1F3B,AkBEA,AYtBK,AtBsBL,ADAA,AJDA,AJAA,A6BXG,ACYH,GDzE+C,CfgJ9C,AQ4Be,AO7Gd,CTwIA,ANvDA,GGkBA,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,GAAG,MAAM,AKUC,CLVA,EKUhC,UAAiC,CAAuB,EAAE,CAAuB;ArBpGlF,AkBEA,AVAA,ADAA,AJDA,AJAA,A8BCA,IhBwES,IGiBP,AKUA,CF0BM,GE1BF,CF0BM,AE1BL,CAAC,CLVC,IGoCS,EHpCH,CAAC,EKUE,KAAK,CAAC,CAAC,UAAU,EAAE,GR3Bb,GAAvB,GMqD+C,EAAE,KNrDzB,MAAe,EAAE,MAAe;AbzEzD,AkBEA,AYvBI,AtBuBJ,ADAA,AJDA,AJAA,A8BCA,IbyFC,CAAC,GGqCA,ANtDA,AiB/FMwE,GAAG,CXqJL,ANtDA,AQ2BH,CF2BI,CWrJOkE,ET0HL,CF2BE,CWrJO,CjB+FL,AiB/FM5I,GjB+FH,IAAI,AiB/FN,CjB+FO,AiB/FM+L,ET0HL,ES1HS,CT0HN,AS1HOrH,CjB+FL,AQ2BD,CR3BE,AQ2BD,CS1Hb,EjB+FiB,AiB/FMU,CjB+FL,IiB/FlB,CAA6B,GXqJG,AE3BP,CF2BQ,AE3BP,AS1H1B,CjB+FkB,CAAC,AiB/FgBnF,IjB+FZ,AiB/FvB,CAAwC,MjB+FjB,AiB/FvB,CjB+FwB,AiB/FlC,CjB+FmC,cAAc,CAAC,MAAM,EAAE,MAAM,CAAC,EAAhC,CAAgC,CAAC,CAAC;AbzEvE,AkBEA,AYvBI,AtBuBJ,ADAA,AJDA,AJAA,A6BXE,ACYF,Ib0FQ,EYtGFmD,ET0IJ,ANtDA,AiB/FMH,GXqJH,AWrJM,CT0HR,CF2BI,CAAC,AWrJM,CjB+FL,CQ2BA,AO/GO,CAACjF,KAAD,CAAd,EAAuB,IZsGV,AKSO,GLTrB,AKSwB,CAAC,CAAC,QLTX,IKSuB,CAAC,ILTP;AhB3FjC,AkBEA,AYxBgBA,AtBwBhB,ADAA,AJDA,AJAA,A6BXI,ACYJ,MCxBgBA,EdkHd,AGmCO,ASzIDqG,CAAC,EEZY,CXqJR,ANrDV,AQ2BA,AO/GSrG,CEZW+N,CXqJR,CHnCN,AGmCO,CE1BT,CS3HoB,AFYV,CEZW/N,AFYVpB,CZsGL,AHlBH,CGkBI,CHlBF,CepFA,GAAa,OZsGC,AKSH,AO/GSoB,CZsGL,EKSD,EO/GW,CfoFR,AepFSpB,CfoFR,GGkBM,AYtGxB,CZsGyB,CAAC,CYtGO,CfoFR,CAAC,AepFlC,CP+GmC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,MAAM,CAAC;ArBpG5E,AkBEA,AYzBc,AtByBd,ADAA,AJDA,AJAA,A6BXIsH,ACYJ,Ib0FC,AYtGGA,CZsGF,AGoCA,AWvJE,GFaI,GAAG,CfoFR,AQ2BA,IAAI,CR3BC,EAAE,IAAI,CAAC,EepFWG,CAAf,GfoFU,AepFS,CfoFR,CQ2BC,CO/GnB,CfoFqB,CAAC,AQ2BA,UR3BA,CAAC,EQ2BY,ER3BR,GQ2Ba,IR3Bb,AQ2BiB,CR3BhB,AQ2BiB,CR3BhB,AQ2BiB,CAAC,CAAC,CAAC,CAAC,CAAC,CR3BhB,EAAR,CAAQ,CAAC,QQ2B4B,CAAC,MAAM,CAAC;ArBpG5E,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BXG,ACYH,GD/E+C,CZ0KvC,AYrGN,KTuIM,GNrDL,AQ2BA,CF0BS,GE1BL,GF0BW,KNrDH,EAAE,MQ2BM,CR3BC,IQ2BI,GLRF,GAAzB,UAA0B,AGkCuB,AE1BN,EF0BQ,AE1BN,OLRF,EAAE,UAA2B;AhB5FzE,AkBEA,AY1BI,AtB0BJ,ADAA,AJDA,AJAA,A8BCA,Qb2FE,AGmCA,AWxJM0H,CjBkGL,CAAC,EGmBE,AGmCA,AWxJM,CXwJL,AWxJMhC,GdqHH,AKQN,CLRO,AGmCA,EWxJH,ET6HC,GS7HeA,CT6HX,CAAC,GAAG,CAAC,AS7Hd,ET6HgB,AS7HY,CT6HX,CLRO,CAAC,CKQL,QLRc,CAAC,EAAE,CGmCO,CAAC,GE3BT,EAAE,CAAC,EAAE,EAAE;ArBpG/C,AkBEA,AY1BM9G,AtB0BN,ADAA,AJDA,AJAA,A8BCA,IhBwEC,CAAC,CiBlGIA,EXwJJ,CWxJO,CAAC8G,CXwJL,CHnCF,CGmCI,CAAC,EWxJF,GdqHI,AcrHSgC,CT6Hd,GLRS,AcrHS,CdqHR,AKQJ,AS7HahC,IT6HT,ES7HT,CT6HY,ULRc,CAAC,EKQF,CAAC,CAAC,CAAC,CAAC,GLRO,CAAC,CAAC,CKQH,CAAC;ArBpG1C,AkBEA,AY1BK,AtB0BL,ADAA,AJDA,AJAA,A6BXE,ACYF,IhBwEA,EepFMjG,ETyIG,CHlCN,GGkCU,EAAE,ASzID,CTyIE,ASzID9F,KP+GV,AO/GS,CAAZ,EAAqB,CP+GZ,GR3BV,CQ2Bc,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;AR3B1C,AbzEA,AkBEA,AVAA,ADAA,AJDA,AJAA,A6BXIkG,ACYJ,ChBnBA,AA0FC,GenFGA,CT0IF,ANvDD,GenFO,GAAG,EZsGF,IAAI,AYtGIvC,GP+GZ,CLTY,CAAC,CYtGK,CP+Gd,AO/GejG,IP+GX,KAAK,AO/GD,CAAiBqI,GP+GZ,EAAE,CLTY,EAAE,AYtGrB,CAA0B3J,IAA1B,CAA+B4D,KAA/B,CAAb;AfPS,AbkBb,AkBEA,AY3BI,AtB2BJ,ADAA,ARDA,A6BXG,ACYH,GDpF+C,CA0E7C,IEjBM6L,CXwJA,CWxJE,EdqHP,CGmCS,EWxJGJ,CdqHR,GGmCW,KE1BZ,ES9HF,EAAwB,GT8Hf,GLTY,CKSR,ELTW,CKSR,GLTY,CAAC,AKST,CAAC,CRvHI,SMiJoB,EAAE,KHnCA,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;AHlBtE,AbzEA,AkBEA,AY3BMxG,AtB2BN,ADAA,ARDA,A8BCA,MC3BMA,EXyJJ,CWzJO,CAACrI,EdqHP,AGoCG,CAAC,GHpCA,AcrHD,CXyJK,EWzJQmR,ET8Hb,ES9HiB,CAACnR,MAAlB,IdqHmB,EAAE,WGoCoB,CAAC;AnB/HhD,AkBEA,AY3BK,AtB2BL,ADAA,ARDA,A8BCA,IhBsE+B,IMwD7B,GAAG,EAAE,CAAC,EHpCJ,CKSC,gBR7B8B,mCGoBqB;AhB3FxD,AkBEA,AVAA,ADAA,ARDA,A6BXE,ACYF,IhB0EC,EetFKoJ,ETyIG,IAAI,ASzID,CP+GR,AO/GShG,CTyIE,CAAC,CHnCZ,EYtGQ,CAAV,CZsGM,CAAC,AYtGY,EfsFR,SAAoB,EAAE,EAAU,EGgBnB,AHhBqB,CGgBpB,GHhBgC,EAAE,IGgBzB,CAAC,AHhBqC,EAAE,CGgBpC,OHhB2D,IGgBhD,CAAC,kBAAkB,EAAE,UAAU,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC;AhB3FxG,AkBEA,AY5BI,AtB4BJ,ADAA,ARDA,A6BXIkG,ACYJ,IDZIA,CT0IF,GNrDD,AiBrGO6G,AFgBA,GAAG,CP+GR,GS/HY,CdsHX,ActHY,CFgBC9G,EP+GP,CRzBR,AiBtGa,CFgBM,CEhBC8H,AFgBArQ,CZsGX,GctHI,CdsHA,ActHX,CdsHY,CctHa,EFgBZ,CAAe4I,GP+GN,GRzBlB,AQyBqB,KO/GZ,CAA2BlK,CZsGX,CAAC,CHhBjB,CetFA,CfsFE,AetF8B4D,EfsF5B,EAAE,CQyBsB,AO/G5B,CZsG0B,AKSG,AO/G1C,CZsGwC,CAAC,AHhBlB,EAAE,IAAI,CAAC,SAIhC;Ab/EF,AkBEA,AY5BMiF,AtB4BN,ADAA,ARDA,A6BXG,ACYH,GDzF+C,CA+E7C,EElBIA,EjBsGJ,CMmDM,AE1BL,AS/HM,CAAC6G,GdsHN,AGmCQ,ANnDN,CAAC,CiBtGD,GAAY,CXyJA,CNnDL,EiBtGP,CjBsGU,IAAI,WMmDe,CNnDH,CMmDK,ANnDJ,KAAK,EAAE,KAAI,CAAC,EAAE,CAAC,CAAC;Ab3EjD,AkBEA,AY5BK,AtB4BL,ADAA,ARDA,A8BCA,QV8HE,ANpDA,AQyBA,CLTC,GGoCG,CAAC,ANpDD,CAAC,CQyBE,CAAC,CF2BC,AE3BA,KRzBI,GAAG,EQyBG,GAAG,CAAC,CAAC,CF2BO,ANpDP,CMoDQ,ANpDP,QQyBS,CAAC;ArBpGrC,AkBEA,AVAA,ADAA,ARDA,A8BCA,Ib0FC,AKSA,CLTC,AKSA,GF2BA,ANpDA,GMoDG,EAAE,ANpDD,CMoDE,ANpDD,uBAAuB,GAAG,IAAI,CAAC;Ab3EtC,AkBEA,AY5BI7G,AtB4BJ,ADAA,ARDA,A6BXE,ACYF,Ib2FQ,AKSA,AShIJA,EFgBEU,CEhBC,CXyJE,EWzJCiF,EXyJG,CSzIA,CTyIE,AWzJD,AFgBA5K,CTyIE,AWzJDgC,IFgBF,CAAX,EEhBQ,AFgBY,CEhBCiD,GAAb,EAAkBnB,IAAlB,EduHU,AcvHcsD,ETgIrB,CLTZ,EKSA,AShIS,CAA8B,IAA9B,EAAoCnF,CduHzB,EKSP,CShIJ,CAAyC,GTgIxB,CLTU,EAAE,AcvH7B,CAAN,QduH0D;AhB5F9D,AkBEA,AY5BIC,AtB4BJ,ADAA,ARDA,A6BXIgE,ACYJ,IhByEC,AiBrGGhE,AFgBAgE,CT0IF,ANrDA,EiBrGK,CduHL,AKSA,AOhHM,GEhBGQ,AFgBA,CZuGL,AKSA,CLTC,CcvHO,EduHJ,CKSC,AShIM,AFgBAb,GZuGH,CAAC,CKSC,CShIL,CTgIO,EAAE,AShIMZ,EFgBE,CEhBxB,AFgByBjF,CZuGL,CAAC,GYvGG,CAAxB,IZuG6B,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;AhB5FrD,AkBEA,AY5BG,AtB4BH,ADAA,ARDA,A6BXG,ACYH,GCpDE,CjB8HD,IGiBC,CGkCM,GEzBL,CFyBS,EHlCH,IGkCS,AEzBR,OR1BE,SQ0Bc,CAAC,EFyBQ,EAAE,cEzBQ,CAAC,EAAE,CAAC,MAAM,CR1B3B,AQ0B4B,IAAI,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC;ArBrG7G,AkBEA,AVAA,ADAA,ARDA,A8BCA,QV8HE,CE1BC,GLTA,AGmCG,CAAC,ANrDN,IMqDU,CHnCF,EAAE,CAAC,CAAC,UAAU,CAAC,AGmCS,CAAC,QHnCD,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC,UAAU,CAAC;AhB5F5D,AkBEA,AY5BE,AtB4BF,ADAA,ARDA,A6BXE,ACYF,MC5BM8N,AFgBAtM,ET0IJ,AEzBA,EOjHQ,CT0IL,AS1IM5E,CZuGR,AHlBD,AQ4BI,CFyBC,CAAC,AW1JM,GFgBR,CEhBYgR,CjBqGT,CQ4BK,CLVF,CYvGU,CZuGR,AKUG,AOjHX,CZuGS,AHlBH,AiBrGV,CduHc,CcvHU,EjBqGV,AQ4BM,AOjHM,CfqFX,AQ4BM,AOjHMnQ,KZuGJ,AYvGG,CfqFL,CAAC,AQ4BM,CAAC,COjHOuC,EPiHJ,CAAC,CR5BH,AQ4BI,CR5BH,AerFU,CAACpD,MAAN,IAAgB,CAAhD,CAAJ,EAAwD;A5BW1D,AkBEA,AY5BIsF,AtB4BJ,ADAA,ARDA,A6BXI,ACYJ,IC5BIA,GAAG,CXyJE,ANpDR,AQ4BC,CLVC,AHlBD,CGkBE,CcvHO,AFgBAiE,CTyIE,AExBP,EFwBS,CAAC,AWzJZ,CTiIc,CAAC,AOjHF,CAAC,CAAD,CAAN,GAAYD,IAAZ,GAAmBC,MAAM,CAAC,CAAD,CAAhC;A5BWJ,AkBEA,AY5BG,AtB4BH,ADAA,ARDA,A6BXG,ACYH,Ib2FC,CAAC,AGmCA,GEzBA,IAAI,IAAY,CAAC;ArBtGnB,AkBEA,AVAA,ADAA,ARDA,A8BCA,Ib4FQ,IKSN,CFwBM,GExBF,CFwBM,MAAM,CExBJ,KAAK,CAAC,CAAC,EAAE,MLTF,AGiCU,EAAE,CHjChC,UAAqB,QAAgB,EAAE,SAAuB;AhB7F/D,AkBEA,AY7BEjE,AtB6BF,ADAA,ARDA,A6BXE,ACYF,EC7BEA,GAAG,CFiBCiD,CfkFJ,CGsBA,AGiCA,CW1JO,GdyHH,AKSH,ASlID,CdyHK,GAAG,AKSH,EOjHW,CPiHR,CLTI,CAAC,AYxGM,CAAnB,EPiHa,AOjHS,CPiHR,KLTQ,CAAC,QAAQ,AGiCA,EHjCE,SAAS,EAAE,IAAI,CAAC,CAAC;AhB7FpD,AkBEA,AY5BE,AtB4BF,ADAA,ARDA,A6BXI,ACYJ,IhBuEQ,IGqBN,AGkCA,AS1IMW,CEhBC5D,GX0JH,AEzBH,ASjID,CX0JK,EHlCE,CKSF,AOjHS,CT0IL,AS1IMlC,EPiHP,EAAE,CAAC,AOjHG,CAAZ,EAAqB,OT0IO,CAAC,eNvDD,GAA/B,UAAgC,OAAsB,EAAE,GAAqB,EAAE,OAAgB;AbxEhG,AkBEA,AY5BC,AtB4BD,ADAA,ARDA,A6BXM,ACYN,CClGA,OXgOE,ANvDA,CQ8BC,EFyBE,ANvDA,CGqBF,AHrBG,CMuDC,AS1IM+D,CT0IL,ENvDE,AenFM,CfmFL,AenFME,CZwGR,EAAE,CAAC,AHrBG,CGqBF,AHrBG,EenFH,CAAYN,GfmFH,CAAC,CAAC,CenFO,CZwGR,AYxGSjG,CZwGR,QYxGC,CAAiBqI,MZwGH,CAAC,CAAC,AYxGhB,CZwGiB,AYxGS3J,IAA1B,CAA+B4D,IZwGL,CYxG1B,CZwG4B,AYxGxC,CZwGyC,CAAC,AYxGS,QAAnD,CAAP,CZwG2D,CAAC;AhB7FlE,AkBEA,AVAA,ADAA,ARDA,A6BXK,ACYL,IhBuEC,CAAC,AerFE,GT2IK,GSzIE,CZwGR,AGiCU,CEzBJ,CFyBM,CAAC,MHjCJ,EAAE,CAAC,CAAC,SAAS;AhB7FzB,AkBEA,AY5BA2K,AtB4BA,ADAA,ARDA,A6BXM,ACYN,IhBwEQ,IMoDS,AWxJT,CdwHL,AcxHMjN,CdwHL,EKQD,COhHUqG,CTwIU,EExBhB,AOhHS,CTwIU,ASxITE,CEhBjB,CTgIU,AShISxD,GAAnB,CXwJgC,CAAC,AExBlB,AOhHF,CPgHG,AShIS,AFgBA,MfoFV,GMoD4B,ANpD1C,AQ4BwB,CFwBmB,AExBlB,AShISiG,AFgBtB,CPgHc,COhHU,CTwIU,AExBlB,AShIJ,CXwJuB,CAAC,AWxJT1G,IjBoGxB,CiBpGS,CTgIY,AOhHxB,CPgHyB,AShIS+L,AFgBzC,CPgHiC,GR5BD,EAAE,AiBpGf,EAA8B,YjBoGO,EAAE,MAAe,EAAE,MAAe;AbzEhG,AkBEA,AY5BEA,AtB4BF,ADAA,ARDA,A6BXK,ACYL,EC5BEA,EdwHD,CAAC,GGgCA,ANpDA,AiBpGM,GAAGA,CXwJL,ANpDA,AQ4BH,CR5BI,GQ4BA,CR5BI,AiBpGM,CXwJL,ANpDA,CQ4BF,EShIW,GTgIN,CAAC,CShIUX,OAAL,CXwJI,AExBA,AShIvB,CTgIwB,CFwBC,KNpDQ,EAAE,AQ4BH,GAAG,CAAC,CAAC,CAAC;ArBrGxC,AkBEA,AY3BE,AtB2BF,ADAA,ARDA,A6BXG,ACYH,Ib6FS,EcxHHoC,GT+HH,AS/HM,GXsJoB,ANnD1B,AiBnGSzB,IjBmGL,CAAC,CiBnGU,CXsJkB,EWtJf9F,GXsJoB,CAAC,AWtJjB,CXsJkB,AWtJjBuH,GAAL,EdwHH,AcxHA,GdwHjB,AcxHiC,CAAhC,IXsJsD,CNnDzB,GAAG,CGqBf,GHrBmB,KGqBH,EAAE,SAAuB,AHrBN,EGqBQ,AHrBN,CAAC,eGqB8B;AhB9FvF,AkBEA,AY3BE,AtB2BF,ADAA,ARDA,A8BCA,MC3BMxQ,EdwHJ,AKQA,CFqBwD,AWrJjD,GdwHH,AHrBH,AQ6BG,AShIM,IdwHF,AHrBH,AQ6BG,CLRC,AHrBH,AQ6BG,AShIMkO,OdwHC,EKQE,CAAC,ELRE,CAAC,CAAC,EAAE,CcxHf,EAAwBlL,KjBmGJ,AQ6BG,AShIvB,CjBmGqB,AQ6BG,CShIO0G,GTgIH,AShI5B,CTgI6B,AShIvC,EjBmGsC,AQ6BG,ER7BD,IAAI,CAAC,uBAAuB,EAAE,IAAI,CAAC,CAAC;AbzE9E,AkBEA,AVAA,ADAA,ARDA,A6BXE3C,ACYF,EDZEA,GAAG,CAACC,ETsIJ,CNlDC,CepFD,CTsIG,AStIMzG,CZyGR,AKQA,CFqBI,CAAC,CStIN,CZyGK,AYzGSyC,CZyGR,EKQE,EOjHR,EPiHY,CLRC,AKQA,GLRG,MKQM,CAAC,IAAI,CAAC,CAAC,KLRF,AKQO,CLRN,AKQO,IAAI,CAAC,CAAC,WLRI,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;AhB9FhH,AkBEA,AY3BE,AtB2BF,ADAA,ARDA,A6BVE,ACWF,MC3BM,AFgBAuG,EToIG,ANjDP,CGqBC,AKQA,EShIQiF,CXoJE,ASpIX,EToIa,CAAC,ANjDP,CiBnGH,EAAYwC,CjBmGL,CAAC,CiBnGR,CAAgBtH,GAAhB,CAAJ,EAA0B,ejBmGS,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AbzEvE,AkBEA,AY3BI,AtB2BJ,ADAA,ARDA,A8BCA,IhBwEC,CAAC,GGsBA,AG0Be,AElBf,ASjIM1J,GAAG,CdyHL,EG0BiB,AWnJT,CTiIL,EFkBiB,EWnJPgO,GAAL,CdyHY,AG0BM,AWnJ5B,CdyHuB,AG0BM,CWnJR,MTiIA,CAAC,EFkBiB,CAAC,GAAG,CAAC,CAAC,UElBL,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC;ArBvG5G,AkBEA,AY3BMgC,AtB2BN,ADAA,ARDA,A6BXE,ACYF,IhBwEA,AQ8BC,CAAC,CSjIIA,AFeAvP,EZ0GJ,AG0BA,CWnJO,CAAC,CFeR,CZ0GI,AG0BA,CH1BC,AY1GM,CEfJ,EAAO,EXmJJ,ENhDX,CiBnGoB+N,CdyHL,IAAI,AczHJ,EAAYhL,GAAZ,CAAgBkG,EXmJP,CH1BI,AczHb,CXmJW,AWnJlB,CAAH,GdyH4B,YAAY,CAAC,IAAI,EAAE;AHtBrD,AbzEA,AkBEA,AY3BM,AtB2BN,ADAA,ARDA,A6BXIH,ACYJ,ChB4CA,AA2BC,CA3B8B,EQ2DvB,AOnHJA,EfwD+B,GA2BlC,CenFS,EZ0GP,AGyB0B,CWlJhB,AFeAC,KEfP,CXkJ8B,IHzBtB,CGyB2B,ASnIjB,CTmIkB,ASnIjBzC,CZ0GR,AGyB0B,ESnInB,EZ0GH,AY1GS/D,CZ0GR,IY1GE,EPmHV,AOnHuBmF,ETmImB,CEhBvD,SOnHuB,CPmHT,COnHoCM,SPmHlB,EAAE,AOnHX,EAAwCjE,GPmHhB,COnHxB,CPmH0B,AOnH9C,YPmHoE,EAAE,SAAiB,EAAE,UAAkB,EAAE,UAAkB;AR3DtH,Ab7Cb,AkBEA,AY3BK,AtB2BL,ADAA,ARDA,A6BXG,ACYH,GDdE,KPqHA,CFewD,ASlIjD,GZ0GN,AKSG,ILTC,CKSI,KAAK,EAAE,EAAE,IR5DE,IGmDG,GAAG,IAAI,CAAC,sBAAsB,CAAC,kBAAkB,EAAE,CAAC;AHtB7E,AbzEA,AkBEA,AVAA,ADAA,ARDA,A6BXI+E,ACYJ,IDZIA,ITkIF,ESlIQ,CTkIL,CHxBF,AKSA,CFeI,ASlIM/E,CTkIL,EHxBD,AKSA,CAAC,AOnHS,CAACiF,GAAL,CAAS,MZ0GH,EKSE,CLTC,AKSA,COnHSC,GAAT,EAAc,IPmHJ,EAAE,MLTM,CAAC,KKSK,EAAE,ELTE,CAAC,CAAC,CAAC,CAAC,GKSG,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;ArBxGnF,AkBEA,AY3BI,AvB2BJ,ARDA,A6BXM,ACYN,IhBsEqC,IM+C5B,AWhJDoG,IdyHL,AGuBU,AEdV,ASlIS,CFeCnG,CTiIE,CAAC,AWhJD,CdyHR,GKSG,CSlIU6E,KAAL,EAAYhL,AFeA,CAACuD,EEfb,CdyHO,AczHS2C,AFeJ,EAAM1G,CZ0GR,AczHV,CAAX,GFeuB,CfkFc,CelFDmF,YAAb,EZ0GkB,AY1GSM,CZ0GR,GAAG,CAAC,CAAC,EAAE,GY1G1B,EAAwCiB,GAAxC,EAA6CjJ,KAA7C,CAArB,EZ0GiE,CAAC,UAAU,EAAE,kBAAkB,CAAC,SAAS,EAAE,YAAY,CAAC,SAAS,EAAE,YAAY,CAAC,UAAU,EAAE,YAAY,CAAC,UAAU,CAAC,CAAC;AhB/F5L,AkBEA,AY3BI,AvB2BJ,ARDA,A6BXK,ACYL,IhB0EC,CexFY,CAAT,ETkIa,AW/ITsQ,CTkIL,GLRA,Ac1HS,EX+IW,CW/IRjB,Cd0HR,CGqBmB,EW/IP,CAAC9M,GX+IY,CAAC,CW/I7B,CAPwB,CASxB,EdwHgB,AHrBP,GGqBU,EGqBoB,CAAC,CHrBjB,CAAC,CGqBmB,AN1Cd,CM0Ce,CAAC,AN1Cd,EAAU,EGqBV,AHrBY,CGqBX,GHrBuB,CGqBnB,CAAC,AHrBoB,OGqBb,CAAC,CAAC,EHrB8B,EAAE,GGqBzB,CAAC,IAAI,AHrBoD,EGqBlD,IAAI,CAAC,CAAC;AhBhGtE,AkBEA,AYzBI,AvByBJ,ARDA,A6BXG,ACYH,QVoHE,AN3CD,AQ+BC,ILTC,AGqBG,AEZA,ILTC,EGqBK,EN1CV,AQ8BY,GAAG,KAAK,CAAC,ELTD,GAAG,AGqBA,EAAE,AEZG,CAAC,CLTF,AHrBrB,CGqBsB,CKSI,CAAC,CAAC,KR9BnB,EAAE,EAAE,EAAE,IAAI,EAAE,EGqBuB,CAAC,QHrBb,CAAC,SAIvC,CGiBsE,CAAC,aAAa,CAAC,CAAC;AhBhGxF,AkBEA,AXAA,ARDA,A8BCA,QhB0EE,AQ8BA,ILTC,AGoB0B,AEXvB,CR9BA,CAAC,EGqBA,AKSW,CAAC,EFWiB,GNzCrB,EMyC0B,CAAC,ANzCxB,CMyCyB,EHpBxB,GAAG,EHrBI,CAAC,KMyC6B,GNzCrB,CAAC,IGqBE,CAAC,aAAa,CAAC,eAAe,EAAE,IAAI,EAAE,eAAe,CAAC,CAAC;AhBhG7F,AkBEA,AY1BI,AvB0BJ,ARDA,A6BXE+D,ACYF,EDZEA,GAAG,CAACC,EfsFJ,AQ8BA,ASlIM,CX4IkD,CS9HxD,CAAS4C,CZ4GR,AKQG,CR9BA,AiBpGOyE,CjBoGN,AetFL,EZ4GK,AKQW,CAAC,GSlIX,CAAJ,EAAmB,Ed0HP,GAAG,IAAI,AHtBE,GAAG,QAAQ,CAAC,IGsBE,CAAC,IAAI,EAAE,OHtBS,CAAC,KGsBG,EAAE,YAAY,CAAC,CAAC;AhBjG3E,AkBEA,AY1BM,AvB0BN,ARDA,A6BVE,ACWF,QVkHE,ANxCA,AQ8BA,COnHOxE,CEfC,CX4IL,AW5IM,Cd2HR,AKOG,CFUC,ANxCD,CMwCE,ANxCD,EiBpGSyE,ITkIF,CLPF,GAAG,CKOI,CAAC,CAAC,CLPF,CKOI,AOnHM,CAAC/E,GEfnB,CAAL,EAA8B,AFeP,CfqFC,CerFQL,EZ4GP,AHvBE,CGuBD,CY5GH,EfqFQ,AerFOC,CZ4GR,AHvBE,EGuBA,GY5GT,CZ4Ga,AY5GxC,CZ4GyC,OAAO,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;AhBlGpF,AkBEA,AY1BQ,AvB0BR,ARDA,A6BVC,ACWD,QViHS,CHhBN,GGgBU,AETV,CSlIUkF,CX2IE,CAAC,CETT,GAAG,CSlIF,EAAc3E,ETkIP,CAAC,ASlIR,EAAmBqH,IAAI,CAAC/N,KAAxB;A9ByBR,AkBEA,AY1BO,AvB0BP,ARDA,A8BCA,IhByEC,CMyCC,ANzCA,OQ+BC,CLRM,GKQF,GAAG,EAAE,CAAC;ArBzGb,AkBEA,AY1BK,AvB0BL,ARDA,A6BTA,ACUA,IhB0EQ,KMuCA,AETL,AOlHMwF,GZ0GN,CGiBS,MAAM,IHjBJ,CY1Gd,CAAyBzB,CZ0GR,EY1GjB,EAA8B/D,CZ0GR,CAAC,GGiBQ,AS3H/B,ET2HiC,AS3HI,iBfoFL,GAA/B,UAAgC,OAAsB,EAAE,GAAqB,EAAE,OAAgB;Ab3EhG,AkBEA,AXAA,ARDA,A6BTE,ACUF,MDVMyD,ET2HJ,ANvCA,IGsBC,AHtBG,CAAS,AQ6BN,ER5BN,EerFc,CfqFH,AerFIzD,EfsFf,CGoBS,CAAC,CY1GI,CfsFJ,AetFX,CfsFY,CerFV,CZyGc,EAAE,CAAC,GYzGV+D,GAAG,CAACE,ET0HkB,KS1HtB,CAAY,WAAZ,EAAyB,WAAzB,CAAP;A5BQJ,AkBEA,AY1BI8J,AvB0BJ,ARDA,A8BCA,IC1BIA,IX4IF,ANrCA,AiBvGM,Cd0HL,Ac1HMP,GX4IH,AEXH,ASjIC,CX4IG,ANrCA,CAAC,CiBvGOA,CTiIR,CFWI,ANrCA,CAAC,AiBvGR,CTiIM,CR1BI,GAAG,CQ0BF,CAAC,CR1BI,IAAI,CAAC,CMqCO,CAAC,CEXR,CAAC,CAAC,EAAE,CR1BI,CAAC,MAAM,AQ0BH,CAAC,CR1BI,AQ0BH,CR1BI,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;Ab9ExD,AkBEA,AY1BIO,AvB0BJ,ARDA,A6BTE,ACUF,IC1BIA,EFgBEjM,EZ2GJ,AGiBA,AW5IM,CAACiK,EX4IJ,CNrCF,AQ0BA,CFWI,CAAC,AS5HM,CEhBV,AFgBW/L,CZ2GL,AHpBH,AQ0BA,ESjIW+L,Cd2HL,AHpBH,AQ0BA,COjHI,CAAZ,EAAqB,CPiHR,ASjIX,CTiIY,CR1BC,CGoBI,AHpBH,GGoBM,IAAI,AHpBH,AQ0BA,CLNI,AHpBH,AQ0BA,IR1BI,CAAC,GQ0BG,GAAG,CAAC,CR1BC,AQ0BA,CR1BC,AQ0BA,CR1BC,CAAC,CAAC,CAAC;Ab9E5C,AkBEA,AY1BIgC,AvB0BJ,ARDA,A6BTI,ACUJ,IC1BIA,Id2HF,AGgBO,AW3ID,AFgBAjH,CPiHL,ASjIM9G,Gd2HH,AGgBO,ANpCV,EMoCY,AW3IX,AFgBU,CT2HE,CNpCT,CAAC,AiBvGSA,AFgBA,KEhBb,Ed2Hc,AY3GMuC,GZ2GH,CY3GO,CAACC,SAAL,CAAexC,EfuFP,CAAC,EevFT,EAAsBoC,GfuFN,CGoBH,CAAC,AHpBI,EevFlB,CfuFqB,AevFS,EfuFP,GGoBD,CAAC,CAAC,AHpBI,CAAC,AevF7B,CfuF8B,CevFU,EAAxC,EACsBA,OADtB,CAC8B,IAD9B,EACoC,KADpC,EAEsBA,OAFtB,CAE8B,MAF9B,EAEsC,GAFtC,CAAP,GAEoD,IAFjE;A5BSJ,AkBEA,AY1BI,AvB0BJ,ARDA,A6BPI,ACQJ,QbiGE,AGee,AERf,CR3BC,AiBvGM6I,EFkBElH,CZyGL,AKOA,EFQiB,ASxHT,CElBV,AFkBWE,ETwHW,AERG,CAAC,ESlIVjH,Ed2HJ,AYzGL,CTwHqB,AW1IT,AFkBA8J,CTwHU,CHfd,Cc3HOiH,GFkBf,CElBmB,CAACnR,AFkBA,GTwHY,CAAC,EW1IxC,CX0I2C,CAAC,ASxHrC,CTwHsC,ASxH7C,CZyGwB,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC;AhBlGlD,AkBEA,AY1BImR,AvB0BJ,ARDA,A6BPG,ACQH,IhB6EC,AiBvGGA,CjBuGF,GGoBA,AGeA,AERA,ASlIM,CAACnR,Gd2HH,AGeA,AERA,GSlIF,CTkIM,CAAC,CFQC,AW1IMI,GAAd,Cd2HY,GAAG,CKOC,CAAC,ELPE,KGeE,EAAE,GHfM,CAAC,CKOC,CAAC,IAAI,CAAC,EAAE,OLPO,EAAE,QAAQ,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC;AhBlGvF,AkBEA,AY1BI,AvB0BJ,ARDA,A8BCA,IhB8EQ,IGmBN,Cc3HOwD,Gd2HH,AGcuB,AEP1B,ASlIC,CAASkG,GAAT,CTkII,EFO4B,CEPzB,CLPI,GAAG,AGcuB,AEP1B,CFO2B,AEP1B,CFO2B,QEPlB,CAAC,ER1BX,EGmBkB,AGcuB,AEP1B,CLPI,AHnBjC,AQ0B8B,CAAC,GLPM,EAAE,IHnBxB,OAAsB,CGmBc,CHnBZ,CGmBc,WAAW,EAAE,AHnBL,CGmBM,CHnBJ,CGmBM,KHnBS,EAAE,EGmBF,EAAE,EHnBe,QGmBL,CAAC,CAAC;AhBlG7F,AkBEA,AY1BI0F,AvB0BJ,ARDA,A6BRE,ACSF,IC1BIA,EFiBErF,EZ2GJ,AHpBA,AiBxGM,CXwIkD,AENvD,ASlIM,GjBwGH,CAAC,AiBxGC,CAAJ,AFiBU,CZ2GL,AY3GM/G,EfuFJ,CAAC,EevFE,CAAZ,EACE,OAAO+D,GAAG,CAACE,OfsFoB,AetFxB,CAAY,CfsFc,IetFTjE,KAAjB,EAAwB,QAAxB,CAAP;A5BOJ,AkBEA,AY1BI,AvB0BJ,ARDA,A6BPE,ACQF,MDRMqE,ETsHJ,GAAG,AWxIM,Cd4HR,AHpBA,CMgCI,AEPE,CFOD,CWxIJ,AFkBW,CfsFR,AetFSrE,CfsFR,IetFO,CZ0GF,AY1GX,EZ0Ga,AYzGX,OAAO+D,GZyGc,AYzGX,CAACE,KfqFgB,EerFpB,CfqFuB,AerFX,IfqFe,CerFVjE,KAAjB,EAAwB,QfqFmB,CerF3C,CfqF6C,AerFpD,CfqFqD,AejGpB,CAanC;A5BKF,AkBEA,AY1BG,AvB0BH,ARDA,A8BCA,QV6GS,IHXN,AGWU,AN/BV,AQyBA,EFMY,CAAC,CN/BT,CAAC,AQyBA,GAAG,ELLE,EAAE,AKKA,ULLU,MKKM,CRzBC,AQyBA,CRzBC,GQyBG,CAAC,GRzBG,EAAE,IAAI,AQyBA,CRzBC,AQyBA,KAAK,EAAE,EAAE,cRzBc,EAAE,IAAI,AQyBA,CRzBC,AQyBA,CRzBC,OQyBO,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC;ArBxGpH,AkBEA,AXAA,ARDA,A6BNE,ACOF,MDPM0C,ETmHW,CN9Bd,GGoBA,AKKA,AO9GS,CAAC1C,CTmHU,EELhB,CFKmB,AELlB,CO9GI,CAAV,EZyGU,AYxGR,EZwGU,AGUkB,CAAC,EELhB,CAAC,CO7GP+D,GP6GW,AO7GR,CZwGS,AKKA,AO7GRE,ETkH4B,CAAC,AELlB,GFKqB,CAAC,ASlHrC,CTkHsC,AELlB,AO7GR,CP6GS,KO7GrB,EAAoB,MAApB,CAAP;A5BKJ,AkBEA,AY1BE,AvB0BF,ARDA,A6BLC,ACMD,MC1BMuI,EXsIJ,AN9BA,CGoBC,AKKA,ASjIM,Cd4HL,EGUE,AWtIM,GjBwGH,CiBxGOyB,EXsIJ,CN9BC,CAAC,CiBxGF,CAAUvH,GAAV,EAAe1G,KAAf,EXsIa,AWtIShD,EXsIP,CWtIf,EAA2BwQ,GAA3B,CjBwGyB,CAAC,AiBxGMzB,MAAhC,CjBwGiC,AiBxG3C,CjBwG4C,AiBzIS,CAmCrD,MjBsGmD,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;Ab/EvE,AkBEA,AXAA,ARDA,A8BCA,IbkGC,AHpBA,CGoBC,AHpBA,GQ0BA,IFG2B,CEHtB,CAAC,KFG4B,CEHtB,CAAC,GFG0B,CAAC,CAAC,KEHlB,GAAG,CAAC,EAAE,EFGyB,EEHrB,EAAE,YAAY,EAAE,SAAS,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;ArBzGtF,AkBEA,AYzBE,AvByBF,ARDA,A6BJA,ACKA,IbkGA,AHpBA,AQ0BC,CAAC,CSjIIS,GXmIoD,AWnIjD,AFoBA3G,CEpBCjJ,MAAJ,Ed2HL,Cc3HkB,CFoBnB,CAAqBoD,GEpBGgL,EjBuGvB,AenFD,CEpBmB,CAAjB,AFoB0B,EEpBE;Ad2H9B,AHpBA,Ab/EA,AkBEA,AYzBI,AvByBJ,ARDA,A6BJE,ACKF,CbzDA,AA0JC,AHlDD,AA8BC,CA9BoC,EQ0D5B,CLRR,CHlDwC,EM2DvC,AWnIM,CjBsGP,AelFQ,ET+GJ,EAAE,AWnIMK,CXmIL,CS/GOxP,KEpBP,AFoBY,CEpBhB,AFoBiB6B,EEpBE,OFoBR,CAAgBqI,QAAhB,CAAyB3J,IP8GlB,AO9GP,CAA8B4D,EP8G5C,GO9Gc,CAAN,GAA6C,GP8G/B,AO9GrB,UP8GuC,EAAE,YAAsB,EAAE,SAAiB,EAAE,UAAkB,EAAE,UAAkB;ALlK/G,AHwGA,AbhDb,AkBEA,AYzBM,AvByBN,ARDA,A6BJC,ACKD,QVyGS,AECP,GSnISqL,CXkIE,AECP,EFDS,CAAC,GWlIV,EAAc3E,GAAd,CTmIY,CSnIO1G,CdjCL,GKoKG,CSnIjB,GTmIqB,EAAE,OR5DD;AGoD5B,AHpBA,Ab/EA,AkBEA,AYzBK,AvByBL,ARDA,A8BCA,QVwGiB,IEEd,EFFoB,GAAG,IHPL,EGOW,CAAC,IHPQ,EAAE,EHpBX,EGoByB,AGOd,CAAC,EN3BC,CM2BE,CAAC,AEElB,CFFmB;AnBzGjD,AkBEA,AXAA,ARDA,A6BHA,ACIA,IbiGC,AHpBA,IM2BC,CS5GOwG,EZqGD,AHpBA,CM2BF,AEEH,ELTQ,EHpBE,AQ6BN,CR7BO,AQ6BN,CFFI,ES5GZ,CAAqBzC,GfiFA,AejFrB,CfiFsB,CQ6BL,AO9GS/D,CZqGV,AKSE,CLTD,GYrGjB,EAAiCmF,CT4GR,CHPD,CAAC,AGOE,CHPD,KKSO,CAAC,EO9GlC,EAA+CM,MP8GH,EAAE,GO9G9C,EAA4DjE,IP8GL,AO9GvD,EfiF+D,AQ6BN,AO9GS,EfiFD,MAAM,CAAC,CAAC,AQ6BN,EAAE,UAAU,CAAC,CAAC;AR5BjF,Ab/EA,AkBEA,AY1BI,AvB0BJ,ARDA,A6BHE,ACIF,ChB6EC,GGqBA,EYtGK+E,KZsGE,Ac5HG,Cd4HF,AGKoB,AEG1B,AO9GS,GAAG,CEtBX,CFsBF,ET2GkC,AEG1B,GLRS,EGKsB,CHLnB,AGKoB,CAAC,MHLd,CAAC,MGK0B,IHLhB,IAAS,EAAE,CAAC;AHnBpD,AbhFA,AkBEA,AY1BG,AvB0BH,ARDA,A8BCA,IbkGC,KGIyD,AEIvD,ELRK,CAAC,UAAU,CAAC,KAAK,GAAG;AhBnG5B,AkBEA,AXAA,ARDA,A6BJE,ACKF,IhB6EkC,GelF3B,CZuGL,AGIA,AEKA,GFLG,AS3GMjJ,CAAC,CT2GL,CAAC,CS3GO,CAAR,EAAW0J,CAAC,GAAGhH,KAAK,CAACpD,GZuGH,EAAE,CYvGzB,EfkFoC,AelFFU,CAAC,GZuGH,AYvGM0J,CZuGL,AYvGjC,CPgHkC,COhHO,EAAE1J,CAA3C,EAA8C,gBZuGU;AhBnG1D,AkBEA,AY1BE,AvB0BF,ARDA,A6BJI,ACKJ,IhBuFC,GiBjHM2N,Cd4HL,AGGO,AEMP,AOhHMhE,IT0GK,CEMN,ASrIL,CX+Ha,CAAC,CHHN,CKSC,CLTC,AKSA,ASrIMuF,GTqIH,ASrIM,CTqIL,ASrIM5P,AFqBA,CAACoD,CPgHL,CLTC,CAAC,AHXP,CQoBQ,CSrInB,AFqBoB,EPgHE,AOhHMmC,IZuGF,AKSA,CRpBK,AQoBJ,COhHO,Cf4FD,Ae5FE7E,CAAD,Cf4FS,Ae5FvB,CAAlB,Cf4F2C,Ce5FL,Gf4FiB,EAAE,UQoBV,CRpB6B,AQoB5B,ERpB8B,IQoBxB,CRpBqC,CQoBnC,CRpBqC,AQoBpC,GAAG,GAAG,EAAE,CAAC,EAAE,ERpBqD,AQoBnD,ERpBqD,GAAW,EAAE,WAA0B,EAAE,mBAA4B,EAAE,QAAgC;AbxFtO,AkBEA,AY1BE,AvB0BF,ARDA,A6BJMiJ,ACKN,KVsGE,CS3GIA,CErBCgF,Cd4HL,AHZD,IGYK,AKSH,AOhHS,CAAChO,CZuGL,Cc5HN,CTqIK,CSrIU2Q,AFqBX,CAAYvH,Ef4FhB,AQoBS,CLTI,CAAC,CKSF,CSrIZ,CAAuB6F,ETqIP,CAAC,ASrIjB,Gd4HuB,CYvGO,CAACzI,GAAD,Ef4FxB,Ae5F8B/D,KAAN,EAAamF,Ef4F5B,EAAE,CQoBsB,CRpBpB,AQoBqB,CAAC,CRpBpB,AQoBqB,CAAC,GRpBlB,Ae5FK,Ef4FH,Ae5F8BM,Wf4FnB,Ae5FR,Cf4FS,Ce3F/BtD,MAAM,CAAC7E,CfqGf,AerGc,CADgB,EACX,IADW,CAA1B;A5BIN,AkBEA,AY1BE,AvB0BF,ARDA,A6BHK,ACIL,KbkGE,AYzGE,CZyGD,Cc5HIkO,CjBiHL,CMcM,ESzGG,CPgHR,AStID,CX+HU,ANdN,CAAC,AiBjHO/K,ETsIP,CStIL,CAAgBiG,CX+HA,CNdL,CiBjHX,EjBiHc,AiBjHO,ETsIP,CAAC,CRrBG,CiBjHQ6E,ETsIP,CAAC,IFPS,CW/HR,CX+HU,CW/HK0B,CjBiHN,CAAC,EiBjH/B,CTsIgC,ERrBI,AQqBF,ERrBI,KAAI,CAAC,EAAE,CAAC,CAAC,AQqBD,CAAC,KAAK,CAAC,EAAE;ArB7GzD,AkBEA,AY1BEb,AvB0BF,ARDA,A6BHM7F,ACIN,EC1BE6F,Ed4HD,Ec5HK,AFsBA7F,CEtBC,CX+HL,ANdA,GGWM,Ac5HF,Cd4HG,Ac5HP,AFsBU,Cf2FN,Ae3FOhJ,Cf2FN,EQqBH,COhHE,CAAY,EAAZ,EZsGa,CAAC,IHXA,CGWK,EHXF,CGWK,IAAI,IAAI,CGGF,GNdE,CAAC,EGWM,CAAC,UAAU,CAAC,KAAK,CAAC,MKUH;ArB7G1D,AkBEA,AY1BE,AvB0BF,ARDA,A6BHK,ACIL,IbkGC,IGIC,ANfA,CiBjHO,Ed4HD,CGIF,CAAC,ANfD,AiBjHJ,CjBiHK,EQqBH,CFNO,CHJI,AHXJ,CGWK,CKUR,CRrBM,AQqBL,IRrBS,SMee,CAAC,CEMV,CRrBM,AQqBL,CRrBM,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,AQqBL,EAAE,SAAS,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;ALTxE,AhBpGA,AkBEA,AY1BC,AvB0BD,ARDA,A6BHG,ACIH,CbkGC,Ac5KD,OXgLE,ANfA,GMeG,EAAE,ANfD,CMeE,ANfD,EQqBH,OAAO,WRrBgB,GAAG,KAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC;AGa1D,AhBrGA,AkBEA,AXAA,ARDA,QoBsGS,ANdP,IMcW,CNdP,AQqBF,CFPW,ANdR,CMcS,SHFQ,CHZN,GAAG,GGYmB,EAAE,MHZV,CAAC,CGY6B,EAAE,WAAoB,EAAE,KAAmB,EAAE,UAAsB,EAAE,QAAuB,EAAE,cAAmC;AhBpG/L,AkBEA,AY1BAoN,AvB0BA,ARDA,A6BJEnJ,EAAAA,EZwGD,EYxGK,CAACwD,CZwGF,AGCY,ANbf,AiBjHM,CTsIL,AStIMtH,IjBiHH,CMaiB,ANbhB,Ae5FL,CAAa,CZwGF,CAAC,AGCY,CW9H1B,CAAmBsQ,GAAnB,Cd6HoB,AGCY,CAAC,CW9HR,AFqBDtH,GZwGC,AYxGV,CZwGW,CYxGG,CZwGD,EHZF,CMaiB,CAAC,AW9HTA,CjBiHN,EMakB,AW9HtB,CX8HuB,CAAC,AW9HT,ejBiHQ,IAAI,KAAK,CAAC;AbxF1D,AkBEA,AY1BE,AvB0BF,ARDA,A6BJI,MErBE,CAAC,Cd6HL,AGCA,ANbA,AQsBA,AOlHM,CAACA,GTyGH,AW9HM8E,AFqBA,Cf4FN,Ae5FOtE,Cf4FN,CGYE,Ec7HF,CX8HK,ASzGH,CErBU8G,AFqBA,Gf4FJ,AiBjHR,CAAgBtH,EjBiHL,CiBjHX,AFqBE,CErBP,AFqBE,EErByB,AFqBA,CPkHL,GFTC,ANbC,CAAC,CMaA,CW9HS,KAAP,CjBiHM,CAAC;AbxFpC,AkBEA,AY1BE,AvB0BF,ARDA,A6BJMH,KZwGJ,Cc7HIiG,AFqBAjG,Ef4FJ,AQuBA,CSxIO,GX6HoB,AW7HjB,AFqBA,Cf4FN,Ae5FOhJ,Cf4FN,GiBjHUiO,AFqBX,CAAY7E,CTwGkB,GW7HxB,EX6H6B,AW7HjBnG,CX6HkB,CAAC,CW7H/B,CAAgBkG,GAAhB,CjBiHa,Ae5FO,CPmHL,ASxIM1G,AFqBA+D,Ef4FL,Ce5FI,EErB9B,AFqBoC/D,CTwGkB,INZpB,Ae5FJ,Cf4FK,Ce5FQmF,YAAb,EAA2BM,Gf4FJ,CAAC,Oe5FxB,EACtBiB,GADsB,EACjB,IADiB,CAA1B;A5BIN,AkBEA,AXAA,ARDA,A6BHK,IZwGJ,IAAI,AHbH,AQuBA,CFZwD,EHElD,CKUF,CRvBA,CGaK,AHbJ,IGaQ,CAAC,EKUD,CLVI,CAAC,QAAQ,CAAC,KHbC,CGaK,EAAE,AHbJ,CQuBG,EAAE,CRvBD,CAAC,SGaa,CAAC,MAAM,CAAC,CAAC;AhBrG5D,AkBEA,AY3BE,AvB2BF,ARDA,A6BHG,GALD,CZ6GD,Ec/HKqG,Ed+HD,AGFH,GAAG,CEYF,CFZI,AW7HM,CX6HL,AW7HM,Id+HC,Ac/HF,EAAOP,Cd+HmB,AKU3B,ELV6B,Ac/H5B,Cd+H6B,AKU3B,ASzIb,EAAwB,ETyIP,CAAC,SAAS,CAAC,SAAS,CAAC;ArB/GxC,AkBEA,AY3BI,AvB2BJ,ARDA,A6BHE,IZwGD,AHdA,CAAC,GGcG,AGHI,CEaN,AOlHMjG,EEvBE,CX4HE,EHGF,AGHI,CAAC,ASrGd,CEvBE,Cd+HU,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;AhBrGpC,AkBEA,AY3BG,AvB2BH,ARDA,A6BHC,IZyGA,AHdA,IMSgB,AEcf,CLTI,GKSA,CLTI,CAAC,AGLY,GHKT,AGLY,CHKX,EAAE,CAAC,CKSF,CFdgB,CHKX,AGLY,ENTrB,CGcY,AKSH,CAAC,CLTI,CAAC,AKSH,ELTK,EAAE,AGLY,CAAC,GAAG,CAAC,CAAC,4BNTrB;AbxF5B,AkBEA,AXAA,ARDA,QiBsGE,AGLA,IHKI,AGLA,AEcH,CRxBF,KMUW,IEcC,CLTI,EKSD,CLTI,GKSA,CAAC,ILTO,AGLH,CHKI,CAAC,AGLH,CHKI,CAAC,CKSF,CAAC,UAAU,CAAC;ArB/G1C,AkBEA,AY5BE,AvB4BF,ARDA,A6BFA,QZwGE,CKSC,AS1IM,AFyBAI,GZwGH,AGNuB,ANT3B,CiBlHA,MX2HkC,ANT3B,IGeQ,AYxGjB,CTkGyC,ANT7B,AezFY5C,CTkGkB,CAAC,CSlG3C,CZwGsB,AHfN,CAAC,AezFY/D,GZwGH,EAAE,AYxG5B,CfyFuB,CAAC,AezFYmF,GTkGoB,GNTxB,CAAC,KezFjC,EAAkDM,WAAlD,EAA+DiB,GAA/D,EAAoEjJ,KAApE,EAA2E;A5BE3E,AkBEA,AY5BC,AvB4BD,ARDA,A6BFE,CEhCF,KFgCMmB,EfyFL,AQwBC,CFhBwD,ANRxD,CezFA,EZwGC,AKSG,AOjHMsD,GAAV,EAAeiF,IAAf,CPiHc,KAAK,CAAC,CLTF,CKSI;ArB/GxB,AkBEA,AXAA,ARDA,A6BFEA,EAAAA,IAAI,ETiGJ,CSjGO9G,ETiGJ,CHOF,AKSA,CFhBI,CAAC,CSjGO,CAACqB,KZwGJ,CKSC,GAAG,IAAI,CAAC,SAAS,CAAC,AOjHtB,CAAgC1B,KAAhC,EAAuC0G,EPiHP,CAAC,AOjHjC,KAA+C;A5BExD,AkBEA,AY5BAiE,AvB4BA,ARDA,A6BH0D3K,IAAAA,ITiGjD,AWzHD,CdiIL,AKSA,AS1IMtC,AFwBsD,EAAEsC,CTiGpD,EAAE,CAAC,CSjGsD,CAAC0G,CExBvE,CAAmBlG,CFwBmD,EExBtE,GAAyB,UAAUkG,GAAV,EAAe;A9B2BxC,AkBEA,AY5BE,AvB4BF,ARDA,A6BJwD,GAAtD,IfwFA,CGmBA,AGVe,AEmBf,CS3IOlG,GdkIH,AKSA,AS3IM,CT2IL,AS3IM,CXwHU,GAAG,AWxHd,EAAOkG,GAAP,CXwHoB,CHUd,AGVe,AWxHT,GdkIH,CclIT,CAAV,KXwHyC,CAAC,AEmBf,CAAC,EFnBiB,CAAC,CAAC,AEmBf,CLTC,AKSA,CLTC,CAAC,CAAC,CAAC,AKSA,oBAAoB,CAAC,UAAU,EAAE,YAAY,EAAE,SAAS,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC,CAAC;ArBhH1H,AkBEA,AY5BC,AvB4BD,ARDA,C+B7BA,GjBkHC,AQ2BA,CAAC,GLRA,AGXA,IHWI,AGXA,MAAM,MHWM,CAAC,CHnBP,KGmBa,GGXA,EHWK,AGXH,CHWI,EAAE,2BHnBP;AbrF1B,AkBEA,AXAA,ARDA,A6BLE,IPqHF,EOrHMS,IAAI,CAAC3G,CZ6GR,AGZ0B,CNR5B,CezFC,EAAc,GTiGoB,KAAK,CAAC,CAAC,CEoB1C,WLR4B,CGZ2B;AEoBxD,ArBhHA,AkBEA,AY5BAmK,AvB4BA,ARDA,A6BLI,CPhBJ,AAoIC,IAAA,GS1IO,AFsBAxD,CTgGkD,AWtHjDzJ,GdmIN,AHpBD,AezFU,CAAC+C,GAAT,EEtBJ,AFsBkB,CfyFT,AiB/GU0N,EdmIP,EcnIZ,CjB+GY,EiB/Gc,EjB+GV,CAAC,IAAI,CAAC,EiB/GczH,GAAV,CjB+GI,CAAC,AiB/GU;ATM5B,ArBqBb,AkBEA,AY5BE,AvB4BF,ARDA,A6BLMxE,MAAAA,ETgGJ,ANPD,CGoBE,AHpBD,AiB/GO1B,AFsBA,ETgGJ,CWtHO,AFsBAuD,CTgGL,AWtHM,CXsHL,CShGO,CAACE,CEtBJ,EAAOyC,GAAP,CFsBA,CEtBY,AFsBA,KEtBZ,CAAV,WFsBU,EAA+B,CPjBd,QOiBjB,CAAN;A5BKN,AkBEA,AY5BC,AvB4BD,ARDA,A6BLK,CExBL,IFsBI,GZgHF,AGfO,GS/FE,CZ8GL,AGfO,EAAE,CAAC,SHeE,CAAC,KAAK,GAAG,MAAM,EAAE;AhBzGnC,AkBEA,AXAA,ARDA,A6BLMxE,MAAAA,ET8FW,CS9FR,GZ8GN,AY9GS6B,ET8FW,CS9FR,CAACE,CT8FU,MAAM,AS9FpB,CT8FqB,AS9FT,UT8FmB,AS9F/B,CT8FgC,CS9FR,ET8FW,CAAC,CAAC,KS9FrC,CAAN,KZ8GoC;AhBzG1C,AkBEA,AY5BA0G,AvB4BA,ARDA,A6BLK,OfsFH,CMQA,AWpHM,CAACjN,GdoIN,AGhBG,MHgBG,AGhBG,AWpHZ,CAAmBkJ,GAAnB,GAAyB,SXoHA,EAAE,CWpHU;A9B2BrC,AkBEA,AY5BE,AvB4BF,ARDA,A6BLG,GAND,Cf6FM,EiB7GFkG,GdoIH,AY9GM,CEtBC,EXmHmB,CWnHhB,KAAKvB,CXmHkB,KAAK,CAAC,CAAC,AWnH9B,EAAeqB,IAA1B,OXmHsD,oBNNhB,GAAvC,UAAwC,QAAgB,EAAE,cAAmC;AblF9F,AkBEA,AY5BE,AvB4BF,ARDA,A6BLI,MEtBE,CAACE,CdqIL,AHxBA,AevFM3F,CT4FkD,EWlHxD,CFsBU,CEtBC,AFsBA1G,EfuFJ,CevFL,EAAc,CfuFL,CAAC,AiB7GM,IjB6GF,AiB7GL,CjB6GM,WGwBW,UHxBU,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC;AblFnE,AkBEA,AY5BEuM,AvB4BF,ARDA,A6BLM9K,EEtBJ8K,EjB6GD,CAAC,AiB7GG,CAAC,AFsBA9K,EZ+GJ,AGnBA,CS5FO,CEtBJ,CXkHA,CWlHO4K,AFsBA/I,CT4FL,CAAC,CHmBC,AY/GM,CEtBV,AFsBWE,CEtBd,MFsBU,CAAY,CZ+GL,CAAC,MAAM,EY/Gd,CZ+GiB,CAAC,AY/GM,IZ+GF,KY/GtB,CAAN,IZ+GsC,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,IAAI,YAAY,CAAC,KAAK,EAAE;AhB1GlG,AkBEA,AY5BE,AvB4BF,ARDA,A6BLK,IfwFG,IMGC,CWjHA6I,GdqIN,AGpBU,CWjHA,CXiHE,AWjHD9M,CXiHE,IHoBN,AcrIR,gCjB8G8B,GAA/B,UAAgC,OAAsB,EAAE,GAAqB,EAAE,OAAgB;AbnFhG,AkBEA,AY5BC,AvB4BD,ARDA,A6BLG,CE3BH,IXuHE,GNJA,IGuBC,AHvBG,OAAO,EAAE,CGuBF,CAAC,iBAAiB,CAAC,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;AhB1GpH,AkBEA,AXAA,ARDA,SoBsFQ,GHoBL,AHvBA,IAAI,CAAC,KGuBK,CAAC,GAAG,AHvBD,EGuBG,AHtBf,CGsBgB,EHtBb,SAAQ,EACX,IAAI,SAAM,CAAC;AbrFf,AkBEA,AY5BA2K,AvB4BA,ARDA,A6BNE,MAAI,CAAC1D,CT4FL,AWjHM,CdqIL,AcrIMvJ,GjBiHN,KAAK,CAAC,AiBjHT,CAAmBsP,EjBiHP,Ae5FS,Cf4FR,AiBjHb,AFqBsBvH,Ef4FP,CiBjHU,EjBiHP,GAAG,Ge5FA,Cf4FI,CAAC,AiBjHSiB,AFqBAA,GErBV,AFqBJ,CAAnB,CErBsC,CFqBC,CT4FL,CNAF,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AbtFzD,AkBEA,AY5BEsG,AvB4BF,ARDA,A6BNIpO,EErBFoO,EFqBEpO,CErBC,CAAC,EdsIJ,AGpBA,AS7FM,EErBH,CFqBM,CZiHL,AGpBA,AWlHM,CXkHL,GNDH,CMCO,AWlHM4M,AFqBA9E,Gf4FT,Ae5FG,EZiHK,ActIJ,CdsIK,AHrBN,Ae5FY,CErBClG,EFqBpB,CErBQ,CAAgBkG,CdsIL,CHrBL,CAAC,AiBjHP,CdsIc,ActIrB,CdsIsB,ActIzB,EdsI2B,AGpBK,CAAC,ENDT,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;AbtF7C,AkBEA,AY5BC,AvB4BD,ARDA,A6BNG,CEvBH,OXoHE,GAAG,CHoBF,IHrBC,IAAI,CAAC,CGqBI,CAAC,iBAAiB,CAAC,IHrBC,CAAC,KGqBQ,CAAC,CHrBF,EAAE,GAAG,EAAE,EGqBK,CAAC,EHrBD,CAAC,CAAC,EGqBK,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,YAAY,CAAC,KAAK,CAAC,CAAC;AhB3G9F,AkBEA,AXAA,ARDA,SiB2GG,GGpBA,CNDC,GMCG,GAAG,IAAI,GAAG,EAAE;AnBvFnB,AkBEA,AY5BAiE,AvB4BA,ARDA,A6BPE,MAAI,CAACzI,CEpBC,CjBiHL,AiBjHMxE,CFoBP,EAAU,CZiHH,GGpBY,EWjHrB,CAAmB0Q,IXiHS,AWjH5B,GAA0B,EXiHO,CAAC,CAAC,MWjHCC,CXiHM,EWjHhB,EAAe;A9B2BzC,AkBEA,AY5BE,AvB4BF,ARDA,A6BPI,QAAItK,GAAG,CZiHR,AYjHSC,CT4FgC,ANAnC,Ge5FD,CAAS4B,KZiHJ,CAAC,CYjHN,CAAiBuB,IAAI,CZiHR,AYjHSnH,CZiHR,IYjHd,CZiHmB,EAAE,CYjHU,CAAnC,EAAsC,QZiHD,CAAC,KAAK,CAAC,CAAC;AhB1GjD,AkBEA,AY5BE,AvB4BF,ARDA,A6BPM,OEpBCkM,EdqIJ,CYjHOxJ,ET6FP,ANDA,AiBhHD,GjBgHI,CAAC,Ae5FS,CAACyC,CT6FR,ENDE,CMCC,ANDA,IAAI,CAAC,CMCC,CAAC,CS7FH,CAAV,Ef4FiB,Ae5FS,Cf4FR,CAAC,IMCI,CAAC,GAAG,CAAC,CAAC;AnBtFnC,AkBEA,AY3BE,AvB2BF,ARDA,A6BPQjD,MEnBFsL,EdqIJ,AYlHMtL,Cf4FL,AiB/GM,EFmBE,CZkHL,AGrBH,AWhHS+D,EFmBEvB,ET8FV,AWjHY,CAAC8I,GAAL,EXiHF,AWjHR,CdqIe,AczIwB,CdyIvB,AcpIhB,CFkBuB,CAACzJ,GAAD,EAAMoD,IAAI,CAACnH,GT8FX,ES9FA,EAAkB,IAAlB,CAAjB,IZkHsC,EAAE;AhB3GhD,AkBEA,AXAA,ARDA,A6BPO,If4FN,CAAC,Ee9FI,KZoHH,CYlHU,MT8FN,CAAC,MAAM,eAAa,IAAI,MAAM,IHoBS,WGpBI,CAAC;AnBvFnD,AkBEA,AY3BE,AvB2BF,ARDA,A6BPQkC,If6FA,GiBhHD,CFmBCA,GEnBG8E,AFmBA,CZkHR,AcrIS,EFmBEtC,CEnBC2J,CdqIR,EcrIW,CXiHX,AWjHYzR,CXiHX,KHoBQ,AcrID,AFmBU,CT8FX,AS9FYmH,EZkHP,AcrIS,CAA1B,AFmBuB,EEnBMiD,AFmBAG,CEnBC,EjBgHjB,Ce7FoB,CEnBC,AFmBAnH,Cf6FnC,AiBhHC,EdqI4B,AcrISgH,CdqIR,AcrIS,CFmBf,CT8FE,AWjHzB,CFmByC7B,CEnBC,EXiHb,CHoBO,AHrBtB,CGqBuB,IGpBF,ENDC,Ce7FiB,Cf6Ff,Ee7FkB,CAAjC,CAAjB,IZkHwC,CAAC,EGpBC,CAAC,ENDW,EAAE,CGqBP,CAAC,EAAE,EHrBmB,EAAE,MAAe,IGqBtB,CAAC,CAAC;AhB3G5E,AkBEA,AY3BI,AvB2BJ,ARDA,A6BPO,Qf6FL,AiBhHMqH,GAAG,CdqIR,AHrBG,EiBhHQ6B,EdqIP,CcrIU,CAACrH,CXiHX,AWjHU,CXiHT,AWjHJ,GjBgHa,GMCH,ANDM,IGqBC,AHrBG,CAAC,EGqBD,KAAK,CAAC,GHrBM,CAAC,EMCN,IAAI,CNDS,CAAC,CAAC,GMCL,KHoBU,CAAC,IAAI,CAAC,OAAO,AGpBP,CAAC,CHoBQ,CGnB7D,QHmBsE,CAAC,CAAC;AhB3G7E,AkBEA,AY3BI,AvB2BJ,ARDA,QcuFE,AiBjHMsH,IdqIL,AHpBG,IGoBC,AGnBH,ANDM,CAAC,AiBjHM,GAAG9B,CjBiHL,CAAC,CiBjHO,CAACxQ,CAAJ,EdqIF,EcrIW,CdqIR,AcrIjB,SjBiH6B,EGoBD,AHpBG,CGoBF,OGnBI,OHmBU,CAAC,gBAAS,CAAC,QAAQ,CAAC,EAAE,cAAc,CAAC,CAAC;AhB3GrF,AkBEA,AXAA,ARDA,A6BRM,UAAIkG,EZmHP,AHpBA,Ce/FU,CAAC0D,EZmHP,AGnBH,ANDG,GMCA,CNDI,CMCF,ANDG,Ae/FF,CTgGA,AShGY,IAAZ,IAAoB,CAAC,CAAzB,EAA4B,GZmHN,GAAG,AHpBA,EAAE,YGoBY,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AhB3GzE,AkBEA,AY5BI,AvB4BJ,ARDA,A6BRQ,QEnBA0I,IduIL,AYpHS7Q,IZoHL,AGrBI,ANAP,CiBlHa,AFmBT,EAAW,CT+FJ,EAAE,AWlHK,CXkHJ,AWlHd,EAAqB,CduIR,CHrBF,CAAC,CGqBI,KAAK,CAAC,EHrBD,CAAC,CGqBI,CAAC,SHrBM,CAAC,CGqBI,CAAC,IHrBC,EAAE,GAAG,CAAC,EAAE,cAAc,CAAC,CGqBI,AHrBH,EGqBK,YAAY,CAAC,KAAK,EAAE,IAAI,EAAE,cAAc,EAAE,qBAAqB,CAAC,CAAC;AhB5G1I,AkBEA,AY5BM,AvB4BN,ARDA,A6BRUyE,UAAAA,EZoHP,CHrBC,Ae/FS,GT+FT,AS/FYA,GAAG,CAACkF,KT+FP,AS/FG,CAAU,CZoHR,CAAC,EYpHH,EAAgBX,GZoHN,AYpHV,CAAoB,CZqHhC,SYrHyCY,IAAT,EAAe,QZqH/B,CACf,gBAAS,CAAC,QAAQ,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,YAAY,CAAC,GAAG,CAAC,CAClD,EACD,CAAC,WAAW,IAAI,YAAY,CAAC,KAAK,KAAK,CAAC,CAAC,EAAE,YAAY,CAAC,KAAK,EAAE,UAAU,EAAE,UAAU,CACrF,CAAC;AhBjHL,AkBEA,AY5BM,AvB4BN,ARDA,A6BRY,WEnBD5G,Cd4IR,CG1BC,CWlHE,CAAS+L,EjBiHL,CiBjHQ,CAACY,AFmBA,CEnBb,Cd4IM,Cc5IUZ,GAAG,CAACe,AFmBAlG,CEnBpB,GFmBM;A5BQZ,AkBEA,AY5BK,AvB4BL,ARDA,A6BRW,KEtBP,Id+ID,Ec5IQ,AFiBK,CTkGb,CShGUpF,Gf8FT,CehGY,CAEE,IAFF,EAEQqF,Gf8FT,CAAC,CMEI,CSlGJ,CAEe,CAFf,CAAN,IfgGe,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC;AbtF7C,AkBEA,AY5BM,AvB4BN,ARDA,A6BRS,QZ0HP,CY9HM,CEfEyE,Ed6IJ,AG1BH,CNFC,Ee9FW,CEnBC,EXmHP,CWnHUuC,SAAS,GAAGd,Cd6IL,Ec7IpB,Cd6IuB,Ac9IlB,CAEL,Ud4IkC,CAAC,OAAO,CAAC,gBAAS,CAAC,QAAQ,CAAC,EAAE,cAAc,CAAC,CAAC;AhBlHtF,AkBEA,AXAA,ARDA,A6BRUtL,QZ0HR,CG1BC,ANFA,Ce9FOA,EZ0HJ,CY1HO,GAAG,CTgGL,IAAI,EAAE,AShGMA,GAAG,CAACkF,KZ0HD,AY1HH,CAAU,IZ0HF,AY1HR,EAAgBX,EZ0HJ,CY1HZ,CZ0Hc,AY1HM,UAASY,IAAT,EAAe;A5BQ1D,AkBEA,AY5BM,AvB4BN,ARDA,A6BRY,KTgGV,GNFA,EiBjHQ0E,Ed6IP,GH5BM,CiBjHO,Gd6IN,AH5BG,AiBjHM,AFmBA,Cf8FL,AiBjHR,EAAgB,KFmBK1E,IAAf,Yf8FyB,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AbtFvE,AkBEA,AY5BQ,AvB4BR,ARDA,A6BRW,ITiGV,ANHA,CAAC,GMGG,CAAC,ESnGiB,CZ4HpB,AGzBM,CWpHI5G,AFmBAwB,ETiGD,CHyBL,Ac7IC,CAASuK,AFiBM,CTmGR,ASjGG,EZ0HP,Ac7IS,CXoHF,AWpHGY,CAAb,AFiBe,CZ4HT,AY5HJ,CEjBcZ,CXoHF,CAAC,CWpHI,CAACe,CAApB,EAAuBxB,CXoHF,CHyBL,AGzBM,CHyBL,Gc7IjB,Gd6IuB,GAAG,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,qBAAqB,CAAC;AhBlH7G,AkBEA,AY5BO,AvB4BP,ARDA,A6BRS,ITiGR,ANFQ,IMEJ,IHyBF,AGzBM,CAAC,GHyBH,EGzBQ,KAAK,IAAI,EAAE,QHyBE,CH3BR,EG2BW,CH3B9B,GG2BkC,CAAC,IAAI,CAAC,CH3BpB,MG2B2B,CH3BL,CG2BO,oBAAoB,CAAC,CAAC;AhBlHxE,AkBEA,AY5BK,AvB4BL,ARDA,A6BRO,QTiGL,ANFA,IG2BC,AGzBG,ANFA,CMEC,ANFA,IAAI,CMEC,ANFA,GMEG,CHyBF,CAAC,IAAI,AGzBG,CHyBF,AGzBG,IHyBC,EGzBK,CAAC,IAAI,CAAC,CNFC,EAAE,GMEG,EAAE,CHyBF,CAAC,EGzBK,CAAC,GAAG,CAAC,CAAC,aHyBU,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC;AhBlHnF,AkBEA,AY5BG,AvB4BH,ARDA,A6BRK,KTiGH,ASlHE,IZ2ID,EY1HQ,Cf+FR,IAAI,CAAC,uBAAuB,GAAG,IAAI,gBAAgB,EAAE,CAAC;AbvFzD,AkBEA,AY5BC,AvB4BD,ARDA,A6BRM7J,CEvCN,GXyIC,CHwBC,CY1HIA,GAAG,CTkGF,CAAC,CNFL,AehGS6B,ETkGD,CSlGI,CfgGR,AehGSE,CTkGF,ANFN,GMES,CAAC,ESlGN,CAAY,YAAZ,EAA0B,GfgGN,CAAC,KehGrB,CAAN,CfgGkC,EAAE,IAAI,CAAC,uBAAuB,EAAE,IAAI,CAAC,CAAC;AbxF9E,AkBEA,AXAA,ARDA,A6BRK,IZ2HJ,AGzBA,MAAM,CHyBC,AGzBA,CNDL,GMCS,CNDL,EMCQ,ENDJ,CG0BO,AH1BN,CG0BO,AGzBA,CAAC,KHyBK,GAAG,CAAC,EAAE,MH1BA,EAAE;AbzFjC,AkBEA,AY5BA0G,AvB4BA,ARDA,A6BRG,ITkGF,IHyBC,Ac9IM,CAACjN,CXqHF,CAAC,IHyBC,AGzBG,CNDR,EMCW,AWrHf,CAAmB6Q,CjBoHX,CAAC,CMCU,CAAC,CWrHpB,GAA2B,YAAY,KjBoHP,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AbzFnG,AkBEA,AY5BE,AvB4BF,ARDA,IoB2FC,EWtHK9D,Ed8IJ,Ec9IQ,GjBoHN,AiBpHS,IAAX,Cd8IU,CAAC,iBAAiB,CAAC,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,CGxBI,CHwBF,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;AhBnHnH,AkBEA,AY5BE,AvB4BF,ARDA,A6BTE,ITqGD,ESrGKhH,CElBC+H,Cd8IL,GGvBM,CWvHN,EAAYxG,CXuHF,CAAC,CNJH,AejGO,CZ4HL,AY5HMpG,CZ4HL,Ec9IX,Cd8Ic,Ac9IM,AFkBL,CAAf,CZ4HgB,CAAC,AY5HM,OElBOoB,KAAV,EAAiB0G,GAAjB,EAAsB;AXwH5C,AnB7FA,AkBEA,AY5BIlG,A/B2BJ,A6BTI,CTqGH,GWvHGA,Cd8IF,Ec9IK,CAACiK,AFkBAhN,IElBD,CFkBM,CElBCiJ,EjBmHV,CiBnHG,AFkBUA,EElBE,CjBmHX,AejGY,CfiGX,AejGYQ,GElBd,CAAH,CFkBa,CAAU,OAAV,CAAb,EAAiC,OfiGL,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AG4BtG,AhBpHA,AkBEA,AY5BG,A/B2BH,A6BTM,CZ4HL,EchJC,UjBqHE,AejGShF,GAAP;AZoIN,AhB3HA,AkBEA,AY5BC,A/B2BD,A6BTK,CEvBL,QjBwHG,0BGkCgC,WAA0B;AhB1H7D,AkBEA,AnBDA,IiB0HC,IAAI,AHlCH,CGkCI,GAAa,EAAE,CAAC,AHlCb,IAAI,CAAC,uBAAuB,CAAC;AbxFtC,AkBEA,AY5BA,A/B2BA,A6BVItD,IZoIH,AHlCA,AelGGA,CfkGF,GelGM,CZoIF,AcrJG4B,EFiBE+B,CEjBX,CdqJU,AcrJIkI,CdqJH,CYpII,CAACjI,CZoIF,AcrJd,CdqJe,CcrJKkE,CdqJH,EcrJjB,CdqJoB,CcrJK8H,CFiBd,CZoIY,AYpIG,GEjB1B,EAAgC,AFiBD9H,GAApB,CAAP,EZoI8B,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AhB1H/D,AkBEA,AY5BE,A/B2BF,IcwFA,EiBnHMoG,EdqJJ,CAAC,CAAC,AcrJM,GAAGrC,CdqJL,CAAC,EcrJQ,CAACe,IdqJF,CHlCf,AiBnHgB,CAAJ,CdqJM,AcrJMhL,GAAZ,CAAgBkG,GAAhB,CAAX,GdqJ4B,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,GAAG,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;AHlC9E,AbxFA,AkBEA,AnBDA,A6BXI,CfoBJ,AA8EC,CA9EiC,GGiHhC,CHjHoC,EepB9B9H,CfkGP,GelGW,CAACsI,KAAL,CAAW,8BAAX,CAAJ,EAAgD;AfoBvC,AbTb,AkBEA,AY7BE,A/B4BF,A6BXMtI,IZqIL,EctJKkO,AFiBAlO,IEjBJ,AFiBQ,CZqIF,CAAC,ActJG,CdsJF,AYrIGA,IZqIC,AYrIG,CZqIF,AYrIG0I,IZqIC,CAAC,CAAC,AYrIR,CAAY,CAAZ,EAAe1I,IAAI,CAAChC,GfmBR,GenBG,GAAc,CAA7B,CAAP;AZsIN,AHnCA,AbxFA,AkBEA,AY7BI,A/B4BJ,A6BXMgC,CZqIL,KYrIKA,EEjBE4N,EFiBE,CEjBC,EFiBEzI,CEjBC+I,EFiBE,CAAC7I,CEjBC,CAACjE,KAAf,AFiBS,CAAYpB,IAAZ,EAAkB,MAAlB,CAAP;AZuIN,AhB5HA,AkBEA,AnBDA,A6BXK,IfiG+B,CepGhC,MAGO,cZsIc,UAAuB,EAAE,CHrCV,MGqC0B,EAAE,QAAoB,EAAE,WAAoB,EAAE,OAAe,EAAE,KAAmB,EAAE,cAAsB;AhB3H5K,AkBEA,AY9BI,A/B6BJ,A6BXMA,IZsIL,AH3BA,Ee3GKA,EElBEmO,EFkBE,GAAGnO,EElBE,CAAC6L,CFkBC,CAACrI,EElBH,EAAOoK,GAAP,AFkBF,CElBT,AFkBsB,CZsIF,CH3BX,AiB7He,EFkBf,EAAmB,Kf2GC,Ae3GpB,Ef2GsB,Ae1GjBpK,Ef0G2B,EAAE,Ge3GlC,Cf2G8C,Ae1GjC,Ef0GmC,Ie3GhD,EACqB,GADrB,Ef2GmE,AezG9DA,EfyGgE,KAAa,Ae3GlF,CAEa,CfyGuE,Se3GpF,EAEyB,EfyGuF,Ce3GhH,Cf2GkH,Ae3GzH,Mf2GuI,EAAE,aAA4B,EAAE,QAAgC;AbhG7M,AkBEA,AY9BM4K,A/B6BN,A6BTMpO,IZoIL,EcxJKoO,AFoBApO,EZoID,AH5BJ,CiB5HQ,CAAC6L,AFoBA,GAAG1G,CEpBJ,EAAO+I,AFoBA,CAAC7I,GfyGf,AiB7HO,CAAH,EdwJc,CYpIP,CAAYrF,CZoIF,GYpIV,EAAkB,CZoIF,CAAC,KH3BtB,CezGK,CAAP,EZoIiC,CAAC,IH3BvB,EAAE,EAAE,EAAE,IAAI,EAAE,WAAW,CAAC,SAUvC;Ab1GF,AkBEA,AY9BM,A/B6BN,A6BTK,IZoIJ,IAAI,AH3BH,EiB7HQ,CAAC6L,EjB6HL,CAAC,CiB7HQ,CAACU,IjB6HH,GAAG,IAAI,AiB7HL,CAAT,EAAwBqB,CdwJF,EcxJK,CdwJmB,EcxJhBnD,EdwJoB,CAAC,AH3BzB,CAAC,KAAK,AiB7HR,EjB6HU,KAAI,CAAC,EAAE,CAAC,CAAC;AbhGjD,AkBEA,AY9BK,A/B6BL,A6BTG,IZoIF,Cc3JG,Gd2JC,AH3BH,GiB7HS,EjB6HL,CAAC,SG2BqB,CAAC,GH3BT,GAAG,aAAa,CAAC;AbhGrC,AkBEA,AY9BM,A/B6BN,IiB2HC,IAAI,AH3BH,EiB7HQmF,GjB6HJ,CAAC,CiB7HD,EAAW,UjB6HG,GAAG,CG2BK,GAAW,CAAC,CAAC,OH3BL,CAAC;AbhGrC,AkBEA,AY9BQ/D,A/B6BR,A6BTE,IZqID,IAAI,AH5BH,AiB7HMA,CFoBC7L,GEpBG,CjB6HN,AiB7HO2M,AFoBA,CZqIF,AH5BJ,EezGS,CZqIF,GH5BD,AezGJ,CEpBG,CdyJO,AczJX,CdyJY,AH5BJ,AiB7HOkD,AFoBAvM,GAArB,CfyGkB,OiB7HZ,CAA2B4K,IjB6HH,AiB7HxB,CjB6HyB,IG4BQ,CAAC,CH5BH,EAAE,CAAC,CAAC,CAAC,CAAC,OG4BW,EAAE,CAAC;AhB5H3D,AkBEA,AY9BO,A/B6BP,A6BTC,IZsIA,IH7BC,CG6BI,IAAI,AH7BJ,CG6BK,AH7BJ,GG6BO,CAAC,EAAE,GAAG,GAAG,UAAU,AH7BJ,CG6BK,EH7BF,IG6BQ,CH7BJ,CG6BM,AH7BL,CG6BM,GAAG,EH7BH,CG6BM,AH7BL,EG6BO,CAAC,EAAE,EAAE,UH7BK,CAAC;AbhG9D,AkBEA,AY9BK,A/B6BL,QiB6HE,AH7BA,IG6BI,CH7BA,CAAC,OG6BQ,CH7BA,EG6BG,CH7BA,QAAQ,CG6BE,AH7BD,CG6BE,CAAC,CAAC,CAAC,IH7BG,CAAC;AbhGpC,AkBEA,AnBDA,A6BRA,QZqIE,AH7BA,CexGOjG,GZqIH,CAAC,AH7BD,CAAC,QG6BS,CAAC,MYrIjB,CZqIwB,AYrIMN,CZqIL,CH7BA,GAAG,CexG5B,CZqI+B,CAAC,AYrIML,EZqIJ,EYrIlC,CfwGoC,CAAC,AexGOC,MAA5C,EAAoD,UfwGG,CAAC;AbhGxD,AkBEA,AY/BI,A/B8BJ,A6BRE,MAAIoB,EfwGJ,AiB9HMiF,GAAJ,Cd2JD,CH7BG,AiB9HOA,CjB8HN,EiB9HS,CFsBC,EEtBEA,CFsBC,CAAlB,CEtBoB,CAACxM,KAAV,SjB8HiB,GAAG,IAAI,CAAC,QG6BM;AhB7H5C,AkBEA,AY/BG,A/B8BH,A6BRE,MAAIpD,EfwGJ,IG6BC,AYrIS,CfwGN,CAAC,CexGQ2J,MZqIH,AYrIS,CAACiB,MAAP,CAAc,UAASC,GfwGH,CexGN,EfwGS,AexGMC,GAAf,CfwGa,CAAC,AexGM;A5BQjD,AkBEA,AnBDA,A6BRIH,IAAAA,KZqID,MYrIY;A5BQf,AkBEA,AYhCE,A/B+BF,A6BRI,IfuGH,CAAC,GG8BA,AYrIMG,CEvBC8E,EFuBE,CZqIL,Ac5JJ,AFuBU5G,OAAJ,CAAY,GZqIH,CYrIT,EZqIY,GYrIS,CAAzB,EAA4B2B,CZqIL,CAAC,OAAO,CAAC,CYrIO,QZqIE,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,OAAO,KAAK,cAAc,CAAC,CAAC;AhB7HtH,AkBEA,AYhCC,A/B+BD,A6BRI,IfwGI,IG6BN,GYrISE,CZqIL,GYrIS,GAAGC,GAAG,CAACtF,CZqIL,GAAG,GYrIF,CAAY,OZqIC,CAAC,OAAO,CAAC,CYrItB,EAA+B,EAA/B,EAAmCxF,MAA1C,GAAmD,CZqIL,AH7Bf,AexGtC,CZqIsD,EH7BzD,MG6BiE,EAAE,EH7BzB,KG6BgC,CAAC,CAAC,CH7BlB,EAAE,cAAmC;AbhGhG,ADCA,A6BRG,GAJY,EAIV,CAJU,CAAb,CZyIA,AH7BA,IG6BI,GH7BG,IAAI,CAAC,MAAM,CAAC,MG6BF,EAAE,aH7BqB,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC;AbhGrE,A8B9BA,A/B+BA,IcgGC,CAAC,IiB/HOmQ,Gd4JN,Ic5JH,CAAkBtC,Ed4JR,CAAC,Cc5JX,Ed4Jc,Ac5JU+B,Cd4JT,Ec5Jf,EAA6B,uBd4Ja,CAAC,CAAC;AhB7H5C,A8B9BE,A/B+BF,A6BRE,IfyGM,EiBhIF,AFuBA5P,CEvBC4P,GAAD,Ed4JH,AYrIS,EEvBG,CAACA,AFuBD,EAAb,CEvBiB,Cd4JT,Ac5JUT,AFuBD,CZqIR,GAAG,CAAC,Cc5JA,IAAe,CAACtB,IAAI,CAACW,OAAD,CAAjC,EAA6C,Id4JP,CAAC,GH5BT,GAA/B,KG4BmD,CAAC,CAAC,CAAC,EH5BtB,OAAsB,EAAE,GAAqB,EAAE,OAAgB;AbjGhG,A8B9BI,A/B+BJ,A6BRI,QfyGF,CG4BC,Ec5JQ,AFuBAjF,CfyGL,IiBhIF,CFuBa,CAAC,CfyGL,AezGI,CAAN,CfyGI,GexGHD,IAAI,KAAK,EAAT,GAAc,EAAd,GAAmBA,IAAI,GAAG,KAD3B,IAEA,GAFA,GAGAK,MAAM,CAACtE,IAAP,CAAY,OAAZ,CAHA,GAIA,GAJA,GAKAkE,MAAM,CAAC,CAAD,CALb;A5BQJ,A8B9BG,A/B+BH,A6BHG,QZiID,IAAI,AH7BH,CG6BI,GH7BA,CAAC,OG6BU,EAAE,AH7BJ,EACZ,GAAG,SAAQ,EACX,IAAI,SAAM,CAAC;AbnGf,ADCA,YiB8HG,AH1BA,KAAK,CAAC,GG0BG,AH1BA,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AbpGzD,A8B/BE,A/BgCF,A6BHE,ME7BI2F,Gd8JH,AYjIM3F,EE7BE,GAAG,CF6BC,CfuGX,AevGY,CAAD,CAAN,CE7BP,CjBoIM,CevGaD,EfuGV,EevGF,GAAmB,EfuGV,CAAC,AevGV,GAAyBK,IfuGR,CAAC,CevGa,CAACtE,EfuGV,CAAC,CevGE,CAAY,IAAZ,CAAzB,CfuG+B,CAAC,CAAC,AevGY,CfuGX,CAAC,CAAC,AevGpC,GAAmDkE,MAAM,CAAC,CAAD,CAAhE;A5BGF,A8B/BE,A/BgCF,A6BHC,EAGD,IEhCMuI,Ed+JJ,Ec/JQ,Ed+JJ,Cc/JOzI,GjBoIT,CiBpIa,CAACuH,EjBoIV,CAAC,AiBpII,Ed+JI,GAAG,Ac/JMhB,GAAG,CAACgB,GAA5B,Id+J6B,CAAC,OH3BC,CAAC,MG2BY,CAAC,AH3BN,CG2BO,CAAC,AH3BN,CG2BO,EH3BJ,EAAE,CG2BO,CAAC,GH3BH,CAAC,CAAC;AbpGvD,ADCA,A6BAA,QZ+HE,IAAI,CH3BF,UG2Ba,IAAI,eAAe,EAAE;AhB/HtC,A8BhCE,A/BiCF,M+BjCMhB,GjBqIH,AiBrIM,CAACT,EdgKP,IchKD,EAAgB,wFdgK+E;AhB/HjG,A8BhCID,A/BiCJ,I+BjCIA,KAAK,GdgKN,AchKS4C,CjBoIH,GiBpIO,GAAGlC,EdgKP,CchKU,CAACT,MAAnB;A9BiCJ,A8BhCG,A/BiCH,A6BFA,GEjCE,MdkKC,AchKM,AF+BA3F,GfqGN,GAAG,CAAC,AerGP,CAAiBuB,EAAjB,CfqGW,CAAC,AerGS,IfqGL,CAAC,MAAM,CAAC,CAAC;AbnGzB,A8BhCImE,A/BiCJ,A6BFE,IE/BEA,IdiKF,CH7BC,AiBpIM,AF+BA1O,GE/BGqN,EF+BE,CAACrE,CE/BC,CAACgF,KF+BR,CZkIQ,AYlIMzD,CE/BP,CAAJ,AF+BH,CZkIW,AYlIlB,GE/B4B+G,IAAI,GAAGjE,CdiKN,CAAC,EcjKS,CAACW,OAAD,CAArC;A9BiCJ,A8BhCG,A/BiCH,A6BFC,IfqGA,CAAC,GG6BA,uBAAuB,GAAG,WAAW,CAAC,cAAc,CAAC;AhBhIvD,ADCA,IcoGQ,IG4BN,eAAe,GAAG,UH5BL,CG4BgB,CAAC,CH5B/B,IG4BoC,CAAC,KH5BtB,MG4BiC,CAAC,AH5BZ,EAAE,GG4Be,CAAC,CAAC,SH5BK,EAAE,MAAe,EAAE,MAAe;AbpGhG,A8BjCE,A/BkCF,A6BHA3P,OAAO,CZmIL,AH5BA,AevGM2K,CE/BC0F,GjBsIH,CAAC,CiBtIL,CF+BF,GAAkB1F,MfuGA,CAAC,AevGnB,MZmIyB,CH5BC,CAAC,CG4BC,AH5BA,SG4BS,CAAC,QAAQ,CAAC;AhBhI/C,A8BjCC,A/BkCD,QiBiIE,AH7BA,IG6BI,GH7BG,IAAI,CAAC,OG6BO,KAAK,OAAO,EAAE,EH7BE,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AbpGvE,ADCA,A6BHA,IfuGC,CAAC,IevGO/B,GZoIN,MYpIH,CAAmBuD,GAAnB,EAAwB,0CZoIiC;AhBjIzD,A8BjCA,A/BkCA,A6BHE,IfwGO,KiBvIAwE,AF+BA,GZoIN,CcnKH,CAAe3B,EF+BC7C,EZoIP,AcnKT,CF+BS,CE/BY,IF+BG,SAAtB,OfwGkB,GAAnB,UAAoB,OAAsB;AbrG3C,A8BjCE,A/BkCF,A6BHC,ME/BK6C,EjBuIJ,CG4BC,CcnKO,CAACQ,CjBuIL,CAAC,IAAI,AiBvID,CjBuIE,AiBvIN,GAAeR,IAAI,CAACO,GAAD,CAAvB,EAA8B,SjBuIG,EAAE;AbrGrC,A8BjCI,A/BkCJ,KiBiIE,IcnKO,GjBuIN,CiBvIU2B,GjBuIN,CAAC,EiBvIW,GAAGlC,IAAI,CAACc,QAAD,CAAJ,CAAeqB,GjBuIN,CiBvI3B,EjBuI8B,AiBtI5BnC,IjBsIgC,AiBtI5B,CAACQ,MAAD,CAAJ,GAAeR,IAAI,CjBsI6B,AiBtI5BO,EjBsI8B,CAAC,AiBtIhC,CAAnB,IAA4B2B,MAAM,KAAK,IADzC,GACgD;A9BiCpD,A8BhCM,A/BiCN,A6BJAlR,IZsIC,GYtIM,CZsIF,AYtIG4I,IfyGL,IAAI,CAAC,AezGR,GAAoBA,SAApB,EZsI4B,EAAE,QH7BE,CAAC,OAAO,EAAE,IAAI,CAAC,uBAAuB,EAAE,IAAI,CAAC,CAAC;AbrG9E,A8BhCM,A/BiCN,QiBkIE,CH7BC,MG6BM;AhBlIT,A8BhCM,A/BiCN,A6BJA,IfyGC,CAAC,IezGO3B,GZsIN,GYtIH,CAAgBkF,GAAhB,EAAqB,IZsIL,EAAE,uBAAuB,KAAK,CAAC,CAAC;AhBlIhD,A8BhCM,A/BiCN,A6BJE,If2GM,Ke3GCA,CE7BCH,EdmKP,AYtIS,EE7BE,GAAGkF,AF6BA,IAAf,EE7BqB,CAAClF,EdmKP,EAAE,AcnKb,ajBwIc,GAAnB,OG2ByC,GH3BrB,OAAsB,EAAE,cAAsB,EAAE,MAAe,EAAE,MAAe;AbvGrG,A8BhCMuF,A/BiCN,A6BJC,ME7BKA,EjBwIJ,CiBxIO,CAACvC,EdmKP,AH3BG,CAAC,CiBxIE,EAAOkC,MAAP,CAAH,EdmKU,EAAE,EH3BK,CAAC,OAAO,CAAC,CAAC,GG2BA;AhBlIjC,A8BhCMA,A/BiCN,M+BjCMA,EjBwIJ,CG2BC,CAAC,EH3BE,AiBxIM,GAAGlF,CjBwIL,CAAC,EiBxIL,IjBwIW,CAAC,iBAAiB,EAAE;AbvGrC,A8BhCK,A/BiCL,A6BLAhM,KZuIE,EYvIK,CAACiH,If4GL,Ee5GH,Ef4GO,CAAC,Ae5GSA,MAAjB,sBf4GoC,CAAC,SAAS,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC;AbvGlE,A8BhCG,A/BiCH,IiBmIC,KH5BE,EG4BK,IAAI,CAAC;AACb,AhBpIA,A8BhCC,A/BiCD,A6BLA,CZwIC,OH5BC,Ce5GOmF,Mf4GA,IAAI,CAAC,Me5Gd,CAA2BD,GAA3B,EAAgC,gBf4GU,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AGmC5E,AhB1IA,ADCA,A6BLE,If4GD,CAAC,Ie5GOA,GAAG,IAAI,GZ8IG,CY9IjB,MZ8IiC,EAAE,QAAoB,EAAE,WAAoB,EAAE,OAAe,EAAE,KAAmB,EAAE,cAAsB;AhBzI7I,A8BhCA,A/BiCA,A6BLC,IZ8IA,AHhCQ,IGgCJ,Cc1KIoF,Gd0KA,Ac1KT,CAAcvC,Ed0KF,Ec1KZ,EAAoBqC,Cd0KH,CAAC,Ec1KlB,EAA0B,Gd0KD,CAAC,OAAO,CAAC,CAAC,OHhCV,GAAxB,UAAyB,OAAsB;AbzGhD,A8BhCE,A/BiCF,IiByIC,Ec1KKA,Ed0KD,AHhCH,EiB1IA,EjB0II,AiB1IM,CjB0IL,IAAI,CAAC,CGgCI,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,EHhCD,EAAE,CGgCI,CAAC,OAAO,EAAE,WAAW,EAAE,OAAO,KAAK,cAAc,CAAC,CAAC;AhBzIjG,A8BhCI,A/BiCJ,A6BNArR,IZ+IC,GY/IM,CZ+IF,Ac1KG+Q,AF2BA3E,CZ+IF,Ec1KK,Cd0KF,AHhCN,EiB1IWiF,EjB0IP,CAAC,CiB1IU,CAAC9M,Id0KC,CAAC,Ac1KjB,CF2BJ,GAA4B6H,GZ+IA,CAAC,aHhCO,Ae/GpC,Gf+GuC,CGgCO,CAAC,EHhCJ,MGgCY,EAAE,OAAO,CAAC,AHhCN,CGgCO,CHhCL,CAAC;AbzG9D,ADCA,IiByIC,IAAI,IHhCF,IAAI,CAAC,YGgCU,EAAE,cHhCgB,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AbzG7G,A8BjCI,A/BkCJ,A6BNA,QZ+IE,Ac3KM4C,CjB2IL,Ae/GM1D,GE5BG,CAACsE,Ed2KJ,CAAC,CY/IV,CAAkBzD,CZ+IL,CAAC,Ac3KF,CAAR,AF4BJ,EE5BuB,AF4BA,aZ+IO,CAAC,CAAC;AhBzIhC,A8BjCM6C,A/BkCN,A6BNE,If+GD,CAAC,CiB3IIA,Ed2KJ,CY/IO,CE5BC,CAACY,Id2KF,CAAC,AY/IMzD,EE5BN,Cd2KG,Ac3KP,AF4BG,CZ+IK,Ac3KM4E,GAAG,CAAC9F,AF4BA,GE5BlB,EAAuB8F,GAAG,AF4B9B,CE5B+BxM,KAA3B,Od2KiC,CAAC,WAAW,CAAC,CAAC,CAAC;AhBzItD,A8BjCK,A/BkCL,A6BNC,If+GD,CGgCE,oBHhCD;AAAD,AbzGA,ADCA,CciCA,AAuEC,CAvEmC,EGyGnC,EHzGuC,EGyGnC,CAAC,AHlCL,EGkCO;AHzGK,AbjCb,A8BlCIyK,A/BmCJ,A6BPAhP,IE5BIgP,GF4BG,CZiJL,Ac7KM,AF4BA1D,CE5BCkE,Md6KA,Ac7KD,CAAJ,AF4BJ,GAAmBlE,CE5BCyF,GAAG,CAAC5P,GF4BxB,GE5BI,UjBmEuB;AAyE3B,AbzGA,A8BlCI6N,A/BmCJ,I+BnCIA,IAAI,CAACe,Gd6KN,Ec7KK,CAAJ,CAAYmD,MAAZ,CAAmBnC,Gd6KN,Ac7KS,CAAC9F,Cd6KR,CAAC,CAAC,Ac7KjB,cd6K+B;AhB1InC,A8BlCI+D,A/BmCJ,A6BPA,If8GA,AiB1IIA,IAAI,CAACc,AF4BAzJ,GZiJN,Kc7KK,AF4BR,CE5BI,AF4Bc8F,CE5BCgH,EF4BnB,EAAuB,EZiJP,EAAE,Ec7Kd,CAA0B9B,IAA1B,Id6KyB,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC;AhB1I5C,A8BlCG,A/BmCH,A6BPE,If6SF,CAAC,IG5JE,AYjJM,CZiJL,MYjJYlF,GAAP,KAAe,QAAtB;A5BOF,A8BlCC,A/BmCD,A6BPC,EE1BD,EjBwIe,CGmCb,4BHnC8B,GAA/B,UAAgC,MAA0B,EAAE,SAAoB,EAAE,IAAY,EAAE,WAAmB,EAAE,4BAAoC;AbvG1J,ADCA,IiB0IC,IHnCC,GGmCM,IAAI,AHnCH,CGmCI,KHnCE,CAAC,YAAY,CAAC,UAAC,EAAE;AGoChC,AhB3IA,ADCA,A6BRAnM,CZkJC,MYlJM,CAACqG,If+GL,Ie/GH,Gf+GU,Ae/GSA,If+GL,Ie/Gd,Of+GyB,CAAC,SAAS,EAAE,EAAE,EAAE,IAAI,EAAE,WAAW,EAAE,4BAA4B,CAAC,CAAC;AGqC1F,AhB5IA,A8BlCA,A/BmCA,QcuGE,CAAC,AiB1IMmM,CjB0IL,CAAC,GiB1IL,CAAgBvH,GAAhB,EAAqB1G,KAArB,EAA4BpD,Id8KG,Ec9K/B,EAAoC4Q,Gd8KW,Ac9K/C,Ed8KiD,Ac9KRzB,MAAzC,Ed8KqE,Ac9KpB,Ed8KsB,WAAoB,EAAE,OAAe,EAAE,KAAmB,EAAE,cAAsB;AhB3IzJ,A8BlCE,A/BmCF,A6BRA,IZmJC,AHpCA,CAAC,EiB1IKrF,EF2BEoB,CE3BP,GAAWpB,GAAX,CF2BF,CAAkBkB,GAAlB,EAAuB,YZmJS;AhB3IhC,A8BlCE,A/BmCF,A6BRE,IZmJD,AHnCc,GiB3IR5H,Cd8KF,CYnJI,GE3BP,GAAaA,CF2BC4H,GZmJA,AYnJP,CE3BP,Ed8KiB,EYnJK,OZmJI,CAAC,AYnJ3B,CfgH8B,GAA/B,GGmCmC,EAAE,KHnCL,GGmCa,CHnCC,CGmCC,CHnCC,MAA0B,EAAE,EGmClB,EAAE,MHnC0C,CGmCnC,EAAE,KAAK,EAAE,cAAc,CAAC,CAAC;AhB3I7F,A8BlCE,A/BmCF,A6BRC,IZoJA,Gc/KMhL,CjB2IL,IAAI,CAAC,AiB3IL,GAAcA,CjB2IL,CAAC,EAAE,EAAE,AiB3Id,Qd+KyB;AhB5I3B,A8BlCE,A/BmCF,IiB4IC,Gc/KM4Q,Cd+KF,Ec/KH,EjB2IC,CiB3IUA,GAAX,Ed+Ka,AHpCN,CAAC,EGoCQ,OAAO,CAAC,EHpCJ,CAAC,UGoCgB,AHpCf,EGoCiB,AHpCf,CGoCgB;AhB5I1C,A8BlCE,A/BmCF,A6BTA/R,IZqJC,Gc/KMsQ,AF0BA,CZqJF,AYrJGjE,KE1BN,GjB2IE,AiB3IYiE,AF0BhB,EZqJe,CAAC,AYrJGjE,CfiHX,CAAC,CiB3Ia,CjB2IX,EGoCW,CHpCR,AiB3IY,CAAxB,AF0BF,CfiHgB,CAAC,CGoCU,CAAC,EAAE;AhB5I9B,A8BlCC,A/BmCD,QiB4IE,QHnCE,IAAI,IAAI,CAAC,KAAK,EAAE,mBGmCyB;AhB5I7C,ADCA,A6BTA,QZqJE,CYrJOrE,MZqJA,KHnCJ,AelHL,CAAqBmE,GAArB,EZqJoB,AYrJM,CZqJL,AHnCT,IAAI,SAAS,CACnB,IAAI,CAAC,uBAAuB,EAC5B,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,KAAK,EACV,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,CAC/D,CAAC;Ab/GP,ADCA,A6BTE,KZqJA,IYrJOA,GAAG,KfwHP,AexHY,KAAK,CAApB;A5BSF,ADCA,A6BTC,IZsJA,IAAI,QH7BD,IAAI,CAAC,EG6BW,EH7BP,CG6BU,AH7BT,KAAK,EAAE,QG6BiB,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,OAAO,EAAE,KAAK,EAAE,cAAc,CAAC,CAAC;AhB7InH,ADCA,IiB6IC,IAAI,CAAC,WH7BD,IG6BgB,AH7BZ,EG6Bc,EH7BV,CAAC,UAAU,EAAE;AbhH1B,ADCA,A6BVAnM,OAAO,CZuJL,AYvJMgI,WAAR,GAAsBA,Ef0HhB,Se1HN,Cf0HgB,GAAG,WG6BuB,SH7BX,CAAC,EAAE,EAAE,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;AbhHjE,ADCA,QiB6IE,OAAO,MH7BH,KG6Bc,CAAC;AhB7IrB,ADCA,A6BVA,KZuJE,IYvJOqC,QAAT,CAAkBiC,Ef0Hb,Ae1HL,EAAsB,Kf0HV,IAAI,eAAe,CACzB,IAAI,CAAC,uBAAuB,EAC5B,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,WAAW,EAChB,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,CAC/D,CAAC;AbtHP,ADCA,A6BVE,IZwJD,IAAI,CAAC,AYxJGpF,QfgIJ,AehIY,CAACoF,EZwJD,AYxJA,CAAR,CZwJU,GYxJMC,cAAc,CAACD,EAAD,CAAd,KAAuB,iBAA9C;A5BUF,ADCA,A6BVC,QZwJC,QHvBE,IAAI,IAAI,CAAC,KAAK,EAAE,kBGuBwB;AhB9I5C,ADCA,QiB8IE,OAAO,KHvBJ,OAAO,GGuBY,CAAC,AHvBT,cAAc,CACxB,IAAI,CAAC,uBAAuB,EAC5B,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,WAAW,EAChB,IAAI,CAAC,KAAK,EAAE,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,EACjG,IAAI,CAAC,KAAK,EAAE,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,EACjG,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,CAC/D,CAAC;Ab/HP,ADCA,A6BXAtM,KZyJE,EYzJK,CAACqK,QAAR,Cf0IK,Ee1IcA,QAAnB;A5BWA,ADCA,IiB+IC,YHfG,OAAO,IAAI,YAAY,CACtB,IAAI,CAAC,iBGciD,MHd1B,EAC5B,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,WAAW,EAChB,IAAI,CAAC,KAAK,EAAE,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,EACjG,IAAI,CAAC,GAAG,EAAE,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,EAC7F,IAAI,CAAC,mBAAmB,EACxB,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,CAC/D,CAAC;AbzIN,ADCA,A6BXA,IZ0JC,IAAI,CY1JInD,GfoJN,CAAC,CAAC,CAAC,EepJN,CAAkBiF,GAAlB,EAAuB,CZ0JF,GAAG,WAAW,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;AhB/I5D,ADCA,A6BXE,IZ0JD,IAAI,CHNF,AepJM,OAAOA,GAAP,KAAe,IZ0JC,GAAG,CY1JnB,IAA2BA,GAAG,KAAK,EZ0JD,CAAC,CY1J1C,aZ0JwD,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;AhB/IpE,ADCA,A6BXC,IZ2JA,IAAI,AHNH,OAAO,IAAI,CAAC,EAAE,CAAC,KGMQ,GAAG,gBAAgB,IAAI,CAAC,eAAe,CAAC,aAAa,IAAI,oBAAoB,KAAK,gBAAgB,CAAC,EAAE;AhBhJ9H,ADCA,Ic0IC,CAAC,GGMA,iBAAiB;AhBhJnB,ADCA,A6BZAnM,IfuJgB,GevJT,CZ4JL,AY5JMkH,OZ4JC,CY5JT,GAAmBA,QAAnB,GZ4JwB,CAAC,CHLO,GAA/B,UAAgC,QAAsB,EAAE,MAA0B,EAAE,UAA0B;Ab3I/G,ADCA,KiBgJE,GHLA,IAAI,CAAC,GAAkB,EAAE,EACxB,gBAAwB,EACxB,gBAAwB,EACxB,CAAS,EACT,SAAiB,CAAC;Ab/IrB,ADCA,A6BZA,IZ4JC,IHAC,Ce5JOqD,EZ4JD,CHAF,Ge5JN,CAAgBiC,CAAhB,EAAmB,Cf4JL,EGAK,AHAH,CGAI;AACpB,AhBjJA,ADCA,A6BZE,CZ4JD,QY5JQtF,Gf4JN,Ke5Jc,CAACsF,CAAD,CAAR,IAAeD,cAAc,CAACC,CAAD,CAAd,Cf4JS,Ie5Ja,eAA5C;AZ0KF,AhB9JA,ADCA,A6BZC,Yf4JE,gBAAgB,GAAG,CAAC,CAAC;AbhJxB,ADCA,YcgJG,KAAK,SAAS,IAAI,QAAQ,EAAE;AbhJ/B,ADCA,A6BbAxM,OAAO,CAACuK,MAAR,Ef6JI,Ce7JaA,Gf6JT,Ge7JR,Mf6JiB,KAAK,yBAAyB,EAAE;AbhJjD,ADCA,oBcgJK,SAAS;AbhJd,ADCA,A6BbA,GZ0KG,MY1KML,OAAT,Cf6JK,Ae7JY3J,CAAjB,EAAoB;AZ2KpB,AhB9JA,ADCA,A6BbE,SAAO2G,Of6JL,Ce7Ja,CAAC3G,CAAD,CAAR,KACFgM,MZyKwB,CHbX,GAAG,GGawB,CYzK1B,CZyK4B,AYzK3BhM,CAAD,CAAd,Cf4JwB,CAAC,Ge5JH,CZyKwC,EAAE,GHb9B,EAAE,EAAE,CAAC,CAAC,EGa4C,EAAE,AYzKtF,IAA0CA,CAAC,EZyK0D,EAAE,KAAmB,EAAE,CYzKrEH,KADrD,CAAP,GZ0KuJ;AhB7JzJ,ADCA,A6BZC,IZyKA,IAAI,QHbD,IAAI,EGaW,GAAG,CAAC,CAAC,CAAC,QHbD,GAAG,gBAAgB,EAAE;AbhJ7C,ADCA,IiB6JC,IAAI,UAAU,EHbV,CGa4B,EAAE,CAAC,YHbf,GAAG,gBAAgB,CAAC;AbhJzC,ADCA,A6BbAJ,IZ0KC,GY1KM,CAACkK,CZ0KF,IAAI,EY1KV,EZ0Kc,AHbT,Ce7JaA,EZ0KD,KAAK,AY1KtB,EZ0KwB,IAAI,EAAE,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,EAAE;AhB7JjD,ADCA,QiB6JE,IAAI,CHbF,OGaU,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;AhB7JvC,ADCA,A6BbA,QZ0KE,CY1KOP,GZ0KH,AHZH,Oe9JH,CZ0Kc,AY1KMwC,GAApB,EAAyB,OZ0KC,AHZH,qBGYiB,EAAE;AhB7J1C,ADCA,A6BbE,SAAO,GZ0KN,AHZA,Ie9JaA,Cf8JR,CAAC,Ce9JA,Ef8JG,CGYC,AHZA,CGYC,CHZC,Ae9JS,Cf8JR,EGYE,CAAC,CHZC,Ke9JlB,Wf8JkC,EAAE,CAAC,EAAE,EAAE;AbjJ3C,ADCA,A6BbC,gBZ0KG,AHZA,CAAC,CAAC,CAAC,CGYC,AHZA,EGYE,CHZC,IAAI,CAAC,EGYE;AhB7JlB,ADCA,aciJI,GGYA,KAAK,EAAE,IAAI;AhB7Jf,ADCA,A6BdAnM,OAAO,CAAC2J,IfgKL,CGWC,CAAC,CAAC,GY3KN,GAAqBA,SfgKA,CehKrB;A5BcA,ADCA,SiB6JG,GHXA,KAAK,SAAS,IAAI,QAAQ,EAAE;AblJ/B,ADCA,A6BdA,KZ2KE,IY3KO8C,OfgKL,IAAI,AehKR,CAAqBN,GAArB,EAA0B,GfgKT,KAAK,yBAAyB,EAAE;AblJjD,ADCA,A6BdE,IZ4KD,KAAK,AY5KGA,GAAG,CZ4KF,IY5KO,GfgKZ,CehKI,CZ4KU,GAAG,AY3Kb,If+JK,Ge/JEA,GZ2KgB,AY3KvB,CZ2KwB,GAAG,CY3KZ,CZ2Kc,EAAE,MY5K/B,GZ4KwC,CY1KxC,CZ0K0C,MY1KnCA,GZ0K4C,AY1KnD,GZ0KsD,EY1KvC,QZ0KiD,AY5KhE,CZ4KiE,GAAG,AYzKpE,EZyKsE,EAAE,GYzKjEA,GAAP,KAAe,QAHf,IAIA,OAAOA,GAAP,KAAe,QAJf,IAI4B;A5BUrC,ADCA,A6BVS,QZwKP,CYxKcA,GZwKV,AYxKG,Kf4JJ,Ae5JmB,MZwKP,GAAG,EY7KlB,OZ6K2B,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,SAAS,CAAC,KAAK,CAAC,OAAO,EAAE,WAAW,EAAE,cAAc,KAAK,OAAO,CAAC,CAAC;AhB9J3H,ADCA,A6BVC,QZwKC,IAAI,CAAC,GAAG,AHZN,WGYiB,CAAC,IHZF,GGYS,AHZN,CGYO,OHZC,CAAC,SGYe,AHZN,CGYO,CHZL,EAAE,CAAC,CAAC,GGYS,EAAE,OAAO,CAAC,CAAC;AhB9JnE,ADCA,QiB8JE,IAAI,IHZF,IAAI,aGYW,EAAE,aHZe,GAAG,CAAC,CAAC;AblJzC,ADCA,A6BXAnM,OAAO,CAACyM,IZyKL,IHZC,GGYM,AYzKV,CZyKW,AHZH,Ee7JcA,CZyKR,CAAC,IHZC,CAAC,Ie7JjB,Kf6J0B,CAAC,CAAC,QAAQ,EAAE,CGYI,CAAC,CAAC;AhB9J5C,ADCA,A6BVAzM,OAAO,CAAC0M,IZwKL,IYxKH,GZwKU,AYxKS9G,CZwKR,AHZN,GGYS,CAAC,EYxKW,CAAC,oBAAD,Cf4JO,Ae5JjC,CZwKwC,CAAC,CHZL,UGYgB,CAAC,AHZN,CGYO,AHZN,CGYO,gBHZU,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;AblJ3G,ADCA,SiB8JG,QHZE;AblJL,ADCA,A6BVA,QZyKE,CYzKO2G,GZyKH,CAAC,EAAE,CHbL,CAAC,CAAC,Ke5JN,CAAwBI,CAAxB,EAA2B,Of4JL,CAAC,GAAG,WAAW,CAAC,iBAAiB,CAAC,MAAM,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC,uBAAuB,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC,IAAI,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC,WAAW,EAAE,4BAA4B,CAAC,CAAC;AblJtM,ADCA,A6BVE,SAAO/H,GZyKN,CHbC,Ee5JW,CZyKR,AYzKS3C,SAAP,CAAiBqI,GZyKN,GAAG,EYzKd,CAA0B3J,IAA1B,CAA+BgM,CAA/B,CAAP,CZyKgC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AhB/JlD,ADCA,A6BVC,Sf4JE,GGaA,IAAI,aAAa,KAAK,CAAC,CAAC,EAAE;AhB/J7B,ADCA,QcmJE,OAAO,CGYL,AHZM,CAAC,0BGYoB;AhB/J/B,ADCA,A6BTA,If4JC,CAAC,Ie5JOC,GAAT,CAAahC,CAAb,EZwKI,AYxKY,KZwKP,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;AhB/JlC,ADCA,A6BTE,If6Jc,Ke7JPA,CAAC,GAAG,EAAJ,CZwKL,EYxKc,IZwKR,EYxKcA,CAAC,CAACN,Mf6JM,Ee7JR,Cf6JvB,Ae7JkC,EAAX,CAAf,GAAgCM,CAAC,CAACN,Ef6JV,Me7JQ,CAAW,Cf6JC,Ce7JZ,Cf6Jc,Ae7JrD,Mf6J+E,EAAE,UAA0B;AbpJ7G,ADCA,A6BTC,Qf6JC,IAAI,CGWF,AHXG,GAAa,EAAE,EACnB,OAAiB,EACjB,CAAS,EACT,GAAW,EACX,SAAiB,EACjB,eAA4B,EAC5B,IAAU,EACV,QAAiB,CAAC;Ab3JrB,ADCA,Qc4JE,IGGC,AHHG,IGGC,CAAC,CAAC,EHHK,EAAE,UGGO,IAAI,CAAC,CAAC,cAAc,CAAC,MAAM,EAAE;AhB/JpD,ADCA,A6BRA,IAAIuC,MAAM,EfoKP,CepKU,CAAC,EZuKV,CHHI,CAAC,CepKI,EfoKD,AepKS,CfoKR,EAAE,EGGD,AYvKD,CZuKE,AHHG,CepKU,EfoKP,GepKR,CZuKS,CAAC,AYvKY,GfoKN,CAAC,CepKjB,EAA6B,EZuKV,CAAC,AHHG,EAAE,AepKzB,CfoK0B,CepKU,CZuKX,CHHI,CGGF,CAAC,CAAC,AHHG,AepKhC,EfoKkC,AepKS,CfoKR,EAAE,EAAE,AepKvC,EAAkD,KZuKP,AYvK3C,CZuK4C,CAAC,AYvKY,CZuKX,CAAC,GYvK/C,EZuKoD,AYtKnD,CZsKoD,CAAC,GYvKtD,EACQ,KADR,EACe,KADf,CAAb,EAGA;A5BKA,ADCA,gBiB+JI,AHHA,OAAO,GAAG,IGGI,CAAC,GHHG,CAAC,CAAC,CAAC,CGGC,AHHA,EGGE,QAAQ,EAAE,WAAW,EAAE,SAAS,CAAC,KAAK,EAAE,UAAU,EAAE,SAAS,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC;AhB/JhI,ADCA,A6BNA,SAASC,OZqKL,AHHA,EelKJ,GAAqB,IfkKR,CGGC,CAAC,CHHC,CAAC,CAAC,CAAC,GGGG,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AhB/JjE,ADCA,A6BNE,MAAIN,CAAC,GAAG,IAAIhC,EZqKV,AHFA,EenKM,EfmKF,AenKN,OfmKa,CAAC,EGEE,GAAG,CAAC,CAAC,AHFA,EAAE,YGEY,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;AhB/J7C,ADCA,A6BNE,MAAIuC,IAAI,GAAG,CAACH,EZqKV,CYrKa,CAACJ,CAAC,CZqKX,AHFH,AenKeQ,CZqKX,CAAC,EHFD,IenKS,EAAD,CfmKD,AenKH,CfmKI,CelKHJ,GZoKU,AYpKP,CZoKQ,AYpKPJ,CZoKQ,AYpKP,CZoKQ,AHFH,AelKJS,CZoKQ,AHFH,GGEM,GAAG,AHFH,CAAC,CAAC,CAAC,AelKhB,EAAD,CADJ,CZqK4B,CHFF,AejKzBL,CZmK6B,EHFD,AejKzB,CAACJ,CfiK0B,AejKzB,CAACU,UAAF,EAAD,CAFJ,EAEsB1G,IAFtB,CAE2B,GAF3B,CAAX;A5BMF,ADCA,A6BJE,SAAO,CAACgG,CAAC,CAACW,OAAF,CZmKL,CYnKI,EAAcN,CfiKjB,GGEM,EYnKiB,CZmKd,AYnKeL,CZmKd,AYnKe,CZmKd,AYnKeY,QAAF,EAAD,CAApB,EAAoCL,CZmKd,CAAC,CAAC,CAAC,AYnKzB,CZmK0B,CYnKgBvG,EZmKb,CAAC,CYnK9B,CAA+C,GAA/C,CAAP,EfiK0C;Ab7J5C,ADCA,A6BJC,EAGD,kBZgKK,IHFC,IAAI,GGEM,GAAG,KAAK,CAAC,KHFE,GAAG,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;Ab7JpE,ADCA,iBiB+JK,OHFC,IAAI,iBAAiB,EAAE;Ab7J7B,ADCA,aiB+JI,eHFG,SAAS,GAAG,WAAW,CAAC,iBAAiB,CAAC,iBAAiB,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;Ab7JxF,ADCA,A6BHAxG,OAAO,CAACqN,CZkKL,EYlKH,GAAc,WfgKP,CehKkB;A5BGzB,ADCA,A6BHE1F,EAAAA,OAAO,CAAC0F,GZiKD,AYjKP,CAAY,SAAZ,EAAuBP,If+JZ,Ke/JqB,EAAhC,EAAoC9M,OAAO,CAACmG,MAAR,CAAejE,KAAf,CAAqBlC,OAArB,EAA8B4B,SAA9B,CAApC;A5BGF,ADCA,A6BHC,CAFD,WZmKG,KAAK,GAAG,QHFJ,CGEa,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,+FHFmF;Ab5JpH,ADCA,A6BDA,YZ+JG,MAAM,OHFF;Ab5JP,ADCA,A6BDA,SZ+JG,YHFG;Ab5JN,ADCA,A6BDA,KZ+JE,oBHHU,IAAI,OAAO,CAAC,OAAO,KAAK,OAAO,IAAI,OAAO,CAAC,OAAO,KAAK,OAAO,EAAE;Ab3J5E,ADCA,A6BDA,IZgKC,OAAO,EAAE,KAAK,EAAE,IHJX,CGIgB,EAAE,OAAO,EAAE,OAAO,EAAE,cAAc,EAAE,QHJP,MGIqB,EAAE,WAAW,EAAE,WAAW,EAAE,CAAC;AACrG,AhBhKA,ADCA,A6BDA,CZgKC,uBHJK,SAAS,GAAG,WAAW,CAAC,iBAAiB,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;AGMjG,AhBjKA,ADCA,A6BDA,qBf4JM,IGKmB,OAAgB,EAAE,QAAoB,EAAE,WAAoB,EAAE,OAAe,EAAE,KAAmB,EAAE,UAAsB;AhBhKnJ,ADCA,A6BDA,IZiKC,IAAM,UAAU,GAAG,IHNR,YGMiB,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC;AhBhK/C,ADCA,A6BDA,IZkKC,IAAI,IAAI,GAAG,KAAK,CAAC,GHPZ,IAAI,mBAAmB,GAAW,IAAI,EACrC,sBAAsB,GAAW,IAAI,EACrC,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;Ab5JjD,ADCA,A6BDA,IZmKC,IAAI,gBAAgB,AHNf,GGMkB,CHNd,UAAU,IAAI,CAAC,EAAE,GGMkB,CAAC,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,OAAO,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;AhBlK1G,ADCA,A6BDA,IZmKC,KAAK,GAAG,gBAAgB,AHNlB,CGMmB,KAAK,CAAC,YHNN,GAAG,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;Ab5JtE,ADCA,A6BDA,IZmKC,OAAO,GAAG,cHNJ,EGMoB,CAAC,OAAO,CAAC,WHNP,GAAG,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;Ab5J1E,ADCA,A6BDA,IZmKC,WAAW,GAAG,OHNR,SGMwB,CAAC,WAAW,CAAC;AhBlK5C,ADCA,A6BDA,IZmKC,IAAI,cAAc,GAAG,IHPT,YGOyB,CAAC,cAAc,CAAC;AhBlKtD,ADCA,IiBmKC,OAAO,CAAC,IAAI,EAAE,UHRR,mBAAmB,GAAG,OAAO,CAAC,OAAO,CAAC;Ab3J7C,ADCA,QiBmKE,QAAQ,EAAE,CAAC,CAAC,KHRP,4CGQwD;AhBnK/D,ADCA,A6BHA5B,KZsKE,EYtKK,CAACsN,QAAR,GAAmB1H,Kf8Jb,Ee9JoB,CAAC,UAAD,CAA1B,Kf8JyB;Ab3JzB,ADCA,IiBoKC,oBHTK,eAAe,GAAG,MAAM,CAAC,kBAAkB,CAAC,mBAAmB,EAAE,UAAU,CAAC,CAAC;Ab3JnF,ADCA,A6BHA5F,OAAO,CZuKL,AYvKM8I,IZuKF,GYvKN,GAAkB,Mf+JZ,IAAI,Ae/JiByE,KZuKR,CYvKD,CZuKG,CYvKcC,GAAjB,EAAsB,Ef+Jf,EAAE;Ab5J3B,ADCA,A6BHE,YZuKC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,AHRZ,IAAI,sBAAsB,EAAE;Ab5JnC,ADCA,A6BHE,MAAI,CAACA,GAAD,EZuKH,EYvKW,CAACtG,IZuKL,CAAC,GAAG,AYvKS,CZuKR,AYvKSsG,GAAD,CAArB,EAA4B,Ef+JtB,IAAI,Ce/JyBD,EZuKP,GAAG,CYvKH,af+JE,EGQU,CAAC,AHRR,QGQgB,CAAC,CAAC,KHRH,CAAC,CGQS,CAAC,KAAK,EAAE,CHRP,CAAC,GGQW,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,EHRN,CGQS,AHRR,CAAC,EGQU,CAAC,CAAC;AhBpKlG,ADCA,A6BFE,MAAIxH,GZsKH,CYtKO,GAAGnB,MAAM,CAACmB,IAAP,CAAYyH,GAAZ,CAAX,Gf8JM,IAAI,oBAAoB,EAAE;Ab5JlC,ADCA,A6BFE,MAAI3L,CAAC,CZsKL,EYtKQkE,EZsKJ,CAAC,CYtKO,CAAC5E,CZsKL,KYtKR,ef8JO,CGQsB,CAAC,OAAO,AHRrB,EGQuB,CHRpB,OGQ4B,EAAE,EHRnB,CAAC,QGQ6B,EAAE,OAAO,AHRrB,CAAC,CGQsB,KAAK,EAAE,YHRT,EGQuB,AHRrB,CGQsB,CAAC,IHRjB,EAAE,eAAe,CAAC,UAAU,CAAC,CAAC;Ab5J7G,ADCA,QiBqKE,IAAI,CAAC,CAAC,EAAE,iBHTD;Ab5JT,ADCA,A6BHE,SAAOU,CAAC,EZwKP,AYxKD,EAAY,EZwKP,qBAAa,AHVL,EGUO;AhBrKtB,ADCA,A6BHI0L,IAAAA,MAAM,CAACxH,IAAI,CZwKX,AYxKYlE,CAAD,CAAL,CAAN,GAAkB2L,CZwKX,CAAC,CYxKa,CAACzH,CZwKX,CAAC,EYxKc,CAAClE,CAAD,CAAL,CAArB,Ef8JK,YGU2B,CAAC,CAAC,+FHVgF;Ab3JtH,ADCA,A6BHG,aZwKC,oBHVK;Ab3JT,ADCA,YiBqKG,WAAW,MHVN;Ab3JR,ADCA,A6BJE,SAAO0L,GZyKN,GYzKD,OZyKW,CAAC,OAAO,CAAC,EHXR,GGWa,EAAE,UAAU,CAAC,CAAC;AhBrKzC,ADCA,A6BJC,CAVD,WZmLG,IAAI,GAAG,IAAI,CAAC,QHXP,SAAS,GAAG,WAAW,CAAC,iBAAiB,CAAC,eAAe,CAAC,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,eAAe,CAAC,UAAU,CAAC,CAAC;Ab1JxH,ADCA,YiBqKG,OAAO,UHXF;Ab1JR,ADCA,A6BJA,SZyKG,AYzKM/B,cAAT,CAAwB1F,Cf8JjB,Ee9JP,EAA6B2H,IAA7B,EAAmC;A5BInC,ADCA,A6BJE,QZ0KA,CY1KO7I,GZ0KH,GY1KS,CAAC3C,SAAP,CZ0KW,AY1KMuJ,GZ0KkB,AHb/B,CGagC,CAAC,SY1KrC,CAAgC7K,IZ0KmB,AY1KnD,CZ0KoD,AY1KfmF,GAArC,EAA0C2H,IAA1C,CAAP;A5BIF,ADCA,A6BJC,QZ0KC,IAAI,aAAa,GAAW,AHbvB,CGawB,CAAC,aAAa,CAAC,gGHbyE;AbzJvH,ADCA,QiBuKE,IAAI,WAAW,EHdV,CGca,CAAC,cAAc,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;AhBvK9G,ADCA,A6BJA,IAAIC,IZ4KF,IAAI,SHdA,IGca,GY5KS,EZ4KJ,CAAC,AY5KM,CZ4KL,EAAE,IY5KUC,MAAP,KAAkB,WAAlB,GAAgCA,MAAM,CAAC,uBAAD,CAAtC,GAAkEC,SAAjG;A5BIA,ADCA,YiBwKG,KHdE,0CGc6C;AhBxKlD,ADCA,A6BJA5N,OAAO,CAAC6N,IZ4KL,IAAI,CY5KP,GAAoB,Cf6JT,KGeM,GAAiB,AY5KLA,KZ4KU,CAAC,GY5KpB,CAAmBC,GZ4KQ,CAAC,IY5K5B,EAA6B,CZ4KM,CAAC,CAAC;AhBxKzD,ADCA,A6BJE,MAAI,MZ6KH,CY7KUA,GZ6KN,IHhBF,Ce7JC,KAAoB,Gf6JZ,GAAG,Ie7Jf,CZ6KkB,CY5KhB,CZ4KkB,IHhBM,CAAC,Ae5JnB,IAAIC,SAAJ,CAAc,Gf4JsB,CAAC,OAAO,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC,iBe5JlE,CAAN;A5BGJ,ADCA,gBiByKI,CHhBC,MGgBM,CAAC,GAAG,CAAC,YAAY,GAAG,UAAU,CAAC,SAAS,GAAG,KAAK,GAAG,UAAU,CAAC,cAAc,CAAC,CAAC;AhBzKzF,ADCA,A6BHE,MAAIL,OZ4KF,GHfA,IAAI,SAAS,Ce7Ja,If6JR,Ae7JYI,Cf6JX,CAAC,EAAE,Ie7JgB,CAACJ,wBAAD,CAAxC,EAAoE;A5BGtE,ADCA,A6BHI,QAAItG,EAAE,EZ6KP,CY7KU0G,Of6JR,Ce7JgB,CZ6KR,AY7KSJ,CZ6KR,CHhBL,GAAG,GGgBS,CAAC,EHhBJ,CAAC,EGgBQ,EAAE,GHhBH,CAAC,Ie7JN,CAAjB,If6JgC,CGgBO,AHhBN,CGgBO,AHhBN,CGgBO,CAAC,CAAC,KAAK,CAAC,CAAC;AhB1KtD,ADCA,YiB0KG,KAAK,GAAG,AHfN,KGeW,CAAC,EHfJ,GAAG,KAAK,CAAC,aGemB,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;AhB1KhE,ADCA,A6BJI,QAAI,IZ8KL,GY9KYtG,EAAP,GfgKH,EehKiB,EfgKb,EGcQ,CAAC,CHdL,IehKT,EZ8KqB,AY9KS,EZ8KP,IHdF,IGcU,EAAE,SHdG,EGcQ,EAAE,AHdN,IAAI,CGcO,EAAE,SHdG,CGcO,EAAE,SHdG,CGcO,CAAC,EHdJ,IAAI,KGcW,EAAE,KHdD,SGce,CAAC,CAAC,GHdH,EAAE;Ab5J5G,ADCA,A6BJM,YZ8KH,AY9KS,IAAI2G,MZ8KH,CAAC,CHdR,CehKM,CAAc,EfgKhB,EGcW,CAAC,CHdR,CAAC,GGcY,EAAE,aHdI,CGcU,CAAC,CAAC,CAAC,AHdT,CGcU,GAAG,AHdT,CGcU,AHdT,CGcU,OHdF,CAAC,MAAM,KAAK,CAAC,EAAE,MehKrD,CAAN;A5BIN,ADCA,A6BJK,YZ+KF,MAAM,UHfF,QAAQ,GAAG,IAAI,CAAC;Ab5JvB,ADCA,YiB2KG,IAAI,MAAM,GAAG,AHfT,KGec,CAAC;AhB3KtB,ADCA,A6BLInJ,IAAAA,MAAM,CAACoJ,CZgLR,KAAK,GAAG,CHfL,IGeU,AYhLZ,CZgLa,AYhLS5G,EAAtB,CZgLgB,CYhLUsG,CZgLR,CAAC,sBYhLnB,EAAoD;A5BKxD,ADCA,A6BLMnJ,MAAAA,KAAK,CZiLR,CYjLU6C,EAD2C,CZkLjD,CAAC,GHfH,IAAI,IGeU,IAAI,AHfN,EAAE,IGeU,CAAC,WAAW,EAAE,KAAK,OAAO,EAAE;AhB5KzD,ADCA,A6BNiB6G,MAAAA,UZkLb,AYlLuB,EAAE,KAD2B,CfoKlD,2CGeiD,qCHf+B;Ab7JtF,ADCA,A6BPoCC,MAAAA,QAAQ,EZmLxC,AYnL0C,KADU,EZoL7C,CAAC,AHfN,KGeW,CAAC,GHfH,qFGe2F,CAAC,CAAC;AhB5K5G,ADCA,A6BRqDC,MAAAA,UZqLjD,EYrL6D,EAAE,CfqK7D,wDGgB2D;AhB7KjE,ADCA,A6BVwD,KAApD,WZuLA,IHfC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,+EGekF;AhB7KzG,ADCA,A6BRI,WAAO/G,EAAP,GZqLA,CHfC,IGeI,GAAG,MAAM,CAAC;AhB7KnB,ADCA,A6BRG,afsKC,GGgBA,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AhB9K1C,ADCA,Sc8JG,OGgBC,IAAI,GAAG,IAAI,CAAC;AhB9KhB,ADCA,A6BRE,QfuKA,GevKSA,EAAT,EfuKO,CGeL,AYtLY,OZsLL;AhB9KX,ADCA,A6BRI,QAAIgH,IfuKL,CGeC,OHfO,EAAE,AevKT,CfuKU,CevKUC,aAApB;A5BQJ,ADCA,A6BRI,QAAIC,CZsLL,GHfA,GevKY,GAAG,IAAIpK,OAAJ,CfuKG,AevKS,EfuKP,CAAC,CAAC,MevKeC,EfuKP,CAAC,CAAC,CAAC,EevKN,EAAmBC,IfuKL,CAAC,CevKf,EAA2B,GfuKN,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC;Ab/JtE,ADCA,A6BRMgK,MAAAA,GfuKH,CAAC,GGcK,OYrLW,GAAGjK,OAAjB;A5BQN,ADCA,A6BRMkK,IfuKL,CAAC,CevKIA,MZqLH,OYrLgB,GAAGjK,MAAhB,KZqLkB;AhB7KxB,ADCA,A6BRK,IfuKL,Ce1KkB,CAAd,MZwLD,IAAI,KAAK,CHdX,EGcc,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;AHd9C,Ab/JA,ADCA,A6BPI,Cf3BJ,AAgMC,IAAA,GerKO1C,IZqLL,AYrLS,GAAG,EAAX,KZqLS,CAAC,OAAO,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AHhNzC,AbkCb,ADCA,YiB+KG,IAAI,UAAU,GAAG,KAAK,AHlND,CGkNE;AhB/K1B,ADCA,A6BRI,SAAK,GZuLN,CYvLUG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,SAAS,CAACT,MZuLH,AYvL3B,EAAsCU,CAAC,EAAvC,EAA2C;A5BQ/C,ADCA,A6BRMH,MAAAA,IAAI,CAACI,CZuLR,GYvLG,CZuLC,AYvLSF,SZuLA,AYvLS,CAACC,CAAD,CZuLN,AYvLb,KZuLkB,CAAC,OAAO,CAAC,gBAAS,CAAC,QAAQ,CAAC,EAAE,cAAc,CAAC,CAAC;AhB/KtE,ADCA,A6BRK,YZuLF,IAAI,cAAc,GAAG,KAAK,CAAC,qBAAqB,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;AhB/K7E,ADCA,YiB+KG,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,aAAa,EAAE,OAAO,EAAE,IAAI,EAAE,cAAc,EAAE,cAAc,CAAC,CAAC;AhB/KpF,ADCA,A6BTIH,IAAAA,IAAI,CAACI,GZyLN,CYzLC,CAAU,EZyLP,KAAK,GYzLYyM,GAAV,EAAehK,IZyLL,CYzLV,EAAsB,gBZyLA,EAAE;AhBhLtC,ADCA,A6BTM,UAAIgK,GAAJ,EAAS,CZyLX,IAAI,UAAU,GAAiB,KAAK,CAAC;AhBhLzC,ADCA,A6BTQF,QAAAA,QZyLJ,IAAI,CYzLa,CAACE,GAAD,CAAb,eZyLa,EAAE;AhBhLvB,ADCA,A6BTO,OAFD,MAEO,OZyLR,OAAO,CAAC,GAAG,CAAC,YAAY,GAAG,UAAU,CAAC,SAAS,GAAG,KAAK,GAAG,UAAU,CAAC,gBAAgB,CAAC,CAAC;AhBhL5F,ADCA,A6BTQH,QAAAA,SZyLH,KYzLiB,CAAC7J,KAAD,CAAd;A5BSR,ADCA,A6BTO,gBZ0LH,cAAc,CAAC,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,KAAK,EAAE,UAAU,EAAE,UAAU,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC;AhBjLhH,ADCA,A6BTK,KAND,WZgMA,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AhBjLrD,ADCA,gBiBiLI,cAAc,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;AhBjL3C,ADCA,A6BTI,QAAI,QZ2LJ,IAAI,WAAW,GAAG,UAAU,CAAC,cAAc,CAAC,gBAAS,CAAC,QAAQ,CAAC,EAAE,cAAc,CAAC,CAAC;AhBlLrF,ADCA,A6BTMuJ,MAAAA,QAAQ,CAAC5L,CZ2LX,IAAI,AY3LF,CAAe,IAAf,EAAqBR,IAArB,UZ2LuB,GAAG,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AhBlL1E,ADCA,A6BTK,KAFD,CAEE,OAAO6M,GZ2LT,AY3LE,EAAY,GZ2LT,GAAG,KAAK,CAAC,wBAAwB,CAAC,qBAAqB,CAAC,CAAC;AhBlLlE,ADCA,A6BTMF,MAAAA,UZ4LF,GY5Le,CZ4LX,AY5LYE,GAAD,CAAb,MZ4LY,CAAC,oBAAoB,EAAE;AhBnLzC,ADCA,A6BTK,oBZ4LA,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,UAAU,CAAC,gCAAgC,CAAC,gBAAS,CAAC,QAAQ,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC;AhBnLhH,ADCA,iBiBmLK;AhBnLL,ADCA,A6BTI,WAAOD,KZ6LP,EY7LA,EZ6LI,CAAC,WAAW,IAAI,UAAU,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE;AhBpLzD,ADCA,A6BTG,oBZ6LE,iDAAiD;AhBpLtD,ADCA,oBiBoLK,OAAO,CAAC,KAAK,CAAC,sFAAsF,CAAC,CAAC;AhBpL3G,ADCA,A6BTE1J,EAAAA,MAAM,CAACa,WZ6LJ,GY7LH,CAAsB2B,CZ6Ld,CY7LR,EZ6LW,AY7LexC,KZ6LV,CAAC,AY7Le,CAAC4J,EZ6Lb,EAAE,CAAC,SY7LG,CAAsBV,QAAtB,CAA1B;A5BSF,ADCA,A6BRE,MAAIJ,cZ4LD,UAAU,AY5Lb,CZ4Lc,CY5LgB9I,MZ4LT,AY5Le,CZ4Ld,AY5LeoJ,KZ4LV,EAAE,OY5LC,CAAsB5G,EZ4Lb,AY5LT,CZ4LU,CAAC,AY5LesG,wBAA1B,EAAoD;A5BQpF,ADCA,A6BRInJ,IAAAA,KAAK,EAAE6C,EADyE,OZ6L/E,IAAI,GAAG,IAAI,CAAC;AhBpLjB,ADCA,A6BTe6G,IAAAA,UAAU,EAAE,IZ6LtB,CY9L+E,MZ8LxE;AhBpLZ,ADCA,A6BVkCC,IAAAA,QAAQ,EAAE,GZ8LvC,EY/L+E;A5BWpF,ADCA,A6BXmDC,IAAAA,SZ+L/C,GY/L2D,EAAE;A5BWjE,ADCA,A6BboF,GAApD,cZgMtB,IAAI,KAAK,YAAY,qBAAc,EAAE;AhBnL/C,ADCA,A6BXE,SAAOvJ,MAAM,CZ8LX,AY9LYC,IZ8LR,UAAU,EY9LT,CZ8L4B,AY7LjCuC,EADK,EAELvB,CZ4LsC,CAAC,uBY5Ld,CAACiI,QAAD,CAFpB,CAAP;A5BWF,ADCA,A6BRC,CApDD,eZ+OI,IAAI,qBAAa,EAAE;AhBnLvB,ADCA,oBiBmLK,OAAO,CAAC,GAAG,CAAC,YAAY,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC;AhBnLtD,ADCA,A6BRA9N,OAAO,CAAC6N,SZ2LH,AY3LL,CAAkBY,MAAlB,GAA2Bf,wBAA3B;A5BQA,ADCA,gBiBoLI,cAAc,CAAC,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,KAAK,EAAE,UAAU,EAAE,UAAU,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC;AhBpLhH,ADCA,A6BRA,SAASgB,OZ4LL,UAAU,CAAC,GY5Lf,CAA+BhL,GZ4LT,CAAC,EY5LvB,EAAuCiL,CZ4LX,CY5L5B,CZ4L8B,CY5La,aZ4LC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AhBpLrD,ADCA,A6BRE,gBZ4LE,cAAc,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;AhBpL3C,ADCA,A6BRE,gBZ4LE,IAAI,WAAW,GAAG,UAAU,CAAC,cAAc,CAAC,gBAAS,CAAC,QAAQ,CAAC,EAAE,cAAc,CAAC,CAAC;AhBpLrF,ADCA,A6BRE,gBZ4LE,IAAI,qBAAqB,GAAG,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AhBpL1E,ADCA,A6BRE,gBZ4LE,KAAK,GAAG,KAAK,CAAC,wBAAwB,CAAC,qBAAqB,CAAC,CAAC;AhBpLlE,ADCA,A6BRE,MAAI,CAACjL,MAAL,EAAa,CZ6LX,IAAI,UAAU,CAAC,sBAAsB,EAAE;AhBrL3C,ADCA,A6BRI,QAAIkL,SAAS,GZ6LZ,AY7Le,IAAIxO,CZ6Ld,GAAG,CY7LO,CAAU,GZ6LZ,CAAC,UAAU,CAAC,UAAU,CAAC,eY7LrB,CAAhB,kBZ6LuE,CAAC,gBAAS,CAAC,QAAQ,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC;AhBrLlH,ADCA,A6BRIwO,IAAAA,SAAS,CAAClL,GZ6LT,GY7LD,GAAmBA,MAAnB;A5BQJ,ADCA,A6BRIA,IAAAA,MAAM,GAAGkL,GZ8LT,IAAI,CAAC,CY9LL,UZ8LgB,IAAI,UAAU,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE;AhBtLzD,ADCA,A6BRG,oBZ8LE,iDAAiD;AhBtLtD,ADCA,oBiBsLK,OAAO,CAAC,KAAK,CAAC,sFAAsF,CAAC,CAAC;AhBtL3G,ADCA,A6BTE,SAAOD,EAAE,CAACjL,MAAD,CAAT,CZ+LG,KAAK,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;AhBtLzB,ADCA,A6BTC,oBZ+LI,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AhBtL3C,ADCA,oBiBsLK,IAAI,GAAG,IAAI,CAAC;AhBtLjB,ADCA,A6BTA,SAASmL,WZ+LJ,AY/LL,CAAqBf,MZ+LT,EY/LZ,EAA+B;A5BS/B,ADCA,A6BTE,MAAI,OAAOA,IZ+LR,IY/LC,KAAoB,UAAxB,EAAoC;A5BStC,ADCA,A6BTI,UAAM,GZ+LN,CY/LUC,SAAJ,CAAc,kDAAd,CAAN;A5BSJ,ADCA,A6BTG,GAH4B,CAK7B,aZ4LQ;AhBrLV,ADCA,A6BPE,gBZ4LE,IAAI,YAAY,GAAc,KAAK,CAAC;AhBrLxC,ADCA,A6BPE,gBZ4LE,IAAI,qBAAa,EAAE;AhBrLvB,ADCA,oBiBqLK,OAAO,CAAC,GAAG,CAAC,YAAY,GAAG,YAAY,CAAC,SAAS,GAAG,KAAK,GAAG,YAAY,CAAC,gBAAgB,CAAC,CAAC;AhBrLhG,ADCA,iBiBqLK;AhBrLL,ADCA,A6BTE,WAASe,KZ+LP,QY/LF,GAAyB,GZ+LT,CAAC,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,KAAK,EAAE,UAAU,EAAE,YAAY,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC;AhBtL7G,ADCA,A6BTI,QAAIpN,IAAI,GAAG,CZ+LX,CY/LA,SZ+LU,CAAC,OAAO,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AhBtLrD,ADCA,gBiBuLI,+CAA+C;AhBvLnD,ADCA,A6BVI,SAAK,IAAIG,CAAC,EZiMV,CYjMa,CAAb,EAAgBA,CZiMX,AYjMY,GZiMT,AYjMYD,KZiMP,CAAC,GAAG,AYjMY,CAACT,CZiMX,CAAC,IYjMpB,EAAsCU,CAAC,EAAvC,EAA2C;A5BU/C,ADCA,A6BVMH,MAAAA,IAAI,CAACI,IAAL,CZkMF,AYlMYF,IZkMR,CAAC,IYlMgB,CAACC,CAAD,CAAnB,IZkMc,EAAE;AhBxLtB,ADCA,A6BVK,oBZkMA,sDAAsD;AhBxL3D,ADCA,oBiBwLK,OAAO,CAAC,KAAK,CAAC,2FAA2F,CAAC,CAAC;AhBxLhH,ADCA,A6BVI,QAAIkN,OAAO,GAAGrN,EZkMb,EYlMiB,CAACyJ,EZkMb,CYlMQ,EZkML,AYlMT,KZkMc,CAAC,OAAO,EAAE,CAAC;AhBxL7B,ADCA,oBiBwLK,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AhBxL3C,ADCA,A6BXI,QAAI,OAAO4D,KZmMV,EYnMG,EZmMC,GAAG,AYnMe,IZmMX,CAAC,KYnMb,EAAmC;A5BWvC,ADCA,A6BXM,YAAM,IAAIhB,IZmMX,KYnMO,CAAc,CZmMd,2CYnMA,CAAN;A5BWN,ADCA,A6BXK,iBZmMA;AhBxLL,ADCA,aiBwLI;AhBxLJ,ADCA,A6BZI,QAAIiB,CZoML,GYpMS,GAAG,IAAX;A5BYJ,ADCA,QiByLE,IAAI,cAAc,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,OAAO,EAAE;AhBzLvC,ADCA,A6BbI,QAAIL,EAAE,EZsMP,CYtMU,YAAW,IZsMJ;AhBzLpB,ADCA,A6BbM,YZsMH,CYtMUI,MZsMH,CYtMU,CAAC7M,CZsMR,IYtMA,CAAc8M,IAAd,EAAoBpN,GZsMN,CAAC,CAAC,CAAC,CAAC,EYtMlB,CZsMqB,AYtM5B,CZsM6B;AhBzLnC,ADCA,A6BbK,KAFD,CAXuB,CAcvB,KZqMD,WAAW,GAAG,KAAK,CAAC;AhBzLvB,ADCA,A6BZI,SZqMD;AhBzLH,ADCA,IiByLC,CAAC;AhBzLF,ADCA,IiB0LC,OAAO,KAAK,CAAC;AACd,AhB3LA,ADCA,A6BdIkM,CZwMH,GYxMGA,QAAQ,CAAC5L,KAAT,CAAe,IAAf,EAAqBR,IAArB,EACG0D,IADH,CACQ,UAASyE,GAAT,EAAc;AZ0M1B,AhB7LA,ADCA,A6Bd4B/J,MAAAA,OAAO,CAAC2B,QAAR,CAAiBkN,EAAjB,EAAqB,IAArB,EAA2B9E,GAA3B;A5Bc5B,ADCA,A6Bf6D,IZ0M7D,CY3MI,EAEQ,UAASoF,GAAT,EAAc;A5Bc1B,ADCA,A6Bf4BnP,IZsR5B,CAAC,CYtR2BA,OAAO,CAAC2B,QAAR,CAAiBiN,qBAAjB,EAAwCO,GAAxC,EAA6CN,EAA7C;A5Be5B,ADCA,A6BhB8E,IZ2M/D,CY7MX,+BZ6MsB,GAAzB,UAA0B,QAAgB;AhB3L3C,ADCA,A6BhBG,QZ2MD,IAAI,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;AhB3L/B,ADCA,QiB2LE,OAAO,CAAC,CAAC,MAAM,GAAG,EAAE,EAAE;AhB3LxB,ADCA,A6BhBE/J,EAAAA,MAAM,CAACa,GZ2MN,CAAC,GAAG,GAAG,GAAG,CAAC,AY3MZ,CZ2Ma,AY3MSqJ,aAAtB,EAAqClK,MAAM,CAAC4J,cAAP,CAAsBV,QAAtB,CAArC;A5BgBF,ADCA,A6BhBElJ,EAAAA,MAAM,CZ2ML,AY3MMC,gBAAP,CAAwBiK,aAAxB,EACwBjJ,yBAAyB,CAACiI,QAAD,CADjD;A5BgBF,ADCA,A6BfE,QZ0MA,CY1MOgB,MZ0MA,CAAC,CAAC,KY1MT;A5BeF,ADCA,A6BfC,IZ0MA,CAAC;AhB3LF,ADCA,IiB4Le,kCAAa,GAA3B,UAA4B,QAAgB;AhB5L7C,ADCA,A6BhBA9O,OAAO,CZ4ML,AY5MM6O,IZ4MF,OY5MN,GZ4MgB,AY5MMA,GZ4MH,QY5MnB,YZ4MuC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AhB5LhE,ADCA,QiB4LE,IAAI,SAAS,GAAG,oBAAoB,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;AhB5L9D,ADCA,QiB4LE,IAAI,SAAS,GAAG,oBAAoB,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;AhB5L9D,ADCA,QiB4LE,IAAI,UAAU,GAAG,oBAAoB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AhB5LhE,ADCA,QiB4LE,IAAI,UAAU,GAAG,oBAAoB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AhB5LhE,ADCA,QiB6LE,OAAO,CAAC,GAAG,CAAC;AhB7Ld,ADCA,YiB6LG,UAAU,EAAE,UAAU;AhB7LzB,ADCA,YiB6LG,SAAS,EAAE,SAAS;AhB7LvB,ADCA,YiB6LG,SAAS,EAAE,SAAS;AhB7LvB,ADCA,YiB6LG,UAAU,EAAE,UAAU;AhB7LzB,ADCA,YiB6LG,UAAU,EAAE,UAAU;AhB7LzB,ADCA,SiB6LG,CAAC,CAAC;AhB7LL,ADCA,IiB6LC,CAAC;AhB7LF,ADCA,IiB8Le,kCAAa,GAA3B,UAA4B,QAAgB;AhB9L7C,ADCA,QiB8LE,OAAO,CAAC,QAAQ,4BAAiC,CAAC,8BAAqC,CAAC;AhB9L1F,ADCA,IiB8LC,CAAC;AhB9LF,ADCA,IiB+Le,iCAAY,GAA1B,UAA2B,QAAgB;AhB/L5C,ADCA,QiB+LE,OAAO,CAAC,QAAQ,6BAAiC,CAAC,8BAAqC,CAAC;AhB/L1F,ADCA,IiB+LC,CAAC;AhB/LF,ADCA,IiBgMe,iCAAY,GAA1B,UAA2B,QAAgB;AhBhM5C,ADCA,QiBgME,OAAO,CAAC,QAAQ,8BAAiC,CAAC,+BAAqC,CAAC;AhBhM1F,ADCA,IiBgMC,CAAC;AhBhMF,ADCA,IiBiMe,kCAAa,GAA3B,UAA4B,QAAgB;AhBjM7C,ADCA,QiBiME,OAAO,CAAC,QAAQ,gCAAiC,CAAC,+BAAqC,CAAC;AhBjM1F,ADCA,IiBiMC,CAAC;AhBjMF,ADCA,IiBkMe,kCAAa,GAA3B,UAA4B,QAAgB;AhBlM7C,ADCA,QiBkME,OAAO,CAAC,QAAQ,mCAAiC,CAAC,+BAAqC,CAAC;AhBlM1F,ADCA,IiBkMC,CAAC;AhBlMF,ADCA,IiBmMe,wBAAG,GAAjB,UAAkB,QAAgB,EAAE,UAAkB,EAAE,SAAqC,EAAE,SAAoB,EAAE,UAAkB,EAAE,UAAkB;AhBnM5J,ADCA,QiBmME,IAAI,WAAW,GAAG,oBAAoB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AhBnMjE,ADCA,QiBmME,IAAI,UAAU,GAAG,oBAAoB,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;AhBnM/D,ADCA,QiBmME,IAAI,UAAU,GAAG,oBAAoB,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;AhBnM/D,ADCA,QiBmME,IAAI,WAAW,GAAG,oBAAoB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AhBnMjE,ADCA,QiBmME,IAAI,WAAW,GAAG,oBAAoB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AhBnMjE,ADCA,QiBoME,IAAI,UAAU,KAAK,CAAC,EAAE;AhBpMxB,ADCA,YiBoMG,WAAW,GAAG,UAAU,CAAC;AhBpM5B,ADCA,SiBoMG;AhBpMH,QgBqME,IAAI,SAAS,kBAAqC,EAAE;AhBpMtD,YgBqMG,UAAU,GAAG,SAAS,yBAA4C,CAAC,CAAC,eAAyB,CAAC,CAAC,SAAS,CAAC;AhBpM5G,SgBqMG;AhBpMH,QgBqME,IAAI,SAAS,oBAAqB,EAAE;AhBpMtC,YgBqMG,UAAU,GAAG,SAAS,CAAC;AhBpM1B,SgBqMG;AhBpMH,QgBqME,IAAI,UAAU,KAAK,CAAC,EAAE;AhBpMxB,YgBqMG,WAAW,GAAG,UAAU,CAAC;AhBpM5B,SgBqMG;AhBpMH,QgBqME,IAAI,UAAU,KAAK,CAAC,EAAE;AhBpMxB,YgBqMG,WAAW,GAAG,UAAU,CAAC;AhBpM5B,SgBqMG;AhBpMH,QgBsME,OAAO,CACN,CAAC,WAAW,6BAAoC,CAAC;AhBtMpD,cgBuMK,CAAC,UAAU,6BAAoC,CAAC;AhBtMrD,cgBuMK,CAAC,UAAU,8BAAoC,CAAC;AhBtMrD,cgBuMK,CAAC,WAAW,8BAAoC,CAAC;AhBtMtD,cgBuMK,CAAC,WAAW,8BAAoC,CAAC,CACnD,KAAK,CAAC,CAAC;AhBvMV,IgBwMC,CAAC;AhBvMF,IgBwMA,2BAAC;AAAD,AhBvMA,CgB0HA,AA6EC,IAAA;AA7EY,AhBzHb,oDgByHiC;AA+EjC,AhBvMA;AACA,IgB6MC,0BAAY,MAAwB,EAAE,KAAa,EAAE,QAAgB;AhB5MtE,QgB6ME,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AhB5MvB,QgB6ME,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AhB5MrB,QgB6ME,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AhB5M3B,IgB6MC,CAAC;AhB5MF,IgB8MgB,wBAAO,GAAtB,UAAuB,CAAmB,EAAE,CAAmB;AhB7MhE,QgB8ME,GAAG;AhB7ML,YgB8MG,IAAI,CAAC,KAAK,CAAC,EAAE;AhB7MhB,gBgB8MI,OAAO,IAAI,CAAC;AhB7MhB,agB8MI;AhB7MJ,YgB+MG,IAAI,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,QAAQ,EAAE;AhB9MzD,gBgB+MI,OAAO,KAAK,CAAC;AhB9MjB,agB+MI;AhB9MJ,YgBgNG,sBAAsB;AhB/MzB,YgBgNG,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;AhB/MhB,YgBgNG,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;AhB/MhB,YgBiNG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE;AhBhNjB,gBgBiNI,+BAA+B;AhBhNnC,gBgBiNI,OAAO,IAAI,CAAC;AhBhNhB,agBiNI;AhBhNJ,YgBkNG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE;AhBjNjB,gBgBkNI,mCAAmC;AhBjNvC,gBgBkNI,OAAO,KAAK,CAAC;AhBjNjB,agBkNI;AhBjNJ,SgBmNG,QAAQ,IAAI,EAAE;AhBlNjB,IgBmNC,CAAC;AhBlNF,IgBoNQ,iCAAM,GAAb,UAAc,KAAuB;AhBnNtC,QgBoNE,OAAO,gBAAgB,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AhBnN/C,IgBoNC,CAAC;AhBnNF,IgBqNgB,8BAAa,GAA5B,UAA6B,KAAa,EAAE,QAAgB,EAAE,eAAuB;AhBpNtF,QgBqNE,OAAO,CAAC,QAAQ,KAAK,KAAK,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,eAAe,CAAC,MAAM,CAAC,KAAK,eAAe,CAAC,CAAC;AhBpNhG,IgBqNC,CAAC;AhBpNF,IgBsNgB,yBAAQ,GAAvB,UAAwB,MAAwB,EAAE,YAAsB;AhBrNzE,QgBsNE,IAAI,YAAY,KAAK,IAAI,EAAE;AhBrN7B,YgBsNG,OAAO,IAAI,CAAC;AhBrNf,SgBsNG;AhBrNH,QgBuNE,IAAI,GAAG,GAAG,YAAY,CAAC,MAAM,CAAC;AhBtNhC,QgBuNE,IAAI,KAAK,GAAG,CAAC,CAAC;AhBtNhB,QgBuNE,IAAI,QAAQ,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;AhBtNrC,QgBuNE,IAAI,eAAe,GAAG,QAAQ,GAAG,GAAG,CAAC;AhBtNvC,QgBwNE,OAAO,MAAM,EAAE;AhBvNjB,YgBwNG,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,EAAE,QAAQ,EAAE,eAAe,CAAC,EAAE;AhBvNpE,gBgBwNI,KAAK,EAAE,CAAC;AhBvNZ,gBgBwNI,IAAI,KAAK,KAAK,GAAG,EAAE;AhBvNvB,oBgBwNK,OAAO,IAAI,CAAC;AhBvNjB,iBgBwNK;AhBvNL,gBgBwNI,QAAQ,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;AhBvNnC,gBgBwNI,eAAe,GAAG,QAAQ,GAAG,GAAG,CAAC;AhBvNrC,agBwNI;AhBvNJ,YgBwNG,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;AhBvN1B,SgBwNG;AhBvNH,QgByNE,OAAO,KAAK,CAAC;AhBxNf,IgByNC,CAAC;AhBxNF,IgB0Ne,8BAAa,GAA3B,UAA4B,QAAgB,EAAE,UAA4B,EAAE,MAAqB;AhBzNlG,QgB0NE,IAAI,MAAM,KAAK,IAAI,EAAE;AhBzNvB,YgB0NG,OAAO,QAAQ,CAAC;AhBzNnB,SgB0NG;AhBzNH,QgB2NE,IAAI,SAAS,kBAAmB,CAAC;AhB1NnC,QgB2NE,IAAI,UAAU,GAAG,CAAC,CAAC;AhB1NrB,QgB2NE,IAAI,UAAU,GAAG,CAAC,CAAC;AhB1NrB,QgB4NE,IAAI,MAAM,CAAC,SAAS,KAAK,IAAI,EAAE;AhB3NjC,YgB4NG,wCAAwC;AhB3N3C,YgB4NG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AhB3NhE,gBgB4NI,IAAI,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AhB3NxC,gBgB6NI,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,SAAS,CAAC,YAAY,CAAC,EAAE;AhB5N3D,oBgB6NK,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC;AhB5NrC,oBgB6NK,UAAU,GAAG,SAAS,CAAC,UAAU,CAAC;AhB5NvC,oBgB6NK,UAAU,GAAG,SAAS,CAAC,UAAU,CAAC;AhB5NvC,oBgB6NK,MAAM;AhB5NX,iBgB6NK;AhB5NL,agB6NI;AhB5NJ,SgB6NG;AhB5NH,QgB8NE,OAAO,oBAAoB,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC,SAAS,EAAE,SAAS,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;AhB7NpH,IgB8NC,CAAC;AhB7NF,IgB+NgB,sBAAK,GAApB,UAAqB,MAAwB,EAAE,OAAgB,EAAE,MAAgB;AhB9NlF,QgB+NE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AhB9NrD,YgB+NG,IAAI,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AhB9NzB,YgB+NG,IAAI,WAAW,GAAG,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;AhB9NxD,YgB+NG,IAAI,QAAQ,GAAG,gBAAgB,CAAC,aAAa,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;AhB9NvF,YgB+NG,MAAM,GAAG,IAAI,gBAAgB,CAAC,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;AhB9N1D,SgB+NG;AhB9NH,QgB+NE,OAAO,MAAM,CAAC;AhB9NhB,IgB+NC,CAAC;AhB9NF,IgBgOQ,+BAAI,GAAX,UAAY,OAAgB,EAAE,KAAa;AhB/N5C,QgBgOE,IAAI,KAAK,KAAK,IAAI,EAAE;AhB/NtB,YgBgOG,OAAO,IAAI,CAAC;AhB/Nf,SgBgOG;AhB/NH,QgBgOE,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AhB/N/B,YgBgOG,oCAAoC;AhB/NvC,YgBgOG,OAAO,gBAAgB,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;AhB/NnE,SgBgOG;AhB/NH,QgBgOE,kCAAkC;AhB/NpC,QgBgOE,OAAO,gBAAgB,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;AhB/NxD,IgBgOC,CAAC;AhB/NF,IgBiOgB,gCAAe,GAA9B,UAA+B,UAA4B;AhBhO5D,QgBiOE,IAAI,MAAM,GAAa,EAAE,EAAE,SAAS,GAAG,CAAC,CAAC;AhBhO3C,QgBiOE,OAAO,UAAU,EAAE;AhBhOrB,YgBiOG,MAAM,CAAC,SAAS,EAAE,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC;AhBhO1C,YgBiOG,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC;AhBhOlC,SgBiOG;AhBhOH,QgBiOE,MAAM,CAAC,OAAO,EAAE,CAAC;AhBhOnB,QgBiOE,OAAO,MAAM,CAAC;AhBhOhB,IgBiOC,CAAC;AhBhOF,IgBkOQ,yCAAc,GAArB;AhBjOD,QgBkOE,OAAO,gBAAgB,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;AhBjOhD,IgBkOC,CAAC;AhBjOF,IgBkOA,uBAAC;AAAD,AhBjOA,CgB2FA,AAsIC,IAAA;AAtIY,AhB1Fb,4CgB0F6B;AAwI7B,AhBjOA;AACA;AACA,GgBiOG;AACH,AhBjOA;AACA,IgBuQC,sBAAY,MAAoB,EAAE,MAAc,EAAE,QAAgB,EAAE,OAAe,EAAE,cAAgC,EAAE,qBAAuC;AhBtQ/J,QgBuQE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AhBtQvB,QgBuQE,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AhBtQzD,QgBuQE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AhBtQvB,QgBuQE,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;AhBtQ5B,QgBuQE,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;AhBtQzB,QgBuQE,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;AhBtQvC,QgBuQE,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;AhBtQrD,IgBuQC,CAAC;AhBtQF,IgBwQC;AhBvQD;AACA,OgBwQI;AhBvQJ,IgBwQgB,8BAAiB,GAAhC,UAAiC,CAAe,EAAE,CAAe;AhBvQlE,QgBwQE,GAAG;AhBvQL,YgBwQG,IAAI,CAAC,KAAK,CAAC,EAAE;AhBvQhB,gBgBwQI,OAAO,IAAI,CAAC;AhBvQhB,agBwQI;AhBvQJ,YgByQG,IAAI,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,OAAO,KAAK,CAAC,CAAC,OAAO,EAAE;AhBxQhF,gBgByQI,OAAO,KAAK,CAAC;AhBxQjB,agByQI;AhBxQJ,YgB0QG,sBAAsB;AhBzQzB,YgB0QG,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;AhBzQhB,YgB0QG,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;AhBzQhB,YgB2QG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE;AhB1QjB,gBgB2QI,+BAA+B;AhB1QnC,gBgB2QI,OAAO,IAAI,CAAC;AhB1QhB,agB2QI;AhB1QJ,YgB4QG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE;AhB3QjB,gBgB4QI,mCAAmC;AhB3QvC,gBgB4QI,OAAO,KAAK,CAAC;AhB3QjB,agB4QI;AhB3QJ,SgB6QG,QAAQ,IAAI,EAAE;AhB5QjB,IgB6QC,CAAC;AhB5QF,IgB8QgB,oBAAO,GAAtB,UAAuB,CAAe,EAAE,CAAe;AhB7QxD,QgB8QE,IAAI,CAAC,KAAK,CAAC,EAAE;AhB7Qf,YgB8QG,OAAO,IAAI,CAAC;AhB7Qf,SgB8QG;AhB7QH,QgB8QE,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;AhB7QrC,YgB8QG,OAAO,KAAK,CAAC;AhB7QhB,SgB8QG;AhB7QH,QgB8QE,OAAO,CAAC,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC;AhB7QjE,IgB8QC,CAAC;AhB7QF,IgB+QQ,4BAAK,GAAZ;AhB9QD,QgB+QE,OAAO,IAAI,CAAC;AhB9Qd,IgB+QC,CAAC;AhB9QF,IgBgRQ,6BAAM,GAAb,UAAc,KAAmB;AhB/QlC,QgBgRE,IAAI,KAAK,KAAK,IAAI,EAAE;AhB/QtB,YgBgRG,OAAO,KAAK,CAAC;AhB/QhB,SgBgRG;AhB/QH,QgBgRE,OAAO,YAAY,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AhB/Q3C,IgBgRC,CAAC;AhB/QF,IgBiRgB,mBAAM,GAArB,UAAsB,EAAgB;AhBhRvC,QgBiRE,OAAO,EAAE,EAAE;AhBhRb,YgBiRG,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;AhBhRrB,YgBiRG,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC;AhBhRlB,SgBiRG;AhBhRH,IgBiRC,CAAC;AhBhRF,IgBkRQ,4BAAK,GAAZ;AhBjRD,QgBkRE,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AhBjR5B,IgBkRC,CAAC;AhBjRF,IgBmRQ,0BAAG,GAAV;AhBlRD,QgBmRE,OAAO,IAAI,CAAC,MAAM,CAAC;AhBlRrB,IgBmRC,CAAC;AhBlRF,IgBoRQ,8BAAO,GAAd;AhBnRD,QgBoRE,IAAI,IAAI,CAAC,MAAM,EAAE;AhBnRnB,YgBoRG,OAAO,IAAI,CAAC,MAAM,CAAC;AhBnRtB,SgBoRG;AhBnRH,QgBoRE,OAAO,IAAI,CAAC;AhBnRd,IgBoRC,CAAC;AhBnRF,IgBqRQ,2BAAI,GAAX,UAAY,MAAc,EAAE,QAAgB,EAAE,OAAe,EAAE,cAAgC,EAAE,qBAAuC;AhBpRzI,QgBqRE,OAAO,IAAI,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,cAAc,EAAE,qBAAqB,CAAC,CAAC;AhBpRlG,IgBqRC,CAAC;AhBpRF,IgBsRQ,kCAAW,GAAlB;AhBrRD,QgBsRE,OAAO,IAAI,CAAC,SAAS,CAAC;AhBrRxB,IgBsRC,CAAC;AhBrRF,IgBuRQ,8BAAO,GAAd,UAAe,OAAsB;AhBtRtC,QgBuRE,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AhBtRtC,IgBuRC,CAAC;AhBtRF,IgBwRS,mCAAY,GAApB,UAAqB,GAAa,EAAE,QAAgB;AhBvRrD,QgBwRE,IAAI,IAAI,CAAC,MAAM,EAAE;AhBvRnB,YgBwRG,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AhBvRtD,SgBwRG;AhBvRH,QgByRE,GAAG,CAAC,QAAQ,EAAE,CAAC,GAAG,MAAI,IAAI,CAAC,MAAM,eAAU,IAAI,CAAC,cAAc,eAAU,IAAI,CAAC,qBAAqB,MAAG,CAAC;AhBxRxG,QgB0RE,OAAO,QAAQ,CAAC;AhBzRlB,IgB0RC,CAAC;AhBzRF,IgB2RQ,+BAAQ,GAAf;AhB1RD,QgB2RE,IAAI,CAAC,GAAa,EAAE,CAAC;AhB1RvB,QgB2RE,IAAI,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AhB1R1B,QgB2RE,OAAO,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC;AhB1RjC,IgB2RC,CAAC;AhB1RF,IgB4RQ,+CAAwB,GAA/B,UAAgC,qBAAuC;AhB3RxE,QgB4RE,IAAI,IAAI,CAAC,qBAAqB,KAAK,qBAAqB,EAAE;AhB3R5D,YgB4RG,OAAO,IAAI,CAAC;AhB3Rf,SgB4RG;AhB3RH,QgB4RE,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,cAAc,EAAE,qBAAqB,CAAC,CAAC;AhB3RjH,IgB4RC,CAAC;AhB3RF,IgB6RQ,iCAAU,GAAjB,UAAkB,OAAe;AhB5RlC,QgB6RE,IAAI,IAAI,CAAC,OAAO,KAAK,OAAO,EAAE;AhB5RhC,YgB6RG,OAAO,IAAI,CAAC;AhB5Rf,SgB6RG;AhB5RH,QgB6RE,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,EAAE,OAAO,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,qBAAqB,CAAC,CAAC;AhB5R9H,IgB6RC,CAAC;AhB5RF,IgB8RQ,oCAAa,GAApB,UAAqB,KAAmB;AhB7RzC,QgB8RE,OAAO,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,CAAC;AhB7RtC,IgB8RC,CAAC;AhB7RF,IgB0He,iBAAI,GAAG,IAAI,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AhBzHrE,IgB6RA,mBAAC;AhB5RD,CgBqHA,AAuKC,IAAA;AAvKY,AhBpHb,oCgBoHyB;AAyKzB,AhB5RA;AACA,IgB+RC,2BAAY,MAAwB,EAAE,MAAc;AhB9RrD,QgB+RE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AhB9RvB,QgB+RE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AhB9RvB,IgB+RC,CAAC;AhB9RF,IgB+RA,wBAAC;AAAD,AhB9RA,CgBsRA,AAQC,IAAA;AARY,AhBrRb,8CgBqR8B;AAe9B,AhBnSA;AACA,IgBsTC,oBAAY,gBAAyB,EAAE,QAAgB,EAAE,kBAAsC;AhBrThG,QgBsTE,IAAI,CAAC,iBAAiB,GAAG,gBAAgB,CAAC;AhBrT5C,QgBsTE,IAAI,CAAC,mBAAmB,GAAG,kBAAkB,CAAC;AhBrThD,QgBsTE,IAAI,qBAAa,EAAE;AhBrTrB,YgBsTG,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;AhBrT7B,SgBsTG;AhBrTH,QgBsTE,IAAI,IAAI,CAAC,iBAAiB,EAAE;AhBrT9B,YgBsTG,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;AhBrT3B,SgBsTG;AhBrTH,agBqTS;AhBpTT,YgBqTG,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;AhBpTrB,SgBqTG;AhBpTH,QgBqTE,IAAI,CAAC,kBAAkB,GAAG,CAAC,CAAC;AhBpT9B,IgBqTC,CAAC;AhBpTF,IgBsTQ,4BAAO,GAAd,UAAe,KAAmB,EAAE,QAAgB;AhBrTrD,QgBsTE,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,qBAAqB,EAAE,QAAQ,CAAC,CAAC;AhBrThE,IgBsTC,CAAC;AhBrTF,IgBuTQ,sCAAiB,GAAxB,UAAyB,UAA4B,EAAE,QAAgB;AhBtTxE,QgBuTE,IAAI,IAAI,CAAC,kBAAkB,IAAI,QAAQ,EAAE;AhBtT3C,YgBuTG,OAAO;AhBtTV,SgBuTG;AhBtTH,QgBwTE,IAAI,IAAI,CAAC,iBAAiB,EAAE;AhBvT9B,YgBwTG,IAAI,QAAQ,GAAG,UAAU,CAAC,QAAQ,CAAC;AhBvTtC,YgByTG,KAAwB,UAAwB,EAAxB,KAAA,IAAI,CAAC,mBAAmB,EAAxB,cAAwB,EAAxB,IAAwB,EAAE;AhBxTrD,gBgBwTQ,IAAM,SAAS,SAAA;AhBvTvB,gBgBwTI,IAAI,SAAS,CAAC,OAAO,CAAC,UAAU,CAAC,cAAc,EAAE,CAAC,EAAE;AhBvTxD,oBgBwTK,QAAQ,GAAG,oBAAoB,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,EAAE,eAAe,CAAC,SAAS,CAAC,IAAI,CAAC,mBAAoB,CAAC,EAAE,CAAC,CAAC,CAAC;AhBvT/G,iBgBwTK;AhBvTL,agBwTI;AhBvTJ,YgByTG,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,QAAQ,EAAE;AhBxTxG,gBgByTI,iDAAiD;AhBxTrD,gBgByTI,IAAI,CAAC,kBAAkB,GAAG,QAAQ,CAAC;AhBxTvC,gBgByTI,OAAO;AhBxTX,agByTI;AhBxTJ,YgB0TG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;AhBzTpD,YgB0TG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AhBzTrC,YgB2TG,IAAI,CAAC,kBAAkB,GAAG,QAAQ,CAAC;AhB1TtC,YgB2TG,OAAO;AhB1TV,SgB2TG;AhB1TH,QgB4TE,IAAI,MAAM,GAAG,UAAU,CAAC,cAAc,EAAE,CAAC;AhB3T3C,QgB6TE,IAAI,qBAAa,EAAE;AhB5TrB,YgB6TG,OAAO,CAAC,GAAG,CAAC,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,kBAAkB,EAAE,QAAQ,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC;AhB5TvH,YgB6TG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AhB5T3C,gBgB6TI,OAAO,CAAC,GAAG,CAAC,UAAU,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AhB5TxC,agB6TI;AhB5TJ,SgB6TG;AhB5TH,QgB8TE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;AhB7TpB,YgB8TG,UAAU,EAAE,IAAI,CAAC,kBAAkB;AhB7TtC,YgB8TG,QAAQ,EAAE,QAAQ;AhB7TrB,YgB8TG,0DAA0D;AhB7T7D,YgB8TG,MAAM,EAAE,MAAM;AhB7TjB,SgB8TG,CAAC,CAAC;AhB7TL,QgB+TE,IAAI,CAAC,kBAAkB,GAAG,QAAQ,CAAC;AhB9TrC,IgB+TC,CAAC;AhB9TF,IgBgUQ,8BAAS,GAAhB,UAAiB,KAAmB,EAAE,UAAkB;AhB/TzD,QgBgUE,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,UAAU,KAAK,UAAU,GAAG,CAAC,EAAE;AhB/TtG,YgBgUG,iCAAiC;AhB/TpC,YgBgUG,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;AhB/TtB,SgBgUG;AhB/TH,QgBiUE,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;AhBhUjC,YgBiUG,IAAI,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC;AhBhUhC,YgBiUG,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AhBhUnC,YgBiUG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC;AhBhUxD,SgBiUG;AhBhUH,QgBkUE,OAAO,IAAI,CAAC,OAAO,CAAC;AhBjUtB,IgBkUC,CAAC;AhBjUF,IgBmUQ,oCAAe,GAAtB,UAAuB,KAAmB,EAAE,UAAkB;AhBlU/D,QgBmUE,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,UAAU,GAAG,CAAC,EAAE;AhBlU7G,YgBmUG,iCAAiC;AhBlUpC,YgBmUG,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC;AhBlU5B,YgBmUG,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC;AhBlU5B,SgBmUG;AhBlUH,QgBoUE,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE;AhBnUvC,YgBoUG,IAAI,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC;AhBnUhC,YgBoUG,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AhBnUnC,YgBoUG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;AhBnUzD,SgBoUG;AhBnUH,QgBqUE,IAAI,MAAM,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;AhBpU1D,QgBqUE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AhBpUjE,YgBqUG,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;AhBpUrC,SgBqUG;AhBpUH,QgBsUE,OAAO,MAAM,CAAC;AhBrUhB,IgBsUC,CAAC;AhBrUF,IgBsUA,iBAAC;AAAD,AhBrUA,CgB8MA,AAuHC,IAAA;AAED,AhBtUA,yBgBsUyB,YAA+B;AhBrUxD,IgBsUC,QAAQ,YAAY,EAAE;AhBrUvB,QgBsUE;AhBrUF,YgBsUG,qBAAwC;AhBrU3C,QgBsUE;AhBrUF,YgBsUG,sBAAyC;AhBrU5C,QgBsUE;AhBrUF,YgBsUG,uBAA0C;AhBrU7C,QgBsUE,mBAA6B;AhBrU/B,QgBsUE;AhBrUF,YgBsUG,8CAA8C;AhBrUjD,YgBsUG,uDAAuD;AhBrU1D,YgBsUG,4BAA+C;AhBrUlD,KgBsUE;AACF,AhBtUA,CgBsUC;AhBrUD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"test.e98b79dd.js","sourceRoot":"..","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n    try {\n      activeElement = document.activeElement;\n    } catch(e) {\n      activeElement = document.body || null;\n    }\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {\n    this.id = null;\n    this.f = null;\n    this.time = 0;\n    this.handler = bind(this.onTimeout, this);\n  };\n  Delayed.prototype.onTimeout = function (self) {\n    self.id = 0;\n    if (self.time <= +new Date) {\n      self.f();\n    } else {\n      setTimeout(self.handler, self.time - +new Date);\n    }\n  };\n  Delayed.prototype.set = function (ms, f) {\n    this.f = f;\n    var time = +new Date + ms;\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id);\n      this.id = setTimeout(this.handler, ms);\n      this.time = time;\n    }\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 50;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      { spaceStrs.push(lst(spaceStrs) + \" \"); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, \"ltr\", 0) }\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, \"ltr\"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < ch && cur.to > ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n    function charType(code) {\n      if (code <= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n      else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n      else if (code == 0x200c) { return \"b\" }\n      else { return \"L\" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i < len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n        if (type == \"m\") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n        else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n                 (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == \",\") { types[i$4] = \"N\"; }\n        else if (type$3 == \"%\") {\n          var end = (void 0);\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i$4; j < end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length, isRTL = direction == \"rtl\" ? 1 : 0;\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }\n              var nstart = j$2;\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              at += isRTL;\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      map[type] = (map[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers, arr = map && map[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index > -1)\n          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) { b = 1; }\n      else if (e.button & 2) { b = 3; }\n      else if (e.button & 4) { b = 2; }\n    }\n    if (mac && e.ctrlKey && b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) { return false }\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3)\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range;\n    try {range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) { return false }\n    return range.compareEndPoints(\"StartToEnd\", range) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) { return true }\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length > 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\")\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\")\n    }\n    if (typeof spec == \"string\") { return {name: spec} }\n    else { return spec || {name: \"null\"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, \"text/plain\") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos >= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == \"string\") { ok = ch == match; }\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start\n  };\n  StringStream.prototype.eatSpace = function () {\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }\n    return this.pos > start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) { return null }\n      if (match && consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos)\n  };\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h < ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n    else if (ch < 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] <= n)\n      { this.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) { return style }\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp(\"(?:^|\\\\s)\" + lineClass[2] + \"(?:$|\\\\s)\")).test(output[prop]))\n        { output[prop] += \" \" + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier < n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i < spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n\n  // Add a span to a line.\n  function addMarkedSpan(line, span, op) {\n    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));\n    if (inThisOp && inThisOp.has(line.markedSpans)) {\n      line.markedSpans.push(span);\n    } else {\n      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n      if (inThisOp) { inThisOp.add(line.markedSpans); }\n    }\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last && last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        { for (var i$2 = 0; i$2 < first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 < gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        { builder.content.className = \"cm-tab-wrap-hack\"; }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css || attributes) {\n      var fullStyle = style || \"\";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = \"\";\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = \"\\u00a0\"; }\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n          if (part.to > start && part.from <= start) { break }\n        }\n        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement(\"span\")); }\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) { spanStyle += \" \" + m.className; }\n            if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n            if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              { collapsed = sp; }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos >= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i < callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i < arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") { updateLineText(cm, lineView); }\n      else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == \"class\") { updateLineClasses(cm, lineView); }\n      else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) { cls += \" CodeMirror-linebackground\"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = \"\"; }\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n      gutterWrap.setAttribute(\"aria-hidden\", \"true\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                     (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    var isWidget = classTest(\"CodeMirror-linewidget\");\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\" + (widget.className ? \" \" + widget.className : \"\"));\n      if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n      if (widget.noHScroll)\n        { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    for (var i = 0; i < lineView.rest.length; i++)\n      { if (lineView.rest[i] == line)\n        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n      { if (lineNo(lineView.rest[i$1]) > lineN)\n        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      mStart = map[i];\n      mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) { collapse = \"right\"; }\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          { collapse = bias; }\n        if (bias == \"left\" && start == 0)\n          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          } }\n        if (bias == \"right\" && start == mEnd - mStart)\n          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) { collapse = bias = \"right\"; }\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i < heights.length - 1; i++)\n      { if (mid < heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n  }\n  function pageScrollY() {\n    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n      { height += widgetHeight(lineObj.widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == \"line\") { return rect }\n    if (!context) { context = \"local\"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n    if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n    if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = outside; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }\n    if (x < 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight; box.bottom += widgetHeight;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?\n        \"after\" : \"before\";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), \"line\", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                     \"line\", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n    if (index > 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                               \"line\", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) && start.top > y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n      if (p.from >= end || p.to <= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt(\"pre\", null, \"CodeMirror-line-like\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor], \"CodeMirror-line-like\");\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e$1) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n < 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) { return i }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        { resetView(cm); }\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from < ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line < display.viewFrom || line >= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i < index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom < from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo > to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) { continue }\n      var range = doc.sel.ranges[i];\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        { drawSelectionCursor(cm, range.head, curFragment); }\n      if (!collapsed)\n        { drawSelectionRange(cm, range, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (/\\bcm-fat-cursor\\b/.test(cm.getWrapperElement().className)) {\n      var charPos = charCoords(cm, head, \"div\", null, null);\n      cursor.style.width = Math.max(0, charPos.right - charPos.left) + \"px\";\n    }\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top <= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) < 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) < 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      { display.blinker = setInterval(function () {\n        if (!cm.hasFocus()) { onBlur(cm); }\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate < 0)\n      { display.cursorDiv.style.visibility = \"hidden\"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.hasFocus()) {\n      cm.display.input.focus();\n      if (!cm.state.focused) { onFocus(cm); }\n    }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      if (cm.state.focused) { onBlur(cm); }\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == \"nocursor\") { return }\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don't extend past the right of the current\n        // editor width\n        if (!wrapping && cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (diff > .005 || diff < -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (rect.top + box.top < 0) { doScroll = true; }\n    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n    }\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top < 0) { rect.top = 0; }\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n    var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n    var tooWide = rect.right - rect.left > screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left < 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left < screenleft)\n      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }\n    else if (rect.right > screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      scrollToCoordsRange(cm, from, to, range.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt != bar) { bar.style.pointerEvents = \"none\"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else { d.scrollbarFiller.style.display = \"\"; }\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else { d.gutterFiller.style.display = \"\"; }\n  }\n\n  var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId,          // Unique ID\n      markArrays: null         // Used by addMarkedSpan\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i < group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused && op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i < hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, \"changes\", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier >= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i < changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], \"text\"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n    for (var i = 0; i < this.events.length; i++)\n      { signal.apply(null, this.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt();\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n    snapshot.activeElt.focus();\n    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&\n        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(), range = document.createRange();\n      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          { break }\n      } else if (first) {\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        { node.style.display = \"none\"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + \"px\";\n    // Send an event to consumers responding to changes in gutter width.\n    signalLater(display, \"gutterChanged\", display);\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j < align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm.display);\n      return true\n    }\n    return false\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [], sawLineNumbers = false;\n    for (var i = 0; i < gutters.length; i++) {\n      var name = gutters[i], style = null;\n      if (typeof name != \"string\") { style = name.style; name = name.className; }\n      if (name == \"CodeMirror-linenumbers\") {\n        if (!lineNumbers) { continue }\n        else { sawLineNumbers = true; }\n      }\n      result.push({className: name, style: style});\n    }\n    if (lineNumbers && !sawLineNumbers) { result.push({className: \"CodeMirror-linenumbers\", style: null}); }\n    return result\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function renderGutters(display) {\n    var gutters = display.gutters, specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n    for (var i = 0; i < specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n      if (style) { gElt.style.cssText = style; }\n      if (className == \"CodeMirror-linenumbers\") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = specs.length ? \"\" : \"none\";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [lines], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // This attribute is respected by automatic translation systems such as Google Translate,\n    // and may also be respected by tools used by human translators.\n    d.wrapper.setAttribute('translate', 'no');\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n\n    input.init(d);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n    var out = [];\n    for (var i = 0; i < this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n    for (var i = 0; i < this.ranges.length; i++)\n      { if (!this.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n    if (!end) { end = pos; }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this.ranges[i];\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) { return pos }\n    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i < end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error(\"This document is already in use.\") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    cm.options.direction = doc.direction;\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(prev) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = prev ? prev.undoDepth : Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, \"historyAdded\"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i < change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i < doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption(\"readOnly\") != \"nocursor\")\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n\n      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n      // is with selectLeft/Right\n      var preventCursorLeft = (\"selectLeft\" in m) ? !m.selectLeft : m.inclusiveLeft;\n      var preventCursorRight = (\"selectRight\" in m) ? !m.selectRight : m.inclusiveRight;\n\n      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n          if (dir < 0 ? preventCursorRight : preventCursorLeft)\n            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? preventCursorLeft : preventCursorRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n    if (suppress && !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        { regLineChange(doc.cm, l, \"gutter\"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line > doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\n    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))\n      { doc.cantEdit = false; }\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, \"text\"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == \"string\") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        { if (op(this.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this.children.splice(++i, 0, leaf);\n              leaf.parent = this;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) { signalLater(this, \"clear\", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n    if (side == null && this.type == \"bookmark\") { side = 1; }\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from && {from: from, to: to}\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      { markers[i].parent = this; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      { this.markers[i].clear(); }\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      if (lineSep === '') { return lines.join('') }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") { pos = range.head; }\n      else if (start == \"anchor\") { pos = range.anchor; }\n      else if (start == \"end\" || start == \"to\" || start === false) { pos = range.to(); }\n      else { pos = range.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i < ranges.length; i++)\n        { out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head || ranges[i].anchor)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n        { makeChange(this, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {\n      var this$1 = this;\n\n      this.history = new History(this.history);\n      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);\n    },\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += \" \" + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\n                span.from == null && lineNo != from.line ||\n                span.from != null && lineNo == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i < sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) { from = options.from; }\n      if (options.to != null && options.to < to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) { continue }\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") { dir = \"ltr\"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var markAsReadAndPasteIfAllFilesAreRead = function () {\n        if (++read == n) {\n          operation(cm, function () {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(\n                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n          })();\n        }\n      };\n      var readTextFromFile = function (file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n          markAsReadAndPasteIfAllFilesAreRead();\n          return\n        }\n        var reader = new FileReader;\n        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };\n        reader.onload = function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n            markAsReadAndPasteIfAllFilesAreRead();\n            return\n          }\n          text[i] = content;\n          markAsReadAndPasteIfAllFilesAreRead();\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n            { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e$1){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i < editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 145: \"ScrollLock\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 224: \"Mod\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n\n  // Number keys\n  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\", \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\",\n    \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\",\n    \"Ctrl-T\": \"transposeChars\", \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n    }\n    if (alt) { name = \"Alt-\" + name; }\n    if (ctrl) { name = \"Ctrl-\" + name; }\n    if (cmd) { name = \"Cmd-\" + name; }\n    if (shift) { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == \"...\") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) { return \"nothing\" }\n    if (found === \"...\") { return \"multi\" }\n    if (found != null && handle(found)) { return \"handled\" }\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        { return lookupKey(key, map.fallthrough, handle, context) }\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Mod\") { name = \"Cmd-\" + name; }\n    if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 && event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      if (cm.doc.direction == \"rtl\") { dir = -dir; }\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir < 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir < 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir < 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), \"before\")\n        : new Pos(start.line, ch, \"after\"); };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir > 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len && range.head.line < cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: \"+move\", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: 0, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n      if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n    goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n    goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n    goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n    goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n    goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n    goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n    goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, \"codepoint\"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n    indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n    indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n    indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n    insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n      else { cm.execCommand(\"insertTab\"); }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch > 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n          } else if (cur.line > cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i >= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 < sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return \"handled\" }\n      if (/\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      { cm.state.keySeq = name; }\n    if (result == \"handled\")\n      { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection(\"\", null, \"cut\"); }\n    }\n    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)\n      { document.execCommand(\"cut\"); }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == \"\\x08\") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time &&\n      cmp(pos, this.pos) == 0 && button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\"\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus();\n\n    // #3261: make sure, that we're not starting a second selection\n    if (button == 1 && cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n    if (repeat == \"double\") { name = \"Double\" + name; }\n    else if (repeat == \"triple\") { name = \"Triple\" + name; }\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      if (cm.state.delayingBlurEvent) {\n        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }\n        else { delayBlurEvent(cm); }\n      }\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if ((webkit && !safari) || ie && ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { return display.input.focus(); }, 20);\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") { return new Range(pos, pos) }\n    if (unit == \"word\") { return cm.findWordAt(pos) }\n    if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    if (ie) { delayBlurEvent(cm); }\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }\n      else\n        { ourRange = range; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length > leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range.anchor, anchor) > 0) {\n          head = range.head;\n          anchor = minPos(oldRange.from(), range.anchor);\n        } else {\n          head = range.anchor;\n          anchor = maxPos(oldRange.to(), range.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range) {\n    var anchor = range.anchor;\n    var head = range.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }\n    var order = getOrder(anchorLine);\n    if (!order) { return range }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch && part.to != anchor.ch) { return range }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir < 0; }\n      else\n        { leftSide = dir > 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e$1) { return false }\n    }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n    return gutterEvent(cm, e, \"gutterContextMenu\", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return \"CodeMirror.Init\"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n      if (old != Init) { cm.refresh(); }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option(\"autocorrect\", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);\n    option(\"autocapitalize\", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n      if (prev && prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, updateGutters, true);\n    option(\"lineNumberFormatter\", function (integer) { return integer; }, updateGutters, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n\n    option(\"screenReaderLabel\", null, function (cm, val) {\n      val = (val === '') ? null : val;\n      cm.display.input.screenReaderLabelChanged(val);\n    });\n\n    option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option(\"phrases\", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || this.hasFocus())\n      { setTimeout(function () {\n        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }\n      }, 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      { display.lineDiv.style.textRendering = \"auto\"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\n    on(d.input.getField(), \"contextmenu\", function (e) {\n      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }\n    });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20\n    }\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = \"add\"; }\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) { how = \"prev\"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) { return }\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n    if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var recent = +new Date - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range = sel.ranges[i$1];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == textLines.join(\"\\n\"))\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          { indented = indentLine(cm, range.head.line, \"smart\"); }\n      }\n      if (indented) { signalLater(cm, \"electricInput\", cm, range.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", autocorrect ? \"\" : \"off\");\n    field.setAttribute(\"autocapitalize\", autocapitalize ? \"\" : \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = \"1000px\"; }\n    else { te.setAttribute(\"wrap\", \"off\"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = \"1px solid black\"; }\n    disableBrowserMagic(te);\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){window.focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value && option != \"mode\") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, \"optionChange\", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n      },\n      removeKeyMap: function(map) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i < maps.length; ++i)\n          { if (maps[i] == map || maps[i].name == map) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                      priority: (options && options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var overlays = this.state.overlays;\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this.state.modeGen++;\n            regChange(this);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n          else { dir = dir ? \"add\" : \"subtract\"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i];\n          if (!range.empty()) {\n            var from = range.from(), to = range.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j < end; ++j)\n              { indentLine(this, j, how); }\n            var newRanges = this.doc.sel.ranges;\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range.head.line > end) {\n            indentLine(this, range.head.line, how, true);\n            end = range.head.line;\n            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) >> 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range = this.doc.sel.primary();\n        if (start == null) { pos = range.head; }\n        else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range.from() : range.to(); }\n        return cursorCoords(this, pos, mode || \"page\")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line < this.doc.first) { line = this.doc.first; }\n          else if (line > last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight <= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth > hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") { left = 0; }\n          else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + \"px\";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var dir = 1;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          cur = findPosH(this.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range) {\n          if (this$1.display.shift || this$1.doc.extend || range.empty())\n            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir < 0 ? range.from() : range.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection(\"\", null, \"+delete\"); }\n        else\n          { deleteNearSelection(this, function (range) {\n            var other = findPosH(doc, range.head, dir, unit, false);\n            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var dir = 1, x = goalColumn;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          var coords = cursorCoords(this, cur, \"div\");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range) {\n          if (collapse)\n            { return dir < 0 ? range.from() : range.to() }\n          var headPos = cursorCoords(this$1, range.head, \"div\");\n          if (range.goalColumn != null) { headPos.left = range.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == \"page\" && range == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n          if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n          while (start > 0 && check(line.charAt(start - 1))) { --start; }\n          while (end < line.length && check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null && value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n        else\n          { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt() },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range, margin) {\n        if (range == null) {\n          range = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range == \"number\") {\n          range = {from: Pos(range, 0), to: null};\n        } else if (range.from == null) {\n          range = {from: range, to: null};\n        }\n        if (!range.to) { range.to = range.from; }\n        range.margin = margin || 0;\n\n        if (range.from.line != null) {\n          scrollToRange(this, range);\n        } else {\n          scrollToCoordsRange(this, range.from, range.to, range.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo = this.display.viewFrom;\n        this.doc.iter(lineNo, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, \"widget\"); break } } }\n          ++lineNo;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)\n          { estimateLineHeights(this); }\n        signal(this, \"refresh\", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        // Cancel the current text selection if any (#5821)\n        if (this.state.selectingText) { this.state.selectingText(); }\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"codepoint\", \"char\", \"column\" (like char, but\n  // doesn't cross line boundaries), \"word\" (across next word), or\n  // \"group\" (to the start of next group of word or\n  // non-word-non-whitespace chars). The visually param controls\n  // whether, in right-to-left text, direction 1 means to move towards\n  // the next index in the string, or towards the character to the right\n  // of the current position. The resulting position will have a\n  // hitSide=true property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    var lineDir = visually && doc.direction == \"rtl\" ? -dir : dir;\n    function findNextLine() {\n      var l = pos.line + lineDir;\n      if (l < doc.first || l >= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (unit == \"codepoint\") {\n        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n        if (isNaN(ch)) {\n          next = null;\n        } else {\n          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;\n          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n        }\n      } else if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine && findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == \"char\" || unit == \"codepoint\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) { type = \"s\"; }\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir > 0 && !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    div.contentEditable = true;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    function belongsToInput(e) {\n      for (var t = e.target; t; t = t.parentNode) {\n        if (t == div) { return true }\n        if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) { break }\n      }\n      return false\n    }\n\n    on(div, \"paste\", function (e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n    on(div, \"input\", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData(\"Text\", content);\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = activeElt();\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.div.setAttribute('aria-label', label);\n    } else {\n      this.div.removeAttribute('aria-label');\n    }\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = activeElt() == this.div;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n        cmp(minPos(curAnchor, curFocus), from) == 0 &&\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old && sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor() || activeElt() != this.div)\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n    if (this.selectionInEditor())\n      { this.pollSelection(); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor && head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 && from.line > cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd < maxCutEnd &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find(0)))\n            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i < node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = \"0px\"; }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = +new Date;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n      if (e.type == \"cut\") { cm.state.cutIncoming = +new Date; }\n    }\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date;\n        input.focus();\n        return\n      }\n\n      // Pass the `paste` event to the textarea so it's handled by its event listener.\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.textarea.setAttribute('aria-label', label);\n    } else {\n      this.textarea.removeAttribute('aria-label');\n    }\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) { return }\n    var cm = this.cm;\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie && ie_version >= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n      if (ie && ie_version >= 9) { this.hasSelection = null; }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || !cm.state.focused ||\n        (hasSelection(input) && !prevInput && !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? \"*compose\" : null);\n\n      // Don't leave long text in the textarea, since it makes further polling slow\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                           {className: \"CodeMirror-composing\"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { window.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200b\" + (selected ? te.value : \"\");\n        te.value = \"\\u21da\"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200b\";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n              te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == \"nocursor\";\n    this.textarea.readOnly = !!val;\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder && textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == \"function\")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, */) {\n    if (!CodeMirror.defaults.mode && name != \"null\") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = \"5.62.3\";\n\n  return CodeMirror;\n\n})));\n","/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport { IOnigCaptureIndex } from 'onigasm';\n\nexport function clone<T>(something: T): T {\n\treturn doClone(something);\n}\n\nfunction doClone(something: any): any {\n\tif (Array.isArray(something)) {\n\t\treturn cloneArray(something);\n\t}\n\tif (typeof something === 'object') {\n\t\treturn cloneObj(something);\n\t}\n\treturn something;\n}\n\nfunction cloneArray(arr: any[]): any[] {\n\tlet r: any[] = [];\n\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\tr[i] = doClone(arr[i]);\n\t}\n\treturn r;\n}\n\nfunction cloneObj(obj: any): any {\n\tlet r: any = {};\n\tfor (let key in obj) {\n\t\tr[key] = doClone(obj[key]);\n\t}\n\treturn r;\n}\n\nexport function mergeObjects(target: any, ...sources: any[]): any {\n\tsources.forEach(source => {\n\t\tfor (let key in source) {\n\t\t\ttarget[key] = source[key];\n\t\t}\n\t});\n\treturn target;\n}\n\nlet CAPTURING_REGEX_SOURCE = /\\$(\\d+)|\\${(\\d+):\\/(downcase|upcase)}/;\n\nexport class RegexSource {\n\n\tpublic static hasCaptures(regexSource: string): boolean {\n\t\treturn CAPTURING_REGEX_SOURCE.test(regexSource);\n\t}\n\n\tpublic static replaceCaptures(regexSource: string, captureSource: string, captureIndices: IOnigCaptureIndex[]): string {\n\t\treturn regexSource.replace(CAPTURING_REGEX_SOURCE, (match: string, index: string, commandIndex: string, command: string) => {\n\t\t\tlet capture = captureIndices[parseInt(index || commandIndex, 10)];\n\t\t\tif (capture) {\n\t\t\t\tlet result = captureSource.substring(capture.start, capture.end);\n\t\t\t\t// Remove leading dots that would make the selector invalid\n\t\t\t\twhile (result[0] === '.') {\n\t\t\t\t\tresult = result.substring(1);\n\t\t\t\t}\n\t\t\t\tswitch (command) {\n\t\t\t\t\tcase 'downcase':\n\t\t\t\t\t\treturn result.toLowerCase();\n\t\t\t\t\tcase 'upcase':\n\t\t\t\t\t\treturn result.toUpperCase();\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t});\n\t}\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","\nvar Onigasm = (function() {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  return (\nfunction(Onigasm) {\n  Onigasm = Onigasm || {};\n\nvar Module=typeof Onigasm!==\"undefined\"?Onigasm:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var arguments_=[];var thisProgram=\"./this.program\";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=true;var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var read_,readBinary;if(ENVIRONMENT_IS_SHELL){if(typeof read!=\"undefined\"){read_=function shell_read(f){return read(f)}}readBinary=function readBinary(f){var data;if(typeof readbuffer===\"function\"){return new Uint8Array(readbuffer(f))}data=read(f,\"binary\");assert(typeof data===\"object\");return data};if(typeof scriptArgs!=\"undefined\"){arguments_=scriptArgs}else if(typeof arguments!=\"undefined\"){arguments_=arguments}if(typeof quit===\"function\"){quit_=function(status){quit(status)}}if(typeof print!==\"undefined\"){if(typeof console===\"undefined\")console={};console.log=print;console.warn=console.error=typeof printErr!==\"undefined\"?printErr:print}}else{}var out=Module[\"print\"]||console.log.bind(console);var err=Module[\"printErr\"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=null;if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"quit\"])quit_=Module[\"quit\"];var STACK_ALIGN=16;function dynamicAlloc(size){var ret=HEAP32[DYNAMICTOP_PTR>>2];var end=ret+size+15&-16;if(end>_emscripten_get_heap_size()){abort()}HEAP32[DYNAMICTOP_PTR>>2]=end;return ret}function getNativeTypeSize(type){switch(type){case\"i1\":case\"i8\":return 1;case\"i16\":return 2;case\"i32\":return 4;case\"i64\":return 8;case\"float\":return 4;case\"double\":return 8;default:{if(type[type.length-1]===\"*\"){return 4}else if(type[0]===\"i\"){var bits=parseInt(type.substr(1));assert(bits%8===0,\"getNativeTypeSize invalid bits \"+bits+\", type \"+type);return bits/8}else{return 0}}}}function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text)}}function convertJsFunctionToWasm(func,sig){var typeSection=[1,0,1,96];var sigRet=sig.slice(0,1);var sigParam=sig.slice(1);var typeCodes={\"i\":127,\"j\":126,\"f\":125,\"d\":124};typeSection.push(sigParam.length);for(var i=0;i<sigParam.length;++i){typeSection.push(typeCodes[sigParam[i]])}if(sigRet==\"v\"){typeSection.push(0)}else{typeSection=typeSection.concat([1,typeCodes[sigRet]])}typeSection[1]=typeSection.length-2;var bytes=new Uint8Array([0,97,115,109,1,0,0,0].concat(typeSection,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0]));var module=new WebAssembly.Module(bytes);var instance=new WebAssembly.Instance(module,{e:{f:func}});var wrappedFunc=instance.exports.f;return wrappedFunc}function addFunctionWasm(func,sig){var table=wasmTable;var ret=table.length;try{table.grow(1)}catch(err){if(!err instanceof RangeError){throw err}throw\"Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.\"}try{table.set(ret,func)}catch(err){if(!err instanceof TypeError){throw err}assert(typeof sig!==\"undefined\",\"Missing signature argument to addFunction\");var wrapped=convertJsFunctionToWasm(func,sig);table.set(ret,wrapped)}return ret}function removeFunctionWasm(index){}var funcWrappers={};function dynCall(sig,ptr,args){if(args&&args.length){return Module[\"dynCall_\"+sig].apply(null,[ptr].concat(args))}else{return Module[\"dynCall_\"+sig].call(null,ptr)}}var tempRet0=0;var setTempRet0=function(value){tempRet0=value};var wasmBinary;if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];var noExitRuntime;if(Module[\"noExitRuntime\"])noExitRuntime=Module[\"noExitRuntime\"];if(typeof WebAssembly!==\"object\"){err(\"no native wasm support detected\")}function setValue(ptr,value,type,noSafe){type=type||\"i8\";if(type.charAt(type.length-1)===\"*\")type=\"i32\";switch(type){case\"i1\":HEAP8[ptr>>0]=value;break;case\"i8\":HEAP8[ptr>>0]=value;break;case\"i16\":HEAP16[ptr>>1]=value;break;case\"i32\":HEAP32[ptr>>2]=value;break;case\"i64\":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=1?tempDouble>0?(Math_min(+Math_floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math_ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case\"float\":HEAPF32[ptr>>2]=value;break;case\"double\":HEAPF64[ptr>>3]=value;break;default:abort(\"invalid type for setValue: \"+type)}}var wasmMemory;var wasmTable=new WebAssembly.Table({\"initial\":244,\"maximum\":244+0,\"element\":\"anyfunc\"});var ABORT=false;var EXITSTATUS=0;function assert(condition,text){if(!condition){abort(\"Assertion failed: \"+text)}}function getCFunc(ident){var func=Module[\"_\"+ident];assert(func,\"Cannot call unknown function \"+ident+\", make sure it is exported\");return func}function ccall(ident,returnType,argTypes,args,opts){var toC={\"string\":function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len)}return ret},\"array\":function(arr){var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType===\"string\")return UTF8ToString(ret);if(returnType===\"boolean\")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);ret=convertReturnValue(ret);if(stack!==0)stackRestore(stack);return ret}var ALLOC_NONE=3;var UTF8Decoder=typeof TextDecoder!==\"undefined\"?new TextDecoder(\"utf8\"):undefined;function UTF8ArrayToString(u8Array,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(u8Array[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var str=\"\";while(idx<endPtr){var u0=u8Array[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|u8Array[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):\"\"}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4}return len}var UTF16Decoder=typeof TextDecoder!==\"undefined\"?new TextDecoder(\"utf-16le\"):undefined;function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}var WASM_PAGE_SIZE=65536;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module[\"HEAP8\"]=HEAP8=new Int8Array(buf);Module[\"HEAP16\"]=HEAP16=new Int16Array(buf);Module[\"HEAP32\"]=HEAP32=new Int32Array(buf);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(buf);Module[\"HEAPU16\"]=HEAPU16=new Uint16Array(buf);Module[\"HEAPU32\"]=HEAPU32=new Uint32Array(buf);Module[\"HEAPF32\"]=HEAPF32=new Float32Array(buf);Module[\"HEAPF64\"]=HEAPF64=new Float64Array(buf)}var STACK_BASE=5507664,DYNAMIC_BASE=5507664,DYNAMICTOP_PTR=264624;var INITIAL_TOTAL_MEMORY=Module[\"TOTAL_MEMORY\"]||157286400;if(Module[\"wasmMemory\"]){wasmMemory=Module[\"wasmMemory\"]}else{wasmMemory=new WebAssembly.Memory({\"initial\":INITIAL_TOTAL_MEMORY/WASM_PAGE_SIZE})}if(wasmMemory){buffer=wasmMemory.buffer}INITIAL_TOTAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback==\"function\"){callback();continue}var func=callback.func;if(typeof func===\"number\"){if(callback.arg===undefined){Module[\"dynCall_v\"](func)}else{Module[\"dynCall_vi\"](func,callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){runtimeExited=true}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var Math_abs=Math.abs;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_min=Math.min;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module[\"preloadedImages\"]={};Module[\"preloadedAudios\"]={};function abort(what){if(Module[\"onAbort\"]){Module[\"onAbort\"](what)}what+=\"\";out(what);err(what);ABORT=true;EXITSTATUS=1;what=\"abort(\"+what+\"). Build with -s ASSERTIONS=1 for more info.\";throw new WebAssembly.RuntimeError(what)}var dataURIPrefix=\"data:application/octet-stream;base64,\";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}var wasmBinaryFile=\"onigasm.wasm\";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(){try{if(wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(wasmBinaryFile)}else{throw\"both async and sync fetching of the wasm failed\"}}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)&&typeof fetch===\"function\"){return fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){if(!response[\"ok\"]){throw\"failed to load wasm binary file at '\"+wasmBinaryFile+\"'\"}return response[\"arrayBuffer\"]()}).catch(function(){return getBinary()})}return new Promise(function(resolve,reject){resolve(getBinary())})}function createWasm(){var info={\"env\":asmLibraryArg,\"wasi_unstable\":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module[\"asm\"]=exports;removeRunDependency(\"wasm-instantiate\")}addRunDependency(\"wasm-instantiate\");function receiveInstantiatedSource(output){receiveInstance(output[\"instance\"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(receiver,function(reason){err(\"failed to asynchronously prepare wasm: \"+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming===\"function\"&&!isDataURI(wasmBinaryFile)&&typeof fetch===\"function\"){fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiatedSource,function(reason){err(\"wasm streaming compile failed: \"+reason);err(\"falling back to ArrayBuffer instantiation\");instantiateArrayBuffer(receiveInstantiatedSource)})})}else{return instantiateArrayBuffer(receiveInstantiatedSource)}}if(Module[\"instantiateWasm\"]){try{var exports=Module[\"instantiateWasm\"](info,receiveInstance);return exports}catch(e){err(\"Module.instantiateWasm callback failed with error: \"+e);return false}}instantiateAsync();return{}}var tempDouble;var tempI64;__ATINIT__.push({func:function(){___wasm_call_ctors()}});function demangle(func){var __cxa_demangle_func=Module[\"___cxa_demangle\"]||Module[\"__cxa_demangle\"];assert(__cxa_demangle_func);try{var s=func;if(s.startsWith(\"__Z\"))s=s.substr(1);var len=lengthBytesUTF8(s)+1;var buf=_malloc(len);stringToUTF8(s,buf,len);var status=_malloc(4);var ret=__cxa_demangle_func(buf,0,0,status);if(HEAP32[status>>2]===0&&ret){return UTF8ToString(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret)}return func}function demangleAll(text){var regex=/\\b_Z[\\w\\d_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+\" [\"+x+\"]\"})}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return\"(no stack trace available)\"}}return err.stack.toString()}function _abort(){abort()}function _emscripten_get_heap_size(){return HEAP8.length}function _emscripten_get_sbrk_ptr(){return 264624}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=_emscripten_get_heap_size();var PAGE_MULTIPLE=65536;var LIMIT=2147483648-PAGE_MULTIPLE;if(requestedSize>LIMIT){return false}var MIN_TOTAL_MEMORY=16777216;var newSize=Math.max(oldSize,MIN_TOTAL_MEMORY);while(newSize<requestedSize){if(newSize<=536870912){newSize=alignUp(2*newSize,PAGE_MULTIPLE)}else{newSize=Math.min(alignUp((3*newSize+2147483648)/4,PAGE_MULTIPLE),LIMIT)}}var replacement=emscripten_realloc_buffer(newSize);if(!replacement){return false}return true}var PATH={splitPath:function(filename){var splitPathRe=/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\".\"){parts.splice(i,1)}else if(last===\"..\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\"..\")}}return parts},normalize:function(path){var isAbsolute=path.charAt(0)===\"/\",trailingSlash=path.substr(-1)===\"/\";path=PATH.normalizeArray(path.split(\"/\").filter(function(p){return!!p}),!isAbsolute).join(\"/\");if(!path&&!isAbsolute){path=\".\"}if(path&&trailingSlash){path+=\"/\"}return(isAbsolute?\"/\":\"\")+path},dirname:function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\".\"}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir},basename:function(path){if(path===\"/\")return\"/\";var lastSlash=path.lastIndexOf(\"/\");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},extname:function(path){return PATH.splitPath(path)[3]},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join(\"/\"))},join2:function(l,r){return PATH.normalize(l+\"/\"+r)}};var SYSCALLS={buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}},varargs:0,get:function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(){var ret=UTF8ToString(SYSCALLS.get());return ret},get64:function(){var low=SYSCALLS.get(),high=SYSCALLS.get();return low},getZero:function(){SYSCALLS.get()}};function _fd_close(fd){try{return 0}catch(e){if(typeof FS===\"undefined\"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){try{return 0}catch(e){if(typeof FS===\"undefined\"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function _fd_write(fd,iov,iovcnt,pnum){try{var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(fd,HEAPU8[ptr+j])}num+=len}HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS===\"undefined\"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function _setTempRet0($i){setTempRet0($i|0)}var ASSERTIONS=false;var asmLibraryArg={\"abort\":_abort,\"emscripten_get_sbrk_ptr\":_emscripten_get_sbrk_ptr,\"emscripten_memcpy_big\":_emscripten_memcpy_big,\"emscripten_resize_heap\":_emscripten_resize_heap,\"fd_close\":_fd_close,\"fd_seek\":_fd_seek,\"fd_write\":_fd_write,\"memory\":wasmMemory,\"setTempRet0\":_setTempRet0,\"table\":wasmTable};var asm=createWasm();Module[\"asm\"]=asm;var ___wasm_call_ctors=Module[\"___wasm_call_ctors\"]=function(){return Module[\"asm\"][\"__wasm_call_ctors\"].apply(null,arguments)};var _malloc=Module[\"_malloc\"]=function(){return Module[\"asm\"][\"malloc\"].apply(null,arguments)};var _free=Module[\"_free\"]=function(){return Module[\"asm\"][\"free\"].apply(null,arguments)};var _getLastError=Module[\"_getLastError\"]=function(){return Module[\"asm\"][\"getLastError\"].apply(null,arguments)};var _compilePattern=Module[\"_compilePattern\"]=function(){return Module[\"asm\"][\"compilePattern\"].apply(null,arguments)};var _disposeCompiledPatterns=Module[\"_disposeCompiledPatterns\"]=function(){return Module[\"asm\"][\"disposeCompiledPatterns\"].apply(null,arguments)};var _findBestMatch=Module[\"_findBestMatch\"]=function(){return Module[\"asm\"][\"findBestMatch\"].apply(null,arguments)};var ___cxa_demangle=Module[\"___cxa_demangle\"]=function(){return Module[\"asm\"][\"__cxa_demangle\"].apply(null,arguments)};var _setThrew=Module[\"_setThrew\"]=function(){return Module[\"asm\"][\"setThrew\"].apply(null,arguments)};var stackSave=Module[\"stackSave\"]=function(){return Module[\"asm\"][\"stackSave\"].apply(null,arguments)};var stackAlloc=Module[\"stackAlloc\"]=function(){return Module[\"asm\"][\"stackAlloc\"].apply(null,arguments)};var stackRestore=Module[\"stackRestore\"]=function(){return Module[\"asm\"][\"stackRestore\"].apply(null,arguments)};var __growWasmMemory=Module[\"__growWasmMemory\"]=function(){return Module[\"asm\"][\"__growWasmMemory\"].apply(null,arguments)};var dynCall_vi=Module[\"dynCall_vi\"]=function(){return Module[\"asm\"][\"dynCall_vi\"].apply(null,arguments)};var dynCall_iiii=Module[\"dynCall_iiii\"]=function(){return Module[\"asm\"][\"dynCall_iiii\"].apply(null,arguments)};var dynCall_iiiii=Module[\"dynCall_iiiii\"]=function(){return Module[\"asm\"][\"dynCall_iiiii\"].apply(null,arguments)};var dynCall_iii=Module[\"dynCall_iii\"]=function(){return Module[\"asm\"][\"dynCall_iii\"].apply(null,arguments)};var dynCall_iidiiii=Module[\"dynCall_iidiiii\"]=function(){return Module[\"asm\"][\"dynCall_iidiiii\"].apply(null,arguments)};var dynCall_vii=Module[\"dynCall_vii\"]=function(){return Module[\"asm\"][\"dynCall_vii\"].apply(null,arguments)};var dynCall_ii=Module[\"dynCall_ii\"]=function(){return Module[\"asm\"][\"dynCall_ii\"].apply(null,arguments)};var dynCall_i=Module[\"dynCall_i\"]=function(){return Module[\"asm\"][\"dynCall_i\"].apply(null,arguments)};var dynCall_v=Module[\"dynCall_v\"]=function(){return Module[\"asm\"][\"dynCall_v\"].apply(null,arguments)};var dynCall_viiiiii=Module[\"dynCall_viiiiii\"]=function(){return Module[\"asm\"][\"dynCall_viiiiii\"].apply(null,arguments)};var dynCall_viiiii=Module[\"dynCall_viiiii\"]=function(){return Module[\"asm\"][\"dynCall_viiiii\"].apply(null,arguments)};var dynCall_viiii=Module[\"dynCall_viiii\"]=function(){return Module[\"asm\"][\"dynCall_viiii\"].apply(null,arguments)};var dynCall_jiji=Module[\"dynCall_jiji\"]=function(){return Module[\"asm\"][\"dynCall_jiji\"].apply(null,arguments)};Module[\"asm\"]=asm;Module[\"ccall\"]=ccall;var calledRun;Module[\"then\"]=function(func){if(calledRun){func(Module)}else{var old=Module[\"onRuntimeInitialized\"];Module[\"onRuntimeInitialized\"]=function(){if(old)old();func(Module)}}return Module};function ExitStatus(status){this.name=\"ExitStatus\";this.message=\"Program terminated with exit(\"+status+\")\";this.status=status}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0)return;function doRun(){if(calledRun)return;calledRun=true;if(ABORT)return;initRuntime();preMain();if(Module[\"onRuntimeInitialized\"])Module[\"onRuntimeInitialized\"]();postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(function(){setTimeout(function(){Module[\"setStatus\"](\"\")},1);doRun()},1)}else{doRun()}}Module[\"run\"]=run;if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].pop()()}}noExitRuntime=true;run();\n\n\n  return Onigasm\n}\n);\n})();\nif (typeof exports === 'object' && typeof module === 'object')\n      module.exports = Onigasm;\n    else if (typeof define === 'function' && define['amd'])\n      define([], function() { return Onigasm; });\n    else if (typeof exports === 'object')\n      exports[\"Onigasm\"] = Onigasm;\n    ","// Just to keep typescript quiet\ndeclare const require\ndeclare const WebAssembly\n\nconst OnigasmModuleFactory = require('./onigasm.js' /** when TS is compiled to JS, this will mean `lib/onigasm.js` (emitted by `emcc`) */)\n\n/**\n * Handle to onigasm module (the JS glue code emitted by emscripten, that provides access to C/C++ runtime)\n *\n * Single handle shared among modules that decorate the C runtime to deliver `atom/node-oniguruma` API\n */\nexport let onigasmH\n\nasync function initModule(bytes: ArrayBuffer) {\n    return new Promise((resolve, reject) => {\n        const { log, warn, error } = console\n        OnigasmModuleFactory({\n            instantiateWasm(imports, successCallback) {\n                WebAssembly.instantiate(bytes, imports)\n                    .then((output) => {\n                        successCallback(output.instance)\n                    })\n                    .catch((e) => {\n                        throw e\n                    })\n                return {}\n            },\n        })\n            .then(moduleH => {\n                onigasmH = moduleH\n                resolve()\n            })\n        if (typeof print !== 'undefined') {\n            // can be removed when https://github.com/emscripten-core/emscripten/issues/9829 is fixed.\n            // tslint:disable-next-line:no-console\n            console.log = log\n            // tslint:disable-next-line:no-console\n            console.error = error\n            // tslint:disable-next-line:no-console\n            console.warn = warn\n        }\n    })\n}\n\nlet isInitialized = false\n\n/**\n * Mount the .wasm file that will act as library's \"backend\"\n * @param data Path to .wasm file or it's ArrayBuffer\n */\nexport async function loadWASM(data: string | ArrayBuffer) {\n    if (isInitialized) {\n        throw new Error(`Onigasm#init has been called and was succesful, subsequent calls are not allowed once initialized`)\n    }\n    if (typeof data === 'string') {\n        const arrayBuffer = await (await fetch(data)).arrayBuffer()\n        await initModule(arrayBuffer)\n    } else if (data instanceof ArrayBuffer) {\n        await initModule(data)\n    } else {\n        throw new TypeError(`Expected a string (URL of .wasm file) or ArrayBuffer (.wasm file itself) as first parameter`)\n    }\n\n    isInitialized = true\n}\n","'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n","'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount /*, ...nodes */) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 2; i < arguments.length; i++) {\n    walker = insert(this, walker, arguments[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n","'use strict'\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = require('yallist')\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n","\ntype UintArray = Uint8Array | Uint16Array | Uint32Array\n\nclass OnigString {\n    private source: string\n    private _utf8Bytes: Uint8Array | null\n\n    /**\n     * utf16-offset where the mapping table starts. Before that index: utf16-index === utf8-index\n     */\n    private _mappingTableStartOffset: number\n    /**\n     * utf-16 to utf-8 mapping table for all uft-8 indexes starting at `_mappingTableStartOffset`. utf8-index are always starting at 0.\n     * `null` if there are no multibyte characters in the utf8 string and all utf-8 indexes are matching the utf-16 indexes.\n     * Example: _mappingTableStartOffset === 10, _utf16OffsetToUtf8 = [0, 3, 6] -> _utf8Indexes[10] = 10, _utf8Indexes[11] = 13\n     */\n    private _utf8Indexes: UintArray | null\n\n    constructor(content: string) {\n        if (typeof content !== 'string') {\n            throw new TypeError('Argument must be a string')\n        }\n        this.source = content\n        this._utf8Bytes = null\n        this._utf8Indexes = null\n\n    }\n\n    public get utf8Bytes(): Uint8Array {\n        if (!this._utf8Bytes) {\n            this.encode()\n        }\n        return this._utf8Bytes\n    }\n\n    /**\n     * Returns `null` if all utf8 offsets match utf-16 offset (content has no multi byte characters)\n     */\n    private get utf8Indexes(): UintArray {\n        if (!this._utf8Bytes) {\n            this.encode()\n        }\n        return this._utf8Indexes\n    }\n\n    public get content(): string {\n        return this.source\n    }\n\n    public get length(): number {\n        return this.source.length\n    }\n\n    public substring = (start, end) => {\n        return this.source.substring(start, end)\n    }\n\n    public toString = (start, end) => {\n        return this.source\n    }\n\n    public get hasMultiByteCharacters() {\n        return this.utf8Indexes !== null\n    }\n\n    public convertUtf8OffsetToUtf16(utf8Offset: number): number {\n        if (utf8Offset < 0) {\n            return 0\n        }\n        const utf8Array = this._utf8Bytes\n        if (utf8Offset >= utf8Array.length - 1) {\n            return this.source.length\n        }\n\n        const utf8OffsetMap = this.utf8Indexes\n        if (utf8OffsetMap && utf8Offset >= this._mappingTableStartOffset) {\n            return findFirstInSorted(utf8OffsetMap, utf8Offset - this._mappingTableStartOffset) + this._mappingTableStartOffset\n        }\n        return utf8Offset\n    }\n\n    public convertUtf16OffsetToUtf8(utf16Offset: number): number {\n        if (utf16Offset < 0) {\n            return 0\n        }\n        const utf8Array = this._utf8Bytes\n        if (utf16Offset >= this.source.length) {\n            return utf8Array.length - 1\n        }\n\n        const utf8OffsetMap = this.utf8Indexes\n        if (utf8OffsetMap && utf16Offset >= this._mappingTableStartOffset) {\n            return utf8OffsetMap[utf16Offset - this._mappingTableStartOffset] + this._mappingTableStartOffset\n        }\n        return utf16Offset\n    }\n\n    private encode(): void {\n        const str = this.source\n        const n = str.length\n        let utf16OffsetToUtf8: UintArray\n        let utf8Offset = 0\n        let mappingTableStartOffset = 0\n        function createOffsetTable(startOffset: number) {\n            const maxUtf8Len = (n - startOffset) * 3\n            if (maxUtf8Len <= 0xff) {\n                utf16OffsetToUtf8 = new Uint8Array(n - startOffset)\n            } else if (maxUtf8Len <= 0xffff) {\n                utf16OffsetToUtf8 = new Uint16Array(n - startOffset)\n            } else {\n                utf16OffsetToUtf8 = new Uint32Array(n - startOffset)\n            }\n            mappingTableStartOffset = startOffset\n            utf16OffsetToUtf8[utf8Offset++] = 0\n        }\n\n        const u8view = new Uint8Array((n * 3) /* alloc max now, trim later*/ + 1 /** null termination character */)\n\n        let ptrHead = 0\n        let i = 0\n        // for some reason, v8 is faster with str.length than using a variable (might be illusion)\n        while (i < str.length) {\n            let codepoint\n            const c = str.charCodeAt(i)\n\n            if (utf16OffsetToUtf8) {\n                utf16OffsetToUtf8[utf8Offset++] = ptrHead - mappingTableStartOffset\n            }\n\n            if (c < 0xD800 || c > 0xDFFF) {\n                codepoint = c\n            }\n\n            else if (c >= 0xDC00) {\n                codepoint = 0xFFFD\n            }\n\n            else {\n                if (i === n - 1) {\n                    codepoint = 0xFFFD\n                }\n                else {\n                    const d = str.charCodeAt(i + 1)\n\n                    if (0xDC00 <= d && d <= 0xDFFF) {\n                        if (!utf16OffsetToUtf8) {\n                            createOffsetTable(i)\n                        }\n\n                        const a = c & 0x3FF\n\n                        const b = d & 0x3FF\n\n                        codepoint = 0x10000 + (a << 10) + b\n                        i += 1\n\n                        utf16OffsetToUtf8[utf8Offset++] = ptrHead - mappingTableStartOffset\n                    }\n\n                    else {\n                        codepoint = 0xFFFD\n                    }\n                }\n            }\n\n            let bytesRequiredToEncode: number\n            let offset: number\n\n            if (codepoint <= 0x7F) {\n                bytesRequiredToEncode = 1\n                offset = 0\n            } else if (codepoint <= 0x07FF) {\n                bytesRequiredToEncode = 2\n                offset = 0xC0\n            } else if (codepoint <= 0xFFFF) {\n                bytesRequiredToEncode = 3\n                offset = 0xE0\n            } else {\n                bytesRequiredToEncode = 4\n                offset = 0xF0\n            }\n\n            if (bytesRequiredToEncode === 1) {\n                u8view[ptrHead++] = codepoint\n            }\n            else {\n                if (!utf16OffsetToUtf8) {\n                    createOffsetTable(ptrHead)\n                }\n                u8view[ptrHead++] = (codepoint >> (6 * (--bytesRequiredToEncode))) + offset\n\n                while (bytesRequiredToEncode > 0) {\n\n                    const temp = codepoint >> (6 * (bytesRequiredToEncode - 1))\n\n                    u8view[ptrHead++] = (0x80 | (temp & 0x3F))\n\n                    bytesRequiredToEncode -= 1\n                }\n            }\n\n            i += 1\n        }\n\n        const utf8 = u8view.slice(0, ptrHead + 1)\n        utf8[ptrHead] = 0x00\n\n        this._utf8Bytes = utf8\n        if (utf16OffsetToUtf8) { // set if UTF-16 surrogate chars or multi-byte characters found\n            this._utf8Indexes = utf16OffsetToUtf8\n            this._mappingTableStartOffset = mappingTableStartOffset\n        }\n    }\n}\n\nfunction findFirstInSorted<T>(array: UintArray, i: number): number {\n    let low = 0\n    let high = array.length\n\n    if (high === 0) {\n        return 0 // no children\n    }\n    while (low < high) {\n        const mid = Math.floor((low + high) / 2)\n        if (array[mid] >= i) {\n            high = mid\n        } else {\n            low = mid + 1\n        }\n    }\n\n    // low is on the index of the first value >= i or array.length. Decrement low until we find array[low] <= i\n    while (low > 0 && (low >= array.length || array[low] > i)) {\n        low--\n    }\n    // check whether we are on the second index of a utf-16 surrogate char. If so, go to the first index.\n    if (low > 0 && array[low] === array[low - 1]) {\n        low--\n    }\n\n    return low\n\n}\n\nexport default OnigString\n","import * as LRUCache from 'lru-cache'\nimport { onigasmH } from './onigasmH'\nimport OnigString from './OnigString'\n\n/**\n * Every instance of OnigScanner internally calls native libonig API\n * Since (at the moment) transferring complex objects between C runtime and JS runtime is not easy,\n * pointers are used to tap into their runtimes to read values (for example result of regex match)\n */\ninterface INativeOnigHInfo {\n    /**\n     * regex_t* is used by libonig to match string against an expression\n     * this is the output of compiling raw string pattern to libonig's internal representation\n     */\n    regexTPtrs: Uint8Array | null\n}\n\nexport interface IOnigCaptureIndex {\n    index: number\n    start: number\n    end: number\n    length: number\n}\n\nexport interface IOnigMatch {\n    index: number\n    captureIndices: IOnigCaptureIndex[]\n    scanner: OnigScanner\n}\n\n/**\n * Allocates space on the heap and copies the string bytes on to it\n * @param str\n * @returns pointer to the first byte's address on heap\n */\nfunction mallocAndWriteString(str: OnigString): number {\n    const ptr = onigasmH._malloc(str.utf8Bytes.length)\n    onigasmH.HEAPU8.set(str.utf8Bytes, ptr)\n    return ptr\n}\n\nfunction convertUTF8BytesFromPtrToString(ptr: number): string {\n    const chars = []\n    let i = 0\n    while (onigasmH.HEAPU8[ptr] !== 0x00) {\n        chars[i++] = onigasmH.HEAPU8[ptr++]\n    }\n    return chars.join()\n}\n\nconst cache = new LRUCache<OnigScanner, INativeOnigHInfo>({\n    dispose: (scanner: OnigScanner, info: INativeOnigHInfo) => {\n        const regexTPtrsPtr = onigasmH._malloc(info.regexTPtrs.length)\n        onigasmH.HEAPU8.set(info.regexTPtrs, regexTPtrsPtr)\n        const status = onigasmH._disposeCompiledPatterns(regexTPtrsPtr, scanner.patterns.length)\n        if (status !== 0) {\n            const errMessage = convertUTF8BytesFromPtrToString(onigasmH._getLastError())\n            throw new Error(errMessage)\n        }\n        onigasmH._free(regexTPtrsPtr)\n    },\n    max: 1000,\n})\n\nexport class OnigScanner {\n    private sources: string[]\n    /**\n     * Create a new scanner with the given patterns\n     * @param patterns  An array of string patterns\n     */\n    constructor(patterns: string[]) {\n        if (onigasmH === null) {\n            throw new Error(`Onigasm has not been initialized, call loadWASM from 'onigasm' exports before using any other API`)\n        }\n        for (let i = 0; i < patterns.length; i++) {\n            const pattern = patterns[i]\n            if (typeof pattern !== 'string') {\n                throw new TypeError(`First parameter to OnigScanner constructor must be array of (pattern) strings`)\n            }\n        }\n        this.sources = patterns.slice()\n    }\n\n    public get patterns() {\n        return this.sources.slice()\n    }\n\n    /**\n     * Find the next match from a given position\n     * @param string The string to search\n     * @param startPosition The optional position to start at, defaults to 0\n     * @param callback The (error, match) function to call when done, match will null when there is no match\n     */\n    public findNextMatch(string: string | OnigString, startPosition: number, callback: (err, match?: IOnigMatch) => void) {\n        if (startPosition == null) { startPosition = 0 }\n        if (typeof startPosition === 'function') {\n            callback = startPosition\n            startPosition = 0\n        }\n\n        try {\n            const match = this.findNextMatchSync(string, startPosition)\n            callback(null, match)\n        } catch (error) {\n            callback(error)\n        }\n    }\n\n    /**\n     * Find the next match from a given position\n     * @param string The string to search\n     * @param startPosition The optional position to start at, defaults to 0\n     */\n    public findNextMatchSync(string: string | OnigString, startPosition: number): IOnigMatch {\n        if (startPosition == null) { startPosition = 0 }\n        startPosition = this.convertToNumber(startPosition)\n\n        let onigNativeInfo = cache.get(this)\n        let status = 0\n        if (!onigNativeInfo) {\n            const regexTAddrRecieverPtr = onigasmH._malloc(4)\n            const regexTPtrs = []\n            for (let i = 0; i < this.sources.length; i++) {\n                const pattern = this.sources[i]\n                const patternStrPtr = mallocAndWriteString(new OnigString(pattern))\n                status = onigasmH._compilePattern(patternStrPtr, regexTAddrRecieverPtr)\n                if (status !== 0) {\n                    const errMessage = convertUTF8BytesFromPtrToString(onigasmH._getLastError())\n                    throw new Error(errMessage)\n                }\n                const regexTAddress = onigasmH.HEAP32[regexTAddrRecieverPtr / 4]\n                regexTPtrs.push(regexTAddress)\n                onigasmH._free(patternStrPtr)\n            }\n            onigNativeInfo = {\n                regexTPtrs: new Uint8Array(Uint32Array.from(regexTPtrs).buffer),\n            }\n            onigasmH._free(regexTAddrRecieverPtr)\n            cache.set(this, onigNativeInfo)\n        }\n\n        const onigString = string instanceof OnigString ? string : new OnigString(this.convertToString(string))\n        const strPtr = mallocAndWriteString(onigString)\n        const resultInfoReceiverPtr = onigasmH._malloc(8)\n        const regexTPtrsPtr = onigasmH._malloc(onigNativeInfo.regexTPtrs.length)\n        onigasmH.HEAPU8.set(onigNativeInfo.regexTPtrs, regexTPtrsPtr)\n\n        status = onigasmH._findBestMatch(\n            // regex_t **patterns\n            regexTPtrsPtr,\n            // int patternCount\n            this.sources.length,\n            // UChar *utf8String\n            strPtr,\n            // int strLen\n            onigString.utf8Bytes.length - 1,\n            // int startOffset\n            onigString.convertUtf16OffsetToUtf8(startPosition),\n            // int *resultInfo\n            resultInfoReceiverPtr,\n        )\n\n        if (status !== 0) {\n            const errMessage = convertUTF8BytesFromPtrToString(onigasmH._getLastError())\n            throw new Error(errMessage)\n        }\n        const [\n            // The index of pattern which matched the string at least offset from 0 (start)\n            bestPatternIdx,\n\n            // Begin address of capture info encoded as pairs\n            // like [start, end, start, end, start, end, ...]\n            //  - first start-end pair is entire match (index 0 and 1)\n            //  - subsequent pairs are capture groups (2, 3 = first capture group, 4, 5 = second capture group and so on)\n            encodedResultBeginAddress,\n\n            // Length of the [start, end, ...] sequence so we know how much memory to read (will always be 0 or multiple of 2)\n            encodedResultLength,\n        ] = new Uint32Array(onigasmH.HEAPU32.buffer, resultInfoReceiverPtr, 3)\n\n        onigasmH._free(strPtr)\n        onigasmH._free(resultInfoReceiverPtr)\n        onigasmH._free(regexTPtrsPtr)\n\n        if (encodedResultLength > 0) {\n            const encodedResult = new Uint32Array(onigasmH.HEAPU32.buffer, encodedResultBeginAddress, encodedResultLength)\n            const captureIndices = []\n            let i = 0\n            let captureIdx = 0\n            while (i < encodedResultLength) {\n                const index = captureIdx++\n                let start = encodedResult[i++]\n                let end = encodedResult[i++]\n                if (onigString.hasMultiByteCharacters) {\n                    start = onigString.convertUtf8OffsetToUtf16(start)\n                    end = onigString.convertUtf8OffsetToUtf16(end)\n                }\n                captureIndices.push({\n                    end,\n                    index,\n                    length: end - start,\n                    start,\n                })\n            }\n            onigasmH._free(encodedResultBeginAddress)\n            return {\n                captureIndices,\n                index: bestPatternIdx,\n                scanner: this,\n            }\n        }\n        return null\n    }\n\n    public convertToString(value) {\n        if (value === undefined) { return 'undefined' }\n        if (value === null) { return 'null' }\n        if (value instanceof OnigString) { return value.content }\n        return value.toString()\n    }\n\n    public convertToNumber(value) {\n        value = parseInt(value, 10)\n        if (!isFinite(value)) { value = 0 }\n        value = Math.max(value, 0)\n        return value\n    }\n}\n\nexport default OnigScanner\n","import OnigScanner, { IOnigCaptureIndex } from './OnigScanner'\nimport OnigString from './OnigString'\n\nexport interface IOnigSearchResult extends IOnigCaptureIndex {\n    match: string\n}\n\nclass OnigRegExp {\n    private source: string\n    private scanner: OnigScanner\n    /**\n     * Create a new regex with the given pattern\n     * @param source A string pattern\n     */\n    constructor(source: string) {\n        this.source = source\n\n        try {\n            this.scanner = new OnigScanner([this.source])\n        } catch (error) {\n            // doesn't make much sense, but this to pass atom/node-oniguruam tests\n        }\n    }\n\n    /**\n     * Synchronously search the string for a match starting at the given position\n     * @param string The string to search\n     * @param startPosition The optional position to start the search at, defaults to `0`\n     */\n    public searchSync(string: string | OnigString, startPosition?: number): IOnigSearchResult[] {\n        let match\n        if (startPosition == null) {\n            startPosition = 0\n        }\n        match = this.scanner.findNextMatchSync(string, startPosition)\n        return this.captureIndicesForMatch(string, match)\n    }\n\n    /**\n     * Search the string for a match starting at the given position\n     * @param string The string to search\n     * @param startPosition The optional position to start the search at, defaults to `0`\n     * @param callback The `(error, match)` function to call when done, match will be null if no matches were found. match will be an array of objects for each matched group on a successful search\n     */\n    public search(string: string | OnigString, startPosition?: number, callback?: (error: any, match?: IOnigSearchResult[]) => void) {\n        if (startPosition == null) {\n            startPosition = 0\n        }\n        if (typeof startPosition === 'function') {\n            callback = startPosition\n            startPosition = 0\n        }\n        try {\n            const ret = this.searchSync(string, startPosition)\n            callback(null, ret)\n        } catch (error) {\n            callback(error)\n        }\n    }\n\n    /**\n     * Synchronously test if this regular expression matches the given string\n     * @param string The string to test against\n     */\n    public testSync(string: string | OnigString): boolean {\n        if ((typeof this.source === 'boolean' || typeof string === 'boolean')) {\n            return this.source === string\n        }\n        return this.searchSync(string) != null\n    }\n\n    /**\n     * Test if this regular expression matches the given string\n     * @param string The string to test against\n     * @param callback The (error, matches) function to call when done, matches will be true if at least one match is found, false otherwise\n     */\n    public test(string: string | OnigString, callback?: (error: any, matches?: boolean) => void) {\n        if (typeof callback !== 'function') {\n            callback = () => { }\n        }\n        try {\n            callback(null, this.testSync(string))\n        } catch (error) {\n            callback(error)\n        }\n    }\n\n    private captureIndicesForMatch(string: string | OnigString, match) {\n        if (match != null) {\n            const { captureIndices } = match\n            let capture\n            string = this.scanner.convertToString(string)\n            for (let i = 0; i < captureIndices.length; i++) {\n                capture = captureIndices[i]\n                capture.match = (string as string).slice(capture.start, capture.end)\n            }\n            return captureIndices\n        } else {\n            return null\n        }\n    }\n}\n\nexport default OnigRegExp\n","import { loadWASM } from './onigasmH'\nimport OnigRegExp, { IOnigSearchResult } from './OnigRegExp'\nimport OnigScanner, { IOnigCaptureIndex } from './OnigScanner'\nimport OnigString from './OnigString'\n\nexport { loadWASM, OnigScanner, OnigRegExp, OnigString, IOnigCaptureIndex, IOnigSearchResult }\n","/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport * as path from 'path';\nimport { RegexSource, mergeObjects } from './utils';\nimport { ILocation, IRawGrammar, IRawRepository, IRawRule, IRawCaptures } from './types';\nimport { OnigString, OnigScanner, IOnigCaptureIndex } from 'onigasm';\n\nconst HAS_BACK_REFERENCES = /\\\\(\\d+)/;\nconst BACK_REFERENCING_END = /\\\\(\\d+)/g;\n\nexport interface IRuleRegistry {\n\tgetRule(patternId: number): Rule;\n\tregisterRule<T extends Rule>(factory: (id: number) => T): T;\n}\n\nexport interface IGrammarRegistry {\n\tgetExternalGrammar(scopeName: string, repository: IRawRepository): IRawGrammar;\n}\n\nexport interface IRuleFactoryHelper extends IRuleRegistry, IGrammarRegistry {\n}\n\nexport interface ICompiledRule {\n\treadonly scanner: OnigScanner;\n\treadonly rules: number[];\n\treadonly debugRegExps: string[];\n}\n\nexport abstract class Rule {\n\n\tpublic readonly $location: ILocation;\n\tpublic readonly id: number;\n\n\tprivate readonly _nameIsCapturing: boolean;\n\tprivate readonly _name: string;\n\n\tprivate readonly _contentNameIsCapturing: boolean;\n\tprivate readonly _contentName: string;\n\n\tconstructor($location: ILocation, id: number, name: string, contentName: string) {\n\t\tthis.$location = $location;\n\t\tthis.id = id;\n\t\tthis._name = name || null;\n\t\tthis._nameIsCapturing = RegexSource.hasCaptures(this._name);\n\t\tthis._contentName = contentName || null;\n\t\tthis._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);\n\t}\n\n\tpublic get debugName(): string {\n\t\treturn `${(<any>this.constructor).name}#${this.id} @ ${path.basename(this.$location.filename)}:${this.$location.line}`;\n\t}\n\n\tpublic getName(lineText: string, captureIndices: IOnigCaptureIndex[]): string {\n\t\tif (!this._nameIsCapturing) {\n\t\t\treturn this._name;\n\t\t}\n\t\treturn RegexSource.replaceCaptures(this._name, lineText, captureIndices);\n\t}\n\n\tpublic getContentName(lineText: string, captureIndices: IOnigCaptureIndex[]): string {\n\t\tif (!this._contentNameIsCapturing) {\n\t\t\treturn this._contentName;\n\t\t}\n\t\treturn RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);\n\t}\n\n\tpublic collectPatternsRecursive(grammar: IRuleRegistry, out: RegExpSourceList, isFirst: boolean) {\n\t\tthrow new Error('Implement me!');\n\t}\n\n\tpublic compile(grammar: IRuleRegistry, endRegexSource: string, allowA: boolean, allowG: boolean): ICompiledRule {\n\t\tthrow new Error('Implement me!');\n\t}\n}\n\nexport interface ICompilePatternsResult {\n\treadonly patterns: number[];\n\treadonly hasMissingPatterns: boolean;\n}\n\nexport class CaptureRule extends Rule {\n\n\tpublic readonly retokenizeCapturedWithRuleId: number;\n\n\tconstructor($location: ILocation, id: number, name: string, contentName: string, retokenizeCapturedWithRuleId: number) {\n\t\tsuper($location, id, name, contentName);\n\t\tthis.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;\n\t}\n}\n\ninterface IRegExpSourceAnchorCache {\n\treadonly A0_G0: string;\n\treadonly A0_G1: string;\n\treadonly A1_G0: string;\n\treadonly A1_G1: string;\n}\n\nexport class RegExpSource {\n\n\tpublic source: string;\n\tpublic readonly ruleId: number;\n\tpublic hasAnchor: boolean;\n\tpublic readonly hasBackReferences: boolean;\n\tprivate _anchorCache: IRegExpSourceAnchorCache;\n\n\tconstructor(regExpSource: string, ruleId: number, handleAnchors: boolean = true) {\n\t\tif (handleAnchors) {\n\t\t\tthis._handleAnchors(regExpSource);\n\t\t} else {\n\t\t\tthis.source = regExpSource;\n\t\t\tthis.hasAnchor = false;\n\t\t}\n\n\t\tif (this.hasAnchor) {\n\t\t\tthis._anchorCache = this._buildAnchorCache();\n\t\t}\n\n\t\tthis.ruleId = ruleId;\n\t\tthis.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);\n\n\t\t// console.log('input: ' + regExpSource + ' => ' + this.source + ', ' + this.hasAnchor);\n\t}\n\n\tpublic clone(): RegExpSource {\n\t\treturn new RegExpSource(this.source, this.ruleId, true);\n\t}\n\n\tpublic setSource(newSource: string): void {\n\t\tif (this.source === newSource) {\n\t\t\treturn;\n\t\t}\n\t\tthis.source = newSource;\n\n\t\tif (this.hasAnchor) {\n\t\t\tthis._anchorCache = this._buildAnchorCache();\n\t\t}\n\t}\n\n\tprivate _handleAnchors(regExpSource: string): void {\n\t\tif (regExpSource) {\n\t\t\tlet pos: number,\n\t\t\t\tlen: number,\n\t\t\t\tch: string,\n\t\t\t\tnextCh: string,\n\t\t\t\tlastPushedPos = 0,\n\t\t\t\toutput: string[] = [];\n\n\t\t\tlet hasAnchor = false;\n\t\t\tfor (pos = 0, len = regExpSource.length; pos < len; pos++) {\n\t\t\t\tch = regExpSource.charAt(pos);\n\n\t\t\t\tif (ch === '\\\\') {\n\t\t\t\t\tif (pos + 1 < len) {\n\t\t\t\t\t\tnextCh = regExpSource.charAt(pos + 1);\n\t\t\t\t\t\tif (nextCh === 'z') {\n\t\t\t\t\t\t\toutput.push(regExpSource.substring(lastPushedPos, pos));\n\t\t\t\t\t\t\toutput.push('$(?!\\\\n)(?<!\\\\n)');\n\t\t\t\t\t\t\tlastPushedPos = pos + 2;\n\t\t\t\t\t\t} else if (nextCh === 'A' || nextCh === 'G') {\n\t\t\t\t\t\t\thasAnchor = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.hasAnchor = hasAnchor;\n\t\t\tif (lastPushedPos === 0) {\n\t\t\t\t// No \\z hit\n\t\t\t\tthis.source = regExpSource;\n\t\t\t} else {\n\t\t\t\toutput.push(regExpSource.substring(lastPushedPos, len));\n\t\t\t\tthis.source = output.join('');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.hasAnchor = false;\n\t\t\tthis.source = regExpSource;\n\t\t}\n\t}\n\n\tpublic resolveBackReferences(lineText: string, captureIndices: IOnigCaptureIndex[]): string {\n\t\tlet capturedValues = captureIndices.map((capture) => {\n\t\t\treturn lineText.substring(capture.start, capture.end);\n\t\t});\n\t\tBACK_REFERENCING_END.lastIndex = 0;\n\t\treturn this.source.replace(BACK_REFERENCING_END, (match, g1) => {\n\t\t\treturn escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || '');\n\t\t});\n\t}\n\n\tprivate _buildAnchorCache(): IRegExpSourceAnchorCache {\n\t\tlet A0_G0_result: string[] = [];\n\t\tlet A0_G1_result: string[] = [];\n\t\tlet A1_G0_result: string[] = [];\n\t\tlet A1_G1_result: string[] = [];\n\n\t\tlet pos: number,\n\t\t\tlen: number,\n\t\t\tch: string,\n\t\t\tnextCh: string;\n\n\t\tfor (pos = 0, len = this.source.length; pos < len; pos++) {\n\t\t\tch = this.source.charAt(pos);\n\t\t\tA0_G0_result[pos] = ch;\n\t\t\tA0_G1_result[pos] = ch;\n\t\t\tA1_G0_result[pos] = ch;\n\t\t\tA1_G1_result[pos] = ch;\n\n\t\t\tif (ch === '\\\\') {\n\t\t\t\tif (pos + 1 < len) {\n\t\t\t\t\tnextCh = this.source.charAt(pos + 1);\n\t\t\t\t\tif (nextCh === 'A') {\n\t\t\t\t\t\tA0_G0_result[pos + 1] = '\\uFFFF';\n\t\t\t\t\t\tA0_G1_result[pos + 1] = '\\uFFFF';\n\t\t\t\t\t\tA1_G0_result[pos + 1] = 'A';\n\t\t\t\t\t\tA1_G1_result[pos + 1] = 'A';\n\t\t\t\t\t} else if (nextCh === 'G') {\n\t\t\t\t\t\tA0_G0_result[pos + 1] = '\\uFFFF';\n\t\t\t\t\t\tA0_G1_result[pos + 1] = 'G';\n\t\t\t\t\t\tA1_G0_result[pos + 1] = '\\uFFFF';\n\t\t\t\t\t\tA1_G1_result[pos + 1] = 'G';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tA0_G0_result[pos + 1] = nextCh;\n\t\t\t\t\t\tA0_G1_result[pos + 1] = nextCh;\n\t\t\t\t\t\tA1_G0_result[pos + 1] = nextCh;\n\t\t\t\t\t\tA1_G1_result[pos + 1] = nextCh;\n\t\t\t\t\t}\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tA0_G0: A0_G0_result.join(''),\n\t\t\tA0_G1: A0_G1_result.join(''),\n\t\t\tA1_G0: A1_G0_result.join(''),\n\t\t\tA1_G1: A1_G1_result.join('')\n\t\t};\n\t}\n\n\tpublic resolveAnchors(allowA: boolean, allowG: boolean): string {\n\t\tif (!this.hasAnchor) {\n\t\t\treturn this.source;\n\t\t}\n\n\t\tif (allowA) {\n\t\t\tif (allowG) {\n\t\t\t\treturn this._anchorCache.A1_G1;\n\t\t\t} else {\n\t\t\t\treturn this._anchorCache.A1_G0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (allowG) {\n\t\t\t\treturn this._anchorCache.A0_G1;\n\t\t\t} else {\n\t\t\t\treturn this._anchorCache.A0_G0;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninterface IRegExpSourceListAnchorCache {\n\tA0_G0: ICompiledRule;\n\tA0_G1: ICompiledRule;\n\tA1_G0: ICompiledRule;\n\tA1_G1: ICompiledRule;\n}\n\nfunction createOnigScanner(sources: string[]): OnigScanner {\n\treturn new OnigScanner(sources);\n}\n\nexport function createOnigString(sources: string): OnigString {\n\tvar r = new OnigString(sources);\n\t(<any>r).$str = sources;\n\treturn r;\n}\n\nexport function getString(str: OnigString): string {\n\treturn (<any>str).$str;\n}\n\nexport class RegExpSourceList {\n\n\tprivate readonly _items: RegExpSource[];\n\tprivate _hasAnchors: boolean;\n\tprivate _cached: ICompiledRule;\n\tprivate _anchorCache: IRegExpSourceListAnchorCache;\n\tprivate readonly _cachedSources: string[];\n\n\tconstructor() {\n\t\tthis._items = [];\n\t\tthis._hasAnchors = false;\n\t\tthis._cached = null;\n\t\tthis._cachedSources = null;\n\t\tthis._anchorCache = {\n\t\t\tA0_G0: null,\n\t\t\tA0_G1: null,\n\t\t\tA1_G0: null,\n\t\t\tA1_G1: null\n\t\t};\n\t}\n\n\tpublic push(item: RegExpSource): void {\n\t\tthis._items.push(item);\n\t\tthis._hasAnchors = this._hasAnchors || item.hasAnchor;\n\t}\n\n\tpublic unshift(item: RegExpSource): void {\n\t\tthis._items.unshift(item);\n\t\tthis._hasAnchors = this._hasAnchors || item.hasAnchor;\n\t}\n\n\tpublic length(): number {\n\t\treturn this._items.length;\n\t}\n\n\tpublic setSource(index: number, newSource: string): void {\n\t\tif (this._items[index].source !== newSource) {\n\t\t\t// bust the cache\n\t\t\tthis._cached = null;\n\t\t\tthis._anchorCache.A0_G0 = null;\n\t\t\tthis._anchorCache.A0_G1 = null;\n\t\t\tthis._anchorCache.A1_G0 = null;\n\t\t\tthis._anchorCache.A1_G1 = null;\n\t\t\tthis._items[index].setSource(newSource);\n\t\t}\n\t}\n\n\tpublic compile(grammar: IRuleRegistry, allowA: boolean, allowG: boolean): ICompiledRule {\n\t\tif (!this._hasAnchors) {\n\t\t\tif (!this._cached) {\n\t\t\t\tlet regExps = this._items.map(e => e.source);\n\t\t\t\tthis._cached = {\n\t\t\t\t\tscanner: createOnigScanner(regExps),\n\t\t\t\t\trules: this._items.map(e => e.ruleId),\n\t\t\t\t\tdebugRegExps: regExps\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn this._cached;\n\t\t} else {\n\t\t\tthis._anchorCache = {\n\t\t\t\tA0_G0: this._anchorCache.A0_G0 || (allowA === false && allowG === false ? this._resolveAnchors(allowA, allowG) : null),\n\t\t\t\tA0_G1: this._anchorCache.A0_G1 || (allowA === false && allowG === true ? this._resolveAnchors(allowA, allowG) : null),\n\t\t\t\tA1_G0: this._anchorCache.A1_G0 || (allowA === true && allowG === false ? this._resolveAnchors(allowA, allowG) : null),\n\t\t\t\tA1_G1: this._anchorCache.A1_G1 || (allowA === true && allowG === true ? this._resolveAnchors(allowA, allowG) : null),\n\t\t\t};\n\t\t\tif (allowA) {\n\t\t\t\tif (allowG) {\n\t\t\t\t\treturn this._anchorCache.A1_G1;\n\t\t\t\t} else {\n\t\t\t\t\treturn this._anchorCache.A1_G0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (allowG) {\n\t\t\t\t\treturn this._anchorCache.A0_G1;\n\t\t\t\t} else {\n\t\t\t\t\treturn this._anchorCache.A0_G0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate _resolveAnchors(allowA: boolean, allowG: boolean): ICompiledRule {\n\t\tlet regExps = this._items.map(e => e.resolveAnchors(allowA, allowG));\n\t\treturn {\n\t\t\tscanner: createOnigScanner(regExps),\n\t\t\trules: this._items.map(e => e.ruleId),\n\t\t\tdebugRegExps: regExps\n\t\t};\n\t}\n}\n\nexport class MatchRule extends Rule {\n\tprivate readonly _match: RegExpSource;\n\tpublic readonly captures: CaptureRule[];\n\tprivate _cachedCompiledPatterns: RegExpSourceList;\n\n\tconstructor($location: ILocation, id: number, name: string, match: string, captures: CaptureRule[]) {\n\t\tsuper($location, id, name, null);\n\t\tthis._match = new RegExpSource(match, this.id);\n\t\tthis.captures = captures;\n\t\tthis._cachedCompiledPatterns = null;\n\t}\n\n\tpublic get debugMatchRegExp(): string {\n\t\treturn `${this._match.source}`;\n\t}\n\n\tpublic collectPatternsRecursive(grammar: IRuleRegistry, out: RegExpSourceList, isFirst: boolean) {\n\t\tout.push(this._match);\n\t}\n\n\tpublic compile(grammar: IRuleRegistry, endRegexSource: string, allowA: boolean, allowG: boolean): ICompiledRule {\n\t\tif (!this._cachedCompiledPatterns) {\n\t\t\tthis._cachedCompiledPatterns = new RegExpSourceList();\n\t\t\tthis.collectPatternsRecursive(grammar, this._cachedCompiledPatterns, true);\n\t\t}\n\t\treturn this._cachedCompiledPatterns.compile(grammar, allowA, allowG);\n\t}\n}\n\nexport class IncludeOnlyRule extends Rule {\n\tpublic readonly hasMissingPatterns: boolean;\n\tpublic readonly patterns: number[];\n\tprivate _cachedCompiledPatterns: RegExpSourceList;\n\n\tconstructor($location: ILocation, id: number, name: string, contentName: string, patterns: ICompilePatternsResult) {\n\t\tsuper($location, id, name, contentName);\n\t\tthis.patterns = patterns.patterns;\n\t\tthis.hasMissingPatterns = patterns.hasMissingPatterns;\n\t\tthis._cachedCompiledPatterns = null;\n\t}\n\n\tpublic collectPatternsRecursive(grammar: IRuleRegistry, out: RegExpSourceList, isFirst: boolean) {\n\t\tlet i: number,\n\t\t\tlen: number,\n\t\t\trule: Rule;\n\n\t\tfor (i = 0, len = this.patterns.length; i < len; i++) {\n\t\t\trule = grammar.getRule(this.patterns[i]);\n\t\t\trule.collectPatternsRecursive(grammar, out, false);\n\t\t}\n\t}\n\n\tpublic compile(grammar: IRuleRegistry, endRegexSource: string, allowA: boolean, allowG: boolean): ICompiledRule {\n\t\tif (!this._cachedCompiledPatterns) {\n\t\t\tthis._cachedCompiledPatterns = new RegExpSourceList();\n\t\t\tthis.collectPatternsRecursive(grammar, this._cachedCompiledPatterns, true);\n\t\t}\n\t\treturn this._cachedCompiledPatterns.compile(grammar, allowA, allowG);\n\t}\n}\n\nfunction escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&');\n}\n\nexport class BeginEndRule extends Rule {\n\tprivate readonly _begin: RegExpSource;\n\tpublic readonly beginCaptures: CaptureRule[];\n\tprivate readonly _end: RegExpSource;\n\tpublic readonly endHasBackReferences: boolean;\n\tpublic readonly endCaptures: CaptureRule[];\n\tpublic readonly applyEndPatternLast: boolean;\n\tpublic readonly hasMissingPatterns: boolean;\n\tpublic readonly patterns: number[];\n\tprivate _cachedCompiledPatterns: RegExpSourceList;\n\n\tconstructor($location: ILocation, id: number, name: string, contentName: string, begin: string, beginCaptures: CaptureRule[], end: string, endCaptures: CaptureRule[], applyEndPatternLast: boolean, patterns: ICompilePatternsResult) {\n\t\tsuper($location, id, name, contentName);\n\t\tthis._begin = new RegExpSource(begin, this.id);\n\t\tthis.beginCaptures = beginCaptures;\n\t\tthis._end = new RegExpSource(end, -1);\n\t\tthis.endHasBackReferences = this._end.hasBackReferences;\n\t\tthis.endCaptures = endCaptures;\n\t\tthis.applyEndPatternLast = applyEndPatternLast || false;\n\t\tthis.patterns = patterns.patterns;\n\t\tthis.hasMissingPatterns = patterns.hasMissingPatterns;\n\t\tthis._cachedCompiledPatterns = null;\n\t}\n\n\tpublic get debugBeginRegExp(): string {\n\t\treturn `${this._begin.source}`;\n\t}\n\n\tpublic get debugEndRegExp(): string {\n\t\treturn `${this._end.source}`;\n\t}\n\n\tpublic getEndWithResolvedBackReferences(lineText: string, captureIndices: IOnigCaptureIndex[]): string {\n\t\treturn this._end.resolveBackReferences(lineText, captureIndices);\n\t}\n\n\tpublic collectPatternsRecursive(grammar: IRuleRegistry, out: RegExpSourceList, isFirst: boolean) {\n\t\tif (isFirst) {\n\t\t\tlet i: number,\n\t\t\t\tlen: number,\n\t\t\t\trule: Rule;\n\n\t\t\tfor (i = 0, len = this.patterns.length; i < len; i++) {\n\t\t\t\trule = grammar.getRule(this.patterns[i]);\n\t\t\t\trule.collectPatternsRecursive(grammar, out, false);\n\t\t\t}\n\t\t} else {\n\t\t\tout.push(this._begin);\n\t\t}\n\t}\n\n\tpublic compile(grammar: IRuleRegistry, endRegexSource: string, allowA: boolean, allowG: boolean): ICompiledRule {\n\t\tlet precompiled = this._precompile(grammar);\n\n\t\tif (this._end.hasBackReferences) {\n\t\t\tif (this.applyEndPatternLast) {\n\t\t\t\tprecompiled.setSource(precompiled.length() - 1, endRegexSource);\n\t\t\t} else {\n\t\t\t\tprecompiled.setSource(0, endRegexSource);\n\t\t\t}\n\t\t}\n\t\treturn this._cachedCompiledPatterns.compile(grammar, allowA, allowG);\n\t}\n\n\tprivate _precompile(grammar: IRuleRegistry): RegExpSourceList {\n\t\tif (!this._cachedCompiledPatterns) {\n\t\t\tthis._cachedCompiledPatterns = new RegExpSourceList();\n\n\t\t\tthis.collectPatternsRecursive(grammar, this._cachedCompiledPatterns, true);\n\n\t\t\tif (this.applyEndPatternLast) {\n\t\t\t\tthis._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);\n\t\t\t} else {\n\t\t\t\tthis._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);\n\t\t\t}\n\t\t}\n\t\treturn this._cachedCompiledPatterns;\n\t}\n}\n\nexport class BeginWhileRule extends Rule {\n\tprivate readonly _begin: RegExpSource;\n\tpublic readonly beginCaptures: CaptureRule[];\n\tpublic readonly whileCaptures: CaptureRule[];\n\tprivate readonly _while: RegExpSource;\n\tpublic readonly whileHasBackReferences: boolean;\n\tpublic readonly hasMissingPatterns: boolean;\n\tpublic readonly patterns: number[];\n\tprivate _cachedCompiledPatterns: RegExpSourceList;\n\tprivate _cachedCompiledWhilePatterns: RegExpSourceList;\n\n\tconstructor($location: ILocation, id: number, name: string, contentName: string, begin: string, beginCaptures: CaptureRule[], _while: string, whileCaptures: CaptureRule[], patterns: ICompilePatternsResult) {\n\t\tsuper($location, id, name, contentName);\n\t\tthis._begin = new RegExpSource(begin, this.id);\n\t\tthis.beginCaptures = beginCaptures;\n\t\tthis.whileCaptures = whileCaptures;\n\t\tthis._while = new RegExpSource(_while, -2);\n\t\tthis.whileHasBackReferences = this._while.hasBackReferences;\n\t\tthis.patterns = patterns.patterns;\n\t\tthis.hasMissingPatterns = patterns.hasMissingPatterns;\n\t\tthis._cachedCompiledPatterns = null;\n\t\tthis._cachedCompiledWhilePatterns = null;\n\t}\n\n\tpublic getWhileWithResolvedBackReferences(lineText: string, captureIndices: IOnigCaptureIndex[]): string {\n\t\treturn this._while.resolveBackReferences(lineText, captureIndices);\n\t}\n\n\tpublic collectPatternsRecursive(grammar: IRuleRegistry, out: RegExpSourceList, isFirst: boolean) {\n\t\tif (isFirst) {\n\t\t\tlet i: number,\n\t\t\t\tlen: number,\n\t\t\t\trule: Rule;\n\n\t\t\tfor (i = 0, len = this.patterns.length; i < len; i++) {\n\t\t\t\trule = grammar.getRule(this.patterns[i]);\n\t\t\t\trule.collectPatternsRecursive(grammar, out, false);\n\t\t\t}\n\t\t} else {\n\t\t\tout.push(this._begin);\n\t\t}\n\t}\n\n\tpublic compile(grammar: IRuleRegistry, endRegexSource: string, allowA: boolean, allowG: boolean): ICompiledRule {\n\t\tthis._precompile(grammar);\n\t\treturn this._cachedCompiledPatterns.compile(grammar, allowA, allowG);\n\t}\n\n\tprivate _precompile(grammar: IRuleRegistry): void {\n\t\tif (!this._cachedCompiledPatterns) {\n\t\t\tthis._cachedCompiledPatterns = new RegExpSourceList();\n\t\t\tthis.collectPatternsRecursive(grammar, this._cachedCompiledPatterns, true);\n\t\t}\n\t}\n\n\n\tpublic compileWhile(grammar: IRuleRegistry, endRegexSource: string, allowA: boolean, allowG: boolean): ICompiledRule {\n\t\tthis._precompileWhile(grammar);\n\t\tif (this._while.hasBackReferences) {\n\t\t\tthis._cachedCompiledWhilePatterns.setSource(0, endRegexSource);\n\t\t}\n\t\treturn this._cachedCompiledWhilePatterns.compile(grammar, allowA, allowG);\n\t}\n\n\n\tprivate _precompileWhile(grammar: IRuleRegistry): void {\n\t\tif (!this._cachedCompiledWhilePatterns) {\n\t\t\tthis._cachedCompiledWhilePatterns = new RegExpSourceList();\n\t\t\tthis._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);\n\t\t}\n\t}\n}\n\nexport class RuleFactory {\n\n\tpublic static createCaptureRule(helper: IRuleFactoryHelper, $location: ILocation, name: string, contentName: string, retokenizeCapturedWithRuleId: number): CaptureRule {\n\t\treturn helper.registerRule((id) => {\n\t\t\treturn new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);\n\t\t});\n\t}\n\n\tpublic static getCompiledRuleId(desc: IRawRule, helper: IRuleFactoryHelper, repository: IRawRepository): number {\n\t\tif (!desc.id) {\n\t\t\thelper.registerRule((id) => {\n\t\t\t\tdesc.id = id;\n\n\t\t\t\tif (desc.match) {\n\t\t\t\t\treturn new MatchRule(\n\t\t\t\t\t\tdesc.$vscodeTextmateLocation,\n\t\t\t\t\t\tdesc.id,\n\t\t\t\t\t\tdesc.name,\n\t\t\t\t\t\tdesc.match,\n\t\t\t\t\t\tRuleFactory._compileCaptures(desc.captures, helper, repository)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!desc.begin) {\n\t\t\t\t\tif (desc.repository) {\n\t\t\t\t\t\trepository = mergeObjects({}, repository, desc.repository);\n\t\t\t\t\t}\n\t\t\t\t\treturn new IncludeOnlyRule(\n\t\t\t\t\t\tdesc.$vscodeTextmateLocation,\n\t\t\t\t\t\tdesc.id,\n\t\t\t\t\t\tdesc.name,\n\t\t\t\t\t\tdesc.contentName,\n\t\t\t\t\t\tRuleFactory._compilePatterns(desc.patterns, helper, repository)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (desc.while) {\n\t\t\t\t\treturn new BeginWhileRule(\n\t\t\t\t\t\tdesc.$vscodeTextmateLocation,\n\t\t\t\t\t\tdesc.id,\n\t\t\t\t\t\tdesc.name,\n\t\t\t\t\t\tdesc.contentName,\n\t\t\t\t\t\tdesc.begin, RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n\t\t\t\t\t\tdesc.while, RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository),\n\t\t\t\t\t\tRuleFactory._compilePatterns(desc.patterns, helper, repository)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn new BeginEndRule(\n\t\t\t\t\tdesc.$vscodeTextmateLocation,\n\t\t\t\t\tdesc.id,\n\t\t\t\t\tdesc.name,\n\t\t\t\t\tdesc.contentName,\n\t\t\t\t\tdesc.begin, RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n\t\t\t\t\tdesc.end, RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository),\n\t\t\t\t\tdesc.applyEndPatternLast,\n\t\t\t\t\tRuleFactory._compilePatterns(desc.patterns, helper, repository)\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\treturn desc.id;\n\t}\n\n\tprivate static _compileCaptures(captures: IRawCaptures, helper: IRuleFactoryHelper, repository: IRawRepository): CaptureRule[] {\n\t\tlet r: CaptureRule[] = [],\n\t\t\tnumericCaptureId: number,\n\t\t\tmaximumCaptureId: number,\n\t\t\ti: number,\n\t\t\tcaptureId: string;\n\n\t\tif (captures) {\n\t\t\t// Find the maximum capture id\n\t\t\tmaximumCaptureId = 0;\n\t\t\tfor (captureId in captures) {\n\t\t\t\tif (captureId === '$vscodeTextmateLocation') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnumericCaptureId = parseInt(captureId, 10);\n\t\t\t\tif (numericCaptureId > maximumCaptureId) {\n\t\t\t\t\tmaximumCaptureId = numericCaptureId;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Initialize result\n\t\t\tfor (i = 0; i <= maximumCaptureId; i++) {\n\t\t\t\tr[i] = null;\n\t\t\t}\n\n\t\t\t// Fill out result\n\t\t\tfor (captureId in captures) {\n\t\t\t\tif (captureId === '$vscodeTextmateLocation') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnumericCaptureId = parseInt(captureId, 10);\n\t\t\t\tlet retokenizeCapturedWithRuleId = 0;\n\t\t\t\tif (captures[captureId].patterns) {\n\t\t\t\t\tretokenizeCapturedWithRuleId = RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);\n\t\t\t\t}\n\t\t\t\tr[numericCaptureId] = RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tprivate static _compilePatterns(patterns: IRawRule[], helper: IRuleFactoryHelper, repository: IRawRepository): ICompilePatternsResult {\n\t\tlet r: number[] = [],\n\t\t\tpattern: IRawRule,\n\t\t\ti: number,\n\t\t\tlen: number,\n\t\t\tpatternId: number,\n\t\t\texternalGrammar: IRawGrammar,\n\t\t\trule: Rule,\n\t\t\tskipRule: boolean;\n\n\t\tif (patterns) {\n\t\t\tfor (i = 0, len = patterns.length; i < len; i++) {\n\t\t\t\tpattern = patterns[i];\n\t\t\t\tpatternId = -1;\n\n\t\t\t\tif (pattern.include) {\n\t\t\t\t\tif (pattern.include.charAt(0) === '#') {\n\t\t\t\t\t\t// Local include found in `repository`\n\t\t\t\t\t\tlet localIncludedRule = repository[pattern.include.substr(1)];\n\t\t\t\t\t\tif (localIncludedRule) {\n\t\t\t\t\t\t\tpatternId = RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// console.warn('CANNOT find rule for scopeName: ' + pattern.include + ', I am: ', repository['$base'].name);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (pattern.include === '$base' || pattern.include === '$self') {\n\t\t\t\t\t\t// Special include also found in `repository`\n\t\t\t\t\t\tpatternId = RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet externalGrammarName: string = null,\n\t\t\t\t\t\t\texternalGrammarInclude: string = null,\n\t\t\t\t\t\t\tsharpIndex = pattern.include.indexOf('#');\n\t\t\t\t\t\tif (sharpIndex >= 0) {\n\t\t\t\t\t\t\texternalGrammarName = pattern.include.substring(0, sharpIndex);\n\t\t\t\t\t\t\texternalGrammarInclude = pattern.include.substring(sharpIndex + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\texternalGrammarName = pattern.include;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// External include\n\t\t\t\t\t\texternalGrammar = helper.getExternalGrammar(externalGrammarName, repository);\n\n\t\t\t\t\t\tif (externalGrammar) {\n\t\t\t\t\t\t\tif (externalGrammarInclude) {\n\t\t\t\t\t\t\t\tlet externalIncludedRule = externalGrammar.repository[externalGrammarInclude];\n\t\t\t\t\t\t\t\tif (externalIncludedRule) {\n\t\t\t\t\t\t\t\t\tpatternId = RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// console.warn('CANNOT find rule for scopeName: ' + pattern.include + ', I am: ', repository['$base'].name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpatternId = RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// console.warn('CANNOT find grammar for scopeName: ' + pattern.include + ', I am: ', repository['$base'].name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpatternId = RuleFactory.getCompiledRuleId(pattern, helper, repository);\n\t\t\t\t}\n\n\t\t\t\tif (patternId !== -1) {\n\t\t\t\t\trule = helper.getRule(patternId);\n\n\t\t\t\t\tskipRule = false;\n\n\t\t\t\t\tif (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {\n\t\t\t\t\t\tif (rule.hasMissingPatterns && rule.patterns.length === 0) {\n\t\t\t\t\t\t\tskipRule = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (skipRule) {\n\t\t\t\t\t\t// console.log('REMOVING RULE ENTIRELY DUE TO EMPTY PATTERNS THAT ARE MISSING');\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tr.push(patternId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tpatterns: r,\n\t\t\thasMissingPatterns: ((patterns ? patterns.length : 0) !== r.length)\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nexport interface MatcherWithPriority<T> {\n\tmatcher: Matcher<T>;\n\tpriority: -1 | 0 | 1;\n}\n\nexport interface Matcher<T> {\n\t(matcherInput: T): boolean;\n}\n\nexport function createMatchers<T>(selector: string, matchesName: (names: string[], matcherInput: T) => boolean): MatcherWithPriority<T>[] {\n\tvar results = <MatcherWithPriority<T>[]> [];\n\tvar tokenizer = newTokenizer(selector);\n\tvar token = tokenizer.next();\n\twhile (token !== null) {\n\t\tlet priority : -1 | 0 | 1 = 0;\n\t\tif (token.length === 2 && token.charAt(1) === ':') {\n\t\t\tswitch (token.charAt(0)) {\n\t\t\t\tcase 'R': priority = 1; break;\n\t\t\t\tcase 'L': priority = -1; break;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(`Unknown priority ${token} in scope selector`);\n\t\t\t}\n\t\t\ttoken = tokenizer.next();\n\t\t}\n\t\tlet matcher = parseConjunction();\n\t\tif (matcher) {\n\t\t\tresults.push({ matcher, priority });\n\t\t}\n\t\tif (token !== ',') {\n\t\t\tbreak;\n\t\t}\n\t\ttoken = tokenizer.next();\n\t}\n\treturn results;\n\n\tfunction parseOperand(): Matcher<T> {\n\t\tif (token === '-') {\n\t\t\ttoken = tokenizer.next();\n\t\t\tvar expressionToNegate = parseOperand();\n\t\t\treturn matcherInput => expressionToNegate && !expressionToNegate(matcherInput);\n\t\t}\n\t\tif (token === '(') {\n\t\t\ttoken = tokenizer.next();\n\t\t\tvar expressionInParents = parseInnerExpression();\n\t\t\tif (token === ')') {\n\t\t\t\ttoken = tokenizer.next();\n\t\t\t}\n\t\t\treturn expressionInParents;\n\t\t}\n\t\tif (isIdentifier(token)) {\n\t\t\tvar identifiers: string[] = [];\n\t\t\tdo {\n\t\t\t\tidentifiers.push(token);\n\t\t\t\ttoken = tokenizer.next();\n\t\t\t} while (isIdentifier(token));\n\t\t\treturn matcherInput => matchesName(identifiers, matcherInput);\n\t\t}\n\t\treturn null;\n\t}\n\tfunction parseConjunction(): Matcher<T> {\n\t\tvar matchers: Matcher<T>[] = [];\n\t\tvar matcher = parseOperand();\n\t\twhile (matcher) {\n\t\t\tmatchers.push(matcher);\n\t\t\tmatcher = parseOperand();\n\t\t}\n\t\treturn matcherInput => matchers.every(matcher => matcher(matcherInput)); // and\n\t}\n\tfunction parseInnerExpression(): Matcher<T> {\n\t\tvar matchers: Matcher<T>[] = [];\n\t\tvar matcher = parseConjunction();\n\t\twhile (matcher) {\n\t\t\tmatchers.push(matcher);\n\t\t\tif (token === '|' || token === ',') {\n\t\t\t\tdo {\n\t\t\t\t\ttoken = tokenizer.next();\n\t\t\t\t} while (token === '|' || token === ','); // ignore subsequent commas\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatcher = parseConjunction();\n\t\t}\n\t\treturn matcherInput => matchers.some(matcher => matcher(matcherInput)); // or\n\t}\n}\n\nfunction isIdentifier(token: string) {\n\treturn token && token.match(/[\\w\\.:]+/);\n}\n\nfunction newTokenizer(input: string): { next: () => string } {\n\tlet regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n\tvar match = regex.exec(input);\n\treturn {\n\t\tnext: () => {\n\t\t\tif (!match) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar res = match[0];\n\t\t\tmatch = regex.exec(input);\n\t\t\treturn res;\n\t\t}\n\t};\n}\n","/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nexport const CAPTURE_METADATA = typeof process === 'undefined' ? false : !!process.env['VSCODE_TEXTMATE_DEBUG'];\nexport const IN_DEBUG_MODE = typeof process === 'undefined' ? false : !!process.env['VSCODE_TEXTMATE_DEBUG'];\n","/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport { clone } from './utils';\nimport { IRawGrammar, IRawRepository, IRawRule } from './types';\nimport { IRuleRegistry, IRuleFactoryHelper, RuleFactory, Rule, CaptureRule, BeginEndRule, BeginWhileRule, MatchRule, ICompiledRule, createOnigString, getString } from './rule';\nimport { IOnigCaptureIndex, OnigString } from 'onigasm';\nimport { createMatchers, Matcher } from './matcher';\nimport { MetadataConsts, IGrammar, ITokenizeLineResult, ITokenizeLineResult2, IToken, IEmbeddedLanguagesMap, StandardTokenType, StackElement as StackElementDef, ITokenTypeMap } from './main';\nimport { IN_DEBUG_MODE } from './debug';\nimport { FontStyle, ThemeTrieElementRule } from './theme';\n\nexport const enum TemporaryStandardTokenType {\n\tOther = 0,\n\tComment = 1,\n\tString = 2,\n\tRegEx = 4,\n\tMetaEmbedded = 8\n}\n\nexport function createGrammar(grammar: IRawGrammar, initialLanguage: number, embeddedLanguages: IEmbeddedLanguagesMap, tokenTypes: ITokenTypeMap, grammarRepository: IGrammarRepository & IThemeProvider): Grammar {\n\treturn new Grammar(grammar, initialLanguage, embeddedLanguages, tokenTypes, grammarRepository);\n}\n\nexport interface IThemeProvider {\n\tthemeMatch(scopeName: string): ThemeTrieElementRule[];\n\tgetDefaults(): ThemeTrieElementRule;\n}\n\nexport interface IGrammarRepository {\n\tlookup(scopeName: string): IRawGrammar;\n\tinjections(scopeName: string): string[];\n}\n\nexport interface IScopeNameSet {\n\t[scopeName: string]: boolean;\n}\n\n/**\n * Fill in `result` all external included scopes in `patterns`\n */\nfunction _extractIncludedScopesInPatterns(result: IScopeNameSet, patterns: IRawRule[]): void {\n\tfor (let i = 0, len = patterns.length; i < len; i++) {\n\n\t\tif (Array.isArray(patterns[i].patterns)) {\n\t\t\t_extractIncludedScopesInPatterns(result, patterns[i].patterns);\n\t\t}\n\n\t\tlet include = patterns[i].include;\n\n\t\tif (!include) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (include === '$base' || include === '$self') {\n\t\t\t// Special includes that can be resolved locally in this grammar\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (include.charAt(0) === '#') {\n\t\t\t// Local include from this grammar\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet sharpIndex = include.indexOf('#');\n\t\tif (sharpIndex >= 0) {\n\t\t\tresult[include.substring(0, sharpIndex)] = true;\n\t\t} else {\n\t\t\tresult[include] = true;\n\t\t}\n\t}\n}\n\n/**\n * Fill in `result` all external included scopes in `repository`\n */\nfunction _extractIncludedScopesInRepository(result: IScopeNameSet, repository: IRawRepository): void {\n\tfor (let name in repository) {\n\t\tlet rule = repository[name];\n\n\t\tif (rule.patterns && Array.isArray(rule.patterns)) {\n\t\t\t_extractIncludedScopesInPatterns(result, rule.patterns);\n\t\t}\n\n\t\tif (rule.repository) {\n\t\t\t_extractIncludedScopesInRepository(result, rule.repository);\n\t\t}\n\t}\n}\n\n/**\n * Collects the list of all external included scopes in `grammar`.\n */\nexport function collectIncludedScopes(result: IScopeNameSet, grammar: IRawGrammar): void {\n\tif (grammar.patterns && Array.isArray(grammar.patterns)) {\n\t\t_extractIncludedScopesInPatterns(result, grammar.patterns);\n\t}\n\n\tif (grammar.repository) {\n\t\t_extractIncludedScopesInRepository(result, grammar.repository);\n\t}\n\n\t// remove references to own scope (avoid recursion)\n\tdelete result[grammar.scopeName];\n}\n\nexport interface Injection {\n\treadonly matcher: Matcher<string[]>;\n\treadonly priority: -1 | 0 | 1; // 0 is the default. -1 for 'L' and 1 for 'R'\n\treadonly ruleId: number;\n\treadonly grammar: IRawGrammar;\n}\n\nfunction scopesAreMatching(thisScopeName: string, scopeName: string): boolean {\n\tif (!thisScopeName) {\n\t\treturn false;\n\t}\n\tif (thisScopeName === scopeName) {\n\t\treturn true;\n\t}\n\tvar len = scopeName.length;\n\treturn thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === '.';\n}\n\nfunction nameMatcher(identifers: string[], scopes: string[]) {\n\tif (scopes.length < identifers.length) {\n\t\treturn false;\n\t}\n\tvar lastIndex = 0;\n\treturn identifers.every(identifier => {\n\t\tfor (var i = lastIndex; i < scopes.length; i++) {\n\t\t\tif (scopesAreMatching(scopes[i], identifier)) {\n\t\t\t\tlastIndex = i + 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t});\n};\n\nfunction collectInjections(result: Injection[], selector: string, rule: IRawRule, ruleFactoryHelper: IRuleFactoryHelper, grammar: IRawGrammar): void {\n\tlet matchers = createMatchers(selector, nameMatcher);\n\tlet ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);\n\tfor (let matcher of matchers) {\n\t\tresult.push({\n\t\t\tmatcher: matcher.matcher,\n\t\t\truleId: ruleId,\n\t\t\tgrammar: grammar,\n\t\t\tpriority: matcher.priority\n\t\t});\n\t}\n}\n\nexport class ScopeMetadata {\n\tpublic readonly scopeName: string;\n\tpublic readonly languageId: number;\n\tpublic readonly tokenType: TemporaryStandardTokenType;\n\tpublic readonly themeData: ThemeTrieElementRule[];\n\n\tconstructor(scopeName: string, languageId: number, tokenType: TemporaryStandardTokenType, themeData: ThemeTrieElementRule[]) {\n\t\tthis.scopeName = scopeName;\n\t\tthis.languageId = languageId;\n\t\tthis.tokenType = tokenType;\n\t\tthis.themeData = themeData;\n\t}\n}\n\nclass ScopeMetadataProvider {\n\n\tprivate readonly _initialLanguage: number;\n\tprivate readonly _themeProvider: IThemeProvider;\n\tprivate _cache: { [scopeName: string]: ScopeMetadata; };\n\tprivate _defaultMetaData: ScopeMetadata;\n\tprivate readonly _embeddedLanguages: IEmbeddedLanguagesMap;\n\tprivate readonly _embeddedLanguagesRegex: RegExp;\n\n\tconstructor(initialLanguage: number, themeProvider: IThemeProvider, embeddedLanguages: IEmbeddedLanguagesMap) {\n\t\tthis._initialLanguage = initialLanguage;\n\t\tthis._themeProvider = themeProvider;\n\t\tthis.onDidChangeTheme();\n\n\t\t// embeddedLanguages handling\n\t\tthis._embeddedLanguages = Object.create(null);\n\n\t\tif (embeddedLanguages) {\n\t\t\t// If embeddedLanguages are configured, fill in `this._embeddedLanguages`\n\t\t\tlet scopes = Object.keys(embeddedLanguages);\n\t\t\tfor (let i = 0, len = scopes.length; i < len; i++) {\n\t\t\t\tlet scope = scopes[i];\n\t\t\t\tlet language = embeddedLanguages[scope];\n\t\t\t\tif (typeof language !== 'number' || language === 0) {\n\t\t\t\t\tconsole.warn('Invalid embedded language found at scope ' + scope + ': <<' + language + '>>');\n\t\t\t\t\t// never hurts to be too careful\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._embeddedLanguages[scope] = language;\n\t\t\t}\n\t\t}\n\n\t\t// create the regex\n\t\tlet escapedScopes = Object.keys(this._embeddedLanguages).map((scopeName) => ScopeMetadataProvider._escapeRegExpCharacters(scopeName));\n\t\tif (escapedScopes.length === 0) {\n\t\t\t// no scopes registered\n\t\t\tthis._embeddedLanguagesRegex = null;\n\t\t} else {\n\t\t\tescapedScopes.sort();\n\t\t\tescapedScopes.reverse();\n\t\t\tthis._embeddedLanguagesRegex = new RegExp(`^((${escapedScopes.join(')|(')}))($|\\\\.)`, '');\n\t\t}\n\t}\n\n\tpublic onDidChangeTheme(): void {\n\t\tthis._cache = Object.create(null);\n\t\tthis._defaultMetaData = new ScopeMetadata(\n\t\t\t'',\n\t\t\tthis._initialLanguage,\n\t\t\tTemporaryStandardTokenType.Other,\n\t\t\t[this._themeProvider.getDefaults()]\n\t\t);\n\t}\n\n\tpublic getDefaultMetadata(): ScopeMetadata {\n\t\treturn this._defaultMetaData;\n\t}\n\n\t/**\n\t * Escapes regular expression characters in a given string\n\t */\n\tprivate static _escapeRegExpCharacters(value: string): string {\n\t\treturn value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&');\n\t}\n\n\tprivate static _NULL_SCOPE_METADATA = new ScopeMetadata('', 0, 0, null);\n\tpublic getMetadataForScope(scopeName: string): ScopeMetadata {\n\t\tif (scopeName === null) {\n\t\t\treturn ScopeMetadataProvider._NULL_SCOPE_METADATA;\n\t\t}\n\t\tlet value = this._cache[scopeName];\n\t\tif (value) {\n\t\t\treturn value;\n\t\t}\n\t\tvalue = this._doGetMetadataForScope(scopeName);\n\t\tthis._cache[scopeName] = value;\n\t\treturn value;\n\t}\n\n\tprivate _doGetMetadataForScope(scopeName: string): ScopeMetadata {\n\t\tlet languageId = this._scopeToLanguage(scopeName);\n\t\tlet standardTokenType = this._toStandardTokenType(scopeName);\n\t\tlet themeData = this._themeProvider.themeMatch(scopeName);\n\n\t\treturn new ScopeMetadata(scopeName, languageId, standardTokenType, themeData);\n\t}\n\n\t/**\n\t * Given a produced TM scope, return the language that token describes or null if unknown.\n\t * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null\n\t */\n\tprivate _scopeToLanguage(scope: string): number {\n\t\tif (!scope) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (!this._embeddedLanguagesRegex) {\n\t\t\t// no scopes registered\n\t\t\treturn 0;\n\t\t}\n\t\tlet m = scope.match(this._embeddedLanguagesRegex);\n\t\tif (!m) {\n\t\t\t// no scopes matched\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet language = this._embeddedLanguages[m[1]] || 0;\n\t\tif (!language) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn language;\n\t}\n\n\tprivate static STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|meta\\.embedded)\\b/;\n\tprivate _toStandardTokenType(tokenType: string): TemporaryStandardTokenType {\n\t\tlet m = tokenType.match(ScopeMetadataProvider.STANDARD_TOKEN_TYPE_REGEXP);\n\t\tif (!m) {\n\t\t\treturn TemporaryStandardTokenType.Other;\n\t\t}\n\t\tswitch (m[1]) {\n\t\t\tcase 'comment':\n\t\t\t\treturn TemporaryStandardTokenType.Comment;\n\t\t\tcase 'string':\n\t\t\t\treturn TemporaryStandardTokenType.String;\n\t\t\tcase 'regex':\n\t\t\t\treturn TemporaryStandardTokenType.RegEx;\n\t\t\tcase 'meta.embedded':\n\t\t\t\treturn TemporaryStandardTokenType.MetaEmbedded;\n\t\t}\n\t\tthrow new Error('Unexpected match for standard token type!');\n\t}\n}\n\nexport class Grammar implements IGrammar, IRuleFactoryHelper {\n\n\tprivate _rootId: number;\n\tprivate _lastRuleId: number;\n\tprivate readonly _ruleId2desc: Rule[];\n\tprivate readonly _includedGrammars: { [scopeName: string]: IRawGrammar; };\n\tprivate readonly _grammarRepository: IGrammarRepository;\n\tprivate readonly _grammar: IRawGrammar;\n\tprivate _injections: Injection[];\n\tprivate readonly _scopeMetadataProvider: ScopeMetadataProvider;\n\tprivate readonly _tokenTypeMatchers: TokenTypeMatcher[];\n\n\tconstructor(grammar: IRawGrammar, initialLanguage: number, embeddedLanguages: IEmbeddedLanguagesMap, tokenTypes: ITokenTypeMap, grammarRepository: IGrammarRepository & IThemeProvider) {\n\t\tthis._scopeMetadataProvider = new ScopeMetadataProvider(initialLanguage, grammarRepository, embeddedLanguages);\n\n\t\tthis._rootId = -1;\n\t\tthis._lastRuleId = 0;\n\t\tthis._ruleId2desc = [];\n\t\tthis._includedGrammars = {};\n\t\tthis._grammarRepository = grammarRepository;\n\t\tthis._grammar = initGrammar(grammar, null);\n\n\t\tthis._tokenTypeMatchers = [];\n\t\tif (tokenTypes) {\n\t\t\tfor (const selector of Object.keys(tokenTypes)) {\n\t\t\t\tconst matchers = createMatchers(selector, nameMatcher);\n\t\t\t\tfor (const matcher of matchers) {\n\t\t\t\t\tthis._tokenTypeMatchers.push({\n\t\t\t\t\t\tmatcher: matcher.matcher,\n\t\t\t\t\t\ttype: tokenTypes[selector]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic onDidChangeTheme(): void {\n\t\tthis._scopeMetadataProvider.onDidChangeTheme();\n\t}\n\n\tpublic getMetadataForScope(scope: string): ScopeMetadata {\n\t\treturn this._scopeMetadataProvider.getMetadataForScope(scope);\n\t}\n\n\tpublic getInjections(): Injection[] {\n\t\tif (!this._injections) {\n\t\t\tthis._injections = [];\n\t\t\t// add injections from the current grammar\n\t\t\tvar rawInjections = this._grammar.injections;\n\t\t\tif (rawInjections) {\n\t\t\t\tfor (var expression in rawInjections) {\n\t\t\t\t\tcollectInjections(this._injections, expression, rawInjections[expression], this, this._grammar);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add injection grammars contributed for the current scope\n\t\t\tif (this._grammarRepository) {\n\t\t\t\tlet injectionScopeNames = this._grammarRepository.injections(this._grammar.scopeName);\n\t\t\t\tif (injectionScopeNames) {\n\t\t\t\t\tinjectionScopeNames.forEach(injectionScopeName => {\n\t\t\t\t\t\tlet injectionGrammar = this.getExternalGrammar(injectionScopeName);\n\t\t\t\t\t\tif (injectionGrammar) {\n\t\t\t\t\t\t\tlet selector = injectionGrammar.injectionSelector;\n\t\t\t\t\t\t\tif (selector) {\n\t\t\t\t\t\t\t\tcollectInjections(this._injections, selector, injectionGrammar, this, injectionGrammar);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._injections.sort((i1, i2) => i1.priority - i2.priority); // sort by priority\n\t\t}\n\t\tif (this._injections.length === 0) {\n\t\t\treturn this._injections;\n\t\t}\n\t\treturn this._injections;\n\t}\n\n\tpublic registerRule<T extends Rule>(factory: (id: number) => T): T {\n\t\tlet id = (++this._lastRuleId);\n\t\tlet result = factory(id);\n\t\tthis._ruleId2desc[id] = result;\n\t\treturn result;\n\t}\n\n\tpublic getRule(patternId: number): Rule {\n\t\treturn this._ruleId2desc[patternId];\n\t}\n\n\tpublic getExternalGrammar(scopeName: string, repository?: IRawRepository): IRawGrammar {\n\t\tif (this._includedGrammars[scopeName]) {\n\t\t\treturn this._includedGrammars[scopeName];\n\t\t} else if (this._grammarRepository) {\n\t\t\tlet rawIncludedGrammar = this._grammarRepository.lookup(scopeName);\n\t\t\tif (rawIncludedGrammar) {\n\t\t\t\t// console.log('LOADED GRAMMAR ' + pattern.include);\n\t\t\t\tthis._includedGrammars[scopeName] = initGrammar(rawIncludedGrammar, repository && repository.$base);\n\t\t\t\treturn this._includedGrammars[scopeName];\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic tokenizeLine(lineText: string, prevState: StackElement): ITokenizeLineResult {\n\t\tlet r = this._tokenize(lineText, prevState, false);\n\t\treturn {\n\t\t\ttokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),\n\t\t\truleStack: r.ruleStack\n\t\t};\n\t}\n\n\tpublic tokenizeLine2(lineText: string, prevState: StackElement): ITokenizeLineResult2 {\n\t\tlet r = this._tokenize(lineText, prevState, true);\n\t\treturn {\n\t\t\ttokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),\n\t\t\truleStack: r.ruleStack\n\t\t};\n\t}\n\n\tprivate _tokenize(lineText: string, prevState: StackElement, emitBinaryTokens: boolean): { lineLength: number; lineTokens: LineTokens; ruleStack: StackElement; } {\n\t\tif (this._rootId === -1) {\n\t\t\tthis._rootId = RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository);\n\t\t}\n\n\t\tlet isFirstLine: boolean;\n\t\tif (!prevState || prevState === StackElement.NULL) {\n\t\t\tisFirstLine = true;\n\t\t\tlet rawDefaultMetadata = this._scopeMetadataProvider.getDefaultMetadata();\n\t\t\tlet defaultTheme = rawDefaultMetadata.themeData[0];\n\t\t\tlet defaultMetadata = StackElementMetadata.set(0, rawDefaultMetadata.languageId, rawDefaultMetadata.tokenType, defaultTheme.fontStyle, defaultTheme.foreground, defaultTheme.background);\n\n\t\t\tlet rootScopeName = this.getRule(this._rootId).getName(null, null);\n\t\t\tlet rawRootMetadata = this._scopeMetadataProvider.getMetadataForScope(rootScopeName);\n\t\t\tlet rootMetadata = ScopeListElement.mergeMetadata(defaultMetadata, null, rawRootMetadata);\n\n\t\t\tlet scopeList = new ScopeListElement(null, rootScopeName, rootMetadata);\n\n\t\t\tprevState = new StackElement(null, this._rootId, -1, null, scopeList, scopeList);\n\t\t} else {\n\t\t\tisFirstLine = false;\n\t\t\tprevState.reset();\n\t\t}\n\n\t\tlineText = lineText + '\\n';\n\t\tlet onigLineText = createOnigString(lineText);\n\t\tlet lineLength = getString(onigLineText).length;\n\t\tlet lineTokens = new LineTokens(emitBinaryTokens, lineText, this._tokenTypeMatchers);\n\t\tlet nextState = _tokenizeString(this, onigLineText, isFirstLine, 0, prevState, lineTokens);\n\n\t\treturn {\n\t\t\tlineLength: lineLength,\n\t\t\tlineTokens: lineTokens,\n\t\t\truleStack: nextState\n\t\t};\n\t}\n}\n\nfunction initGrammar(grammar: IRawGrammar, base: IRawRule): IRawGrammar {\n\tgrammar = clone(grammar);\n\n\tgrammar.repository = grammar.repository || <any>{};\n\tgrammar.repository.$self = {\n\t\t$vscodeTextmateLocation: grammar.$vscodeTextmateLocation,\n\t\tpatterns: grammar.patterns,\n\t\tname: grammar.scopeName\n\t};\n\tgrammar.repository.$base = base || grammar.repository.$self;\n\treturn grammar;\n}\n\nfunction handleCaptures(grammar: Grammar, lineText: OnigString, isFirstLine: boolean, stack: StackElement, lineTokens: LineTokens, captures: CaptureRule[], captureIndices: IOnigCaptureIndex[]): void {\n\tif (captures.length === 0) {\n\t\treturn;\n\t}\n\n\tlet len = Math.min(captures.length, captureIndices.length);\n\tlet localStack: LocalStackElement[] = [];\n\tlet maxEnd = captureIndices[0].end;\n\n\tfor (let i = 0; i < len; i++) {\n\t\tlet captureRule = captures[i];\n\t\tif (captureRule === null) {\n\t\t\t// Not interested\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet captureIndex = captureIndices[i];\n\n\t\tif (captureIndex.length === 0) {\n\t\t\t// Nothing really captured\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (captureIndex.start > maxEnd) {\n\t\t\t// Capture going beyond consumed string\n\t\t\tbreak;\n\t\t}\n\n\t\t// pop captures while needed\n\t\twhile (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {\n\t\t\t// pop!\n\t\t\tlineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n\t\t\tlocalStack.pop();\n\t\t}\n\n\t\tif (localStack.length > 0) {\n\t\t\tlineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);\n\t\t} else {\n\t\t\tlineTokens.produce(stack, captureIndex.start);\n\t\t}\n\n\t\tif (captureRule.retokenizeCapturedWithRuleId) {\n\t\t\t// the capture requires additional matching\n\t\t\tlet scopeName = captureRule.getName(getString(lineText), captureIndices);\n\t\t\tlet nameScopesList = stack.contentNameScopesList.push(grammar, scopeName);\n\t\t\tlet contentName = captureRule.getContentName(getString(lineText), captureIndices);\n\t\t\tlet contentNameScopesList = nameScopesList.push(grammar, contentName);\n\n\t\t\tlet stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, null, nameScopesList, contentNameScopesList);\n\t\t\t_tokenizeString(grammar,\n\t\t\t\tcreateOnigString(\n\t\t\t\t\tgetString(lineText).substring(0, captureIndex.end)\n\t\t\t\t),\n\t\t\t\t(isFirstLine && captureIndex.start === 0), captureIndex.start, stackClone, lineTokens\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet captureRuleScopeName = captureRule.getName(getString(lineText), captureIndices);\n\t\tif (captureRuleScopeName !== null) {\n\t\t\t// push\n\t\t\tlet base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;\n\t\t\tlet captureRuleScopesList = base.push(grammar, captureRuleScopeName);\n\t\t\tlocalStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));\n\t\t}\n\t}\n\n\twhile (localStack.length > 0) {\n\t\t// pop!\n\t\tlineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n\t\tlocalStack.pop();\n\t}\n}\n\ninterface IMatchInjectionsResult {\n\treadonly priorityMatch: boolean;\n\treadonly captureIndices: IOnigCaptureIndex[];\n\treadonly matchedRuleId: number;\n}\n\nfunction debugCompiledRuleToString(ruleScanner: ICompiledRule): string {\n\tlet r: string[] = [];\n\tfor (let i = 0, len = ruleScanner.rules.length; i < len; i++) {\n\t\tr.push('   - ' + ruleScanner.rules[i] + ': ' + ruleScanner.debugRegExps[i]);\n\t}\n\treturn r.join('\\n');\n}\n\nfunction matchInjections(injections: Injection[], grammar: Grammar, lineText: OnigString, isFirstLine: boolean, linePos: number, stack: StackElement, anchorPosition: number): IMatchInjectionsResult {\n\t// The lower the better\n\tlet bestMatchRating = Number.MAX_VALUE;\n\tlet bestMatchCaptureIndices: IOnigCaptureIndex[] = null;\n\tlet bestMatchRuleId: number;\n\tlet bestMatchResultPriority: number = 0;\n\n\tlet scopes = stack.contentNameScopesList.generateScopes();\n\n\tfor (let i = 0, len = injections.length; i < len; i++) {\n\t\tlet injection = injections[i];\n\t\tif (!injection.matcher(scopes)) {\n\t\t\t// injection selector doesn't match stack\n\t\t\tcontinue;\n\t\t}\n\t\tlet ruleScanner = grammar.getRule(injection.ruleId).compile(grammar, null, isFirstLine, linePos === anchorPosition);\n\t\tlet matchResult = ruleScanner.scanner.findNextMatchSync(lineText, linePos);\n\t\tif (IN_DEBUG_MODE) {\n\t\t\tconsole.log('  scanning for injections');\n\t\t\tconsole.log(debugCompiledRuleToString(ruleScanner));\n\t\t}\n\n\t\tif (!matchResult) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet matchRating = matchResult.captureIndices[0].start;\n\t\tif (matchRating >= bestMatchRating) {\n\t\t\t// Injections are sorted by priority, so the previous injection had a better or equal priority\n\t\t\tcontinue;\n\t\t}\n\n\t\tbestMatchRating = matchRating;\n\t\tbestMatchCaptureIndices = matchResult.captureIndices;\n\t\tbestMatchRuleId = ruleScanner.rules[matchResult.index];\n\t\tbestMatchResultPriority = injection.priority;\n\n\t\tif (bestMatchRating === linePos) {\n\t\t\t// No more need to look at the rest of the injections.\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bestMatchCaptureIndices) {\n\t\treturn {\n\t\t\tpriorityMatch: bestMatchResultPriority === -1,\n\t\t\tcaptureIndices: bestMatchCaptureIndices,\n\t\t\tmatchedRuleId: bestMatchRuleId\n\t\t};\n\t}\n\n\treturn null;\n}\n\ninterface IMatchResult {\n\treadonly captureIndices: IOnigCaptureIndex[];\n\treadonly matchedRuleId: number;\n}\n\nfunction matchRule(grammar: Grammar, lineText: OnigString, isFirstLine: boolean, linePos: number, stack: StackElement, anchorPosition: number): IMatchResult {\n\tlet rule = stack.getRule(grammar);\n\tlet ruleScanner = rule.compile(grammar, stack.endRule, isFirstLine, linePos === anchorPosition);\n\tlet r = ruleScanner.scanner.findNextMatchSync(lineText, linePos);\n\tif (IN_DEBUG_MODE) {\n\t\tconsole.log('  scanning for');\n\t\tconsole.log(debugCompiledRuleToString(ruleScanner));\n\t}\n\n\tif (r) {\n\t\treturn {\n\t\t\tcaptureIndices: r.captureIndices,\n\t\t\tmatchedRuleId: ruleScanner.rules[r.index]\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction matchRuleOrInjections(grammar: Grammar, lineText: OnigString, isFirstLine: boolean, linePos: number, stack: StackElement, anchorPosition: number): IMatchResult {\n\t// Look for normal grammar rule\n\tlet matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n\n\t// Look for injected rules\n\tlet injections = grammar.getInjections();\n\tif (injections.length === 0) {\n\t\t// No injections whatsoever => early return\n\t\treturn matchResult;\n\t}\n\n\tlet injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n\tif (!injectionResult) {\n\t\t// No injections matched => early return\n\t\treturn matchResult;\n\t}\n\n\tif (!matchResult) {\n\t\t// Only injections matched => early return\n\t\treturn injectionResult;\n\t}\n\n\t// Decide if `matchResult` or `injectionResult` should win\n\tlet matchResultScore = matchResult.captureIndices[0].start;\n\tlet injectionResultScore = injectionResult.captureIndices[0].start;\n\n\tif (injectionResultScore < matchResultScore || (injectionResult.priorityMatch && injectionResultScore === matchResultScore)) {\n\t\t// injection won!\n\t\treturn injectionResult;\n\t}\n\treturn matchResult;\n}\n\ninterface IWhileStack {\n\treadonly stack: StackElement;\n\treadonly rule: BeginWhileRule;\n}\n\ninterface IWhileCheckResult {\n\treadonly stack: StackElement;\n\treadonly linePos: number;\n\treadonly anchorPosition: number;\n\treadonly isFirstLine: boolean;\n}\n\n/**\n * Walk the stack from bottom to top, and check each while condition in this order.\n * If any fails, cut off the entire stack above the failed while condition. While conditions\n * may also advance the linePosition.\n */\nfunction _checkWhileConditions(grammar: Grammar, lineText: OnigString, isFirstLine: boolean, linePos: number, stack: StackElement, lineTokens: LineTokens): IWhileCheckResult {\n\tlet anchorPosition = -1;\n\tlet whileRules: IWhileStack[] = [];\n\tfor (let node = stack; node; node = node.pop()) {\n\t\tlet nodeRule = node.getRule(grammar);\n\t\tif (nodeRule instanceof BeginWhileRule) {\n\t\t\twhileRules.push({\n\t\t\t\trule: nodeRule,\n\t\t\t\tstack: node\n\t\t\t});\n\t\t}\n\t}\n\n\tfor (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {\n\t\tlet ruleScanner = whileRule.rule.compileWhile(grammar, whileRule.stack.endRule, isFirstLine, anchorPosition === linePos);\n\t\tlet r = ruleScanner.scanner.findNextMatchSync(lineText, linePos);\n\t\tif (IN_DEBUG_MODE) {\n\t\t\tconsole.log('  scanning for while rule');\n\t\t\tconsole.log(debugCompiledRuleToString(ruleScanner));\n\t\t}\n\n\t\tif (r) {\n\t\t\tlet matchedRuleId = ruleScanner.rules[r.index];\n\t\t\tif (matchedRuleId !== -2) {\n\t\t\t\t// we shouldn't end up here\n\t\t\t\tstack = whileRule.stack.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (r.captureIndices && r.captureIndices.length) {\n\t\t\t\tlineTokens.produce(whileRule.stack, r.captureIndices[0].start);\n\t\t\t\thandleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);\n\t\t\t\tlineTokens.produce(whileRule.stack, r.captureIndices[0].end);\n\t\t\t\tanchorPosition = r.captureIndices[0].end;\n\t\t\t\tif (r.captureIndices[0].end > linePos) {\n\t\t\t\t\tlinePos = r.captureIndices[0].end;\n\t\t\t\t\tisFirstLine = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstack = whileRule.stack.pop();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn { stack: stack, linePos: linePos, anchorPosition: anchorPosition, isFirstLine: isFirstLine };\n}\n\nfunction _tokenizeString(grammar: Grammar, lineText: OnigString, isFirstLine: boolean, linePos: number, stack: StackElement, lineTokens: LineTokens): StackElement {\n\tconst lineLength = getString(lineText).length;\n\n\tlet STOP = false;\n\n\tlet whileCheckResult = _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens);\n\tstack = whileCheckResult.stack;\n\tlinePos = whileCheckResult.linePos;\n\tisFirstLine = whileCheckResult.isFirstLine;\n\tlet anchorPosition = whileCheckResult.anchorPosition;\n\n\twhile (!STOP) {\n\t\tscanNext(); // potentially modifies linePos && anchorPosition\n\t}\n\n\tfunction scanNext(): void {\n\t\tif (IN_DEBUG_MODE) {\n\t\t\tconsole.log('');\n\t\t\tconsole.log('@@scanNext: |' + getString(lineText).replace(/\\n$/, '\\\\n').substr(linePos) + '|');\n\t\t}\n\t\tlet r = matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n\n\t\tif (!r) {\n\t\t\tif (IN_DEBUG_MODE) {\n\t\t\t\tconsole.log('  no more matches.');\n\t\t\t}\n\t\t\t// No match\n\t\t\tlineTokens.produce(stack, lineLength);\n\t\t\tSTOP = true;\n\t\t\treturn;\n\t\t}\n\n\t\tlet captureIndices: IOnigCaptureIndex[] = r.captureIndices;\n\t\tlet matchedRuleId: number = r.matchedRuleId;\n\n\t\tlet hasAdvanced = (captureIndices && captureIndices.length > 0) ? (captureIndices[0].end > linePos) : false;\n\n\t\tif (matchedRuleId === -1) {\n\t\t\t// We matched the `end` for this rule => pop it\n\t\t\tlet poppedRule = <BeginEndRule>stack.getRule(grammar);\n\n\t\t\tif (IN_DEBUG_MODE) {\n\t\t\t\tconsole.log('  popping ' + poppedRule.debugName + ' - ' + poppedRule.debugEndRegExp);\n\t\t\t}\n\n\t\t\tlineTokens.produce(stack, captureIndices[0].start);\n\t\t\tstack = stack.setContentNameScopesList(stack.nameScopesList);\n\t\t\thandleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, poppedRule.endCaptures, captureIndices);\n\t\t\tlineTokens.produce(stack, captureIndices[0].end);\n\n\t\t\t// pop\n\t\t\tlet popped = stack;\n\t\t\tstack = stack.pop();\n\n\t\t\tif (!hasAdvanced && popped.getEnterPos() === linePos) {\n\t\t\t\t// Grammar pushed & popped a rule without advancing\n\t\t\t\tconsole.error('[1] - Grammar is in an endless loop - Grammar pushed & popped a rule without advancing');\n\n\t\t\t\t// See https://github.com/Microsoft/vscode-textmate/issues/12\n\t\t\t\t// Let's assume this was a mistake by the grammar author and the intent was to continue in this state\n\t\t\t\tstack = popped;\n\n\t\t\t\tlineTokens.produce(stack, lineLength);\n\t\t\t\tSTOP = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t// We matched a rule!\n\t\t\tlet _rule = grammar.getRule(matchedRuleId);\n\n\t\t\tlineTokens.produce(stack, captureIndices[0].start);\n\n\t\t\tlet beforePush = stack;\n\t\t\t// push it on the stack rule\n\t\t\tlet scopeName = _rule.getName(getString(lineText), captureIndices);\n\t\t\tlet nameScopesList = stack.contentNameScopesList.push(grammar, scopeName);\n\t\t\tstack = stack.push(matchedRuleId, linePos, null, nameScopesList, nameScopesList);\n\n\t\t\tif (_rule instanceof BeginEndRule) {\n\t\t\t\tlet pushedRule = <BeginEndRule>_rule;\n\t\t\t\tif (IN_DEBUG_MODE) {\n\t\t\t\t\tconsole.log('  pushing ' + pushedRule.debugName + ' - ' + pushedRule.debugBeginRegExp);\n\t\t\t\t}\n\n\t\t\t\thandleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);\n\t\t\t\tlineTokens.produce(stack, captureIndices[0].end);\n\t\t\t\tanchorPosition = captureIndices[0].end;\n\n\t\t\t\tlet contentName = pushedRule.getContentName(getString(lineText), captureIndices);\n\t\t\t\tlet contentNameScopesList = nameScopesList.push(grammar, contentName);\n\t\t\t\tstack = stack.setContentNameScopesList(contentNameScopesList);\n\n\t\t\t\tif (pushedRule.endHasBackReferences) {\n\t\t\t\t\tstack = stack.setEndRule(pushedRule.getEndWithResolvedBackReferences(getString(lineText), captureIndices));\n\t\t\t\t}\n\n\t\t\t\tif (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n\t\t\t\t\t// Grammar pushed the same rule without advancing\n\t\t\t\t\tconsole.error('[2] - Grammar is in an endless loop - Grammar pushed the same rule without advancing');\n\t\t\t\t\tstack = stack.pop();\n\t\t\t\t\tlineTokens.produce(stack, lineLength);\n\t\t\t\t\tSTOP = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (_rule instanceof BeginWhileRule) {\n\t\t\t\tlet pushedRule = <BeginWhileRule>_rule;\n\t\t\t\tif (IN_DEBUG_MODE) {\n\t\t\t\t\tconsole.log('  pushing ' + pushedRule.debugName);\n\t\t\t\t}\n\n\t\t\t\thandleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);\n\t\t\t\tlineTokens.produce(stack, captureIndices[0].end);\n\t\t\t\tanchorPosition = captureIndices[0].end;\n\t\t\t\tlet contentName = pushedRule.getContentName(getString(lineText), captureIndices);\n\t\t\t\tlet contentNameScopesList = nameScopesList.push(grammar, contentName);\n\t\t\t\tstack = stack.setContentNameScopesList(contentNameScopesList);\n\n\t\t\t\tif (pushedRule.whileHasBackReferences) {\n\t\t\t\t\tstack = stack.setEndRule(pushedRule.getWhileWithResolvedBackReferences(getString(lineText), captureIndices));\n\t\t\t\t}\n\n\t\t\t\tif (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n\t\t\t\t\t// Grammar pushed the same rule without advancing\n\t\t\t\t\tconsole.error('[3] - Grammar is in an endless loop - Grammar pushed the same rule without advancing');\n\t\t\t\t\tstack = stack.pop();\n\t\t\t\t\tlineTokens.produce(stack, lineLength);\n\t\t\t\t\tSTOP = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet matchingRule = <MatchRule>_rule;\n\t\t\t\tif (IN_DEBUG_MODE) {\n\t\t\t\t\tconsole.log('  matched ' + matchingRule.debugName + ' - ' + matchingRule.debugMatchRegExp);\n\t\t\t\t}\n\n\t\t\t\thandleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, matchingRule.captures, captureIndices);\n\t\t\t\tlineTokens.produce(stack, captureIndices[0].end);\n\n\t\t\t\t// pop rule immediately since it is a MatchRule\n\t\t\t\tstack = stack.pop();\n\n\t\t\t\tif (!hasAdvanced) {\n\t\t\t\t\t// Grammar is not advancing, nor is it pushing/popping\n\t\t\t\t\tconsole.error('[4] - Grammar is in an endless loop - Grammar is not advancing, nor is it pushing/popping');\n\t\t\t\t\tstack = stack.safePop();\n\t\t\t\t\tlineTokens.produce(stack, lineLength);\n\t\t\t\t\tSTOP = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (captureIndices[0].end > linePos) {\n\t\t\t// Advance stream\n\t\t\tlinePos = captureIndices[0].end;\n\t\t\tisFirstLine = false;\n\t\t}\n\t}\n\n\treturn stack;\n}\n\n\nexport class StackElementMetadata {\n\n\tpublic static toBinaryStr(metadata: number): string {\n\t\tlet r = metadata.toString(2);\n\t\twhile (r.length < 32) {\n\t\t\tr = '0' + r;\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic static printMetadata(metadata: number): void {\n\t\tlet languageId = StackElementMetadata.getLanguageId(metadata);\n\t\tlet tokenType = StackElementMetadata.getTokenType(metadata);\n\t\tlet fontStyle = StackElementMetadata.getFontStyle(metadata);\n\t\tlet foreground = StackElementMetadata.getForeground(metadata);\n\t\tlet background = StackElementMetadata.getBackground(metadata);\n\n\t\tconsole.log({\n\t\t\tlanguageId: languageId,\n\t\t\ttokenType: tokenType,\n\t\t\tfontStyle: fontStyle,\n\t\t\tforeground: foreground,\n\t\t\tbackground: background,\n\t\t});\n\t}\n\n\tpublic static getLanguageId(metadata: number): number {\n\t\treturn (metadata & MetadataConsts.LANGUAGEID_MASK) >>> MetadataConsts.LANGUAGEID_OFFSET;\n\t}\n\n\tpublic static getTokenType(metadata: number): number {\n\t\treturn (metadata & MetadataConsts.TOKEN_TYPE_MASK) >>> MetadataConsts.TOKEN_TYPE_OFFSET;\n\t}\n\n\tpublic static getFontStyle(metadata: number): number {\n\t\treturn (metadata & MetadataConsts.FONT_STYLE_MASK) >>> MetadataConsts.FONT_STYLE_OFFSET;\n\t}\n\n\tpublic static getForeground(metadata: number): number {\n\t\treturn (metadata & MetadataConsts.FOREGROUND_MASK) >>> MetadataConsts.FOREGROUND_OFFSET;\n\t}\n\n\tpublic static getBackground(metadata: number): number {\n\t\treturn (metadata & MetadataConsts.BACKGROUND_MASK) >>> MetadataConsts.BACKGROUND_OFFSET;\n\t}\n\n\tpublic static set(metadata: number, languageId: number, tokenType: TemporaryStandardTokenType, fontStyle: FontStyle, foreground: number, background: number): number {\n\t\tlet _languageId = StackElementMetadata.getLanguageId(metadata);\n\t\tlet _tokenType = StackElementMetadata.getTokenType(metadata);\n\t\tlet _fontStyle = StackElementMetadata.getFontStyle(metadata);\n\t\tlet _foreground = StackElementMetadata.getForeground(metadata);\n\t\tlet _background = StackElementMetadata.getBackground(metadata);\n\n\t\tif (languageId !== 0) {\n\t\t\t_languageId = languageId;\n\t\t}\n\t\tif (tokenType !== TemporaryStandardTokenType.Other) {\n\t\t\t_tokenType = tokenType === TemporaryStandardTokenType.MetaEmbedded ? StandardTokenType.Other : tokenType;\n\t\t}\n\t\tif (fontStyle !== FontStyle.NotSet) {\n\t\t\t_fontStyle = fontStyle;\n\t\t}\n\t\tif (foreground !== 0) {\n\t\t\t_foreground = foreground;\n\t\t}\n\t\tif (background !== 0) {\n\t\t\t_background = background;\n\t\t}\n\n\t\treturn (\n\t\t\t(_languageId << MetadataConsts.LANGUAGEID_OFFSET)\n\t\t\t| (_tokenType << MetadataConsts.TOKEN_TYPE_OFFSET)\n\t\t\t| (_fontStyle << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t\t| (_foreground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t\t| (_background << MetadataConsts.BACKGROUND_OFFSET)\n\t\t) >>> 0;\n\t}\n}\n\nexport class ScopeListElement {\n\t_scopeListElementBrand: void;\n\n\tpublic readonly parent: ScopeListElement;\n\tpublic readonly scope: string;\n\tpublic readonly metadata: number;\n\n\tconstructor(parent: ScopeListElement, scope: string, metadata: number) {\n\t\tthis.parent = parent;\n\t\tthis.scope = scope;\n\t\tthis.metadata = metadata;\n\t}\n\n\tprivate static _equals(a: ScopeListElement, b: ScopeListElement): boolean {\n\t\tdo {\n\t\t\tif (a === b) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (a.scope !== b.scope || a.metadata !== b.metadata) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Go to previous pair\n\t\t\ta = a.parent;\n\t\t\tb = b.parent;\n\n\t\t\tif (!a && !b) {\n\t\t\t\t// End of list reached for both\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!a || !b) {\n\t\t\t\t// End of list reached only for one\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t} while (true);\n\t}\n\n\tpublic equals(other: ScopeListElement): boolean {\n\t\treturn ScopeListElement._equals(this, other);\n\t}\n\n\tprivate static _matchesScope(scope: string, selector: string, selectorWithDot: string): boolean {\n\t\treturn (selector === scope || scope.substring(0, selectorWithDot.length) === selectorWithDot);\n\t}\n\n\tprivate static _matches(target: ScopeListElement, parentScopes: string[]): boolean {\n\t\tif (parentScopes === null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet len = parentScopes.length;\n\t\tlet index = 0;\n\t\tlet selector = parentScopes[index];\n\t\tlet selectorWithDot = selector + '.';\n\n\t\twhile (target) {\n\t\t\tif (this._matchesScope(target.scope, selector, selectorWithDot)) {\n\t\t\t\tindex++;\n\t\t\t\tif (index === len) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tselector = parentScopes[index];\n\t\t\t\tselectorWithDot = selector + '.';\n\t\t\t}\n\t\t\ttarget = target.parent;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static mergeMetadata(metadata: number, scopesList: ScopeListElement, source: ScopeMetadata): number {\n\t\tif (source === null) {\n\t\t\treturn metadata;\n\t\t}\n\n\t\tlet fontStyle = FontStyle.NotSet;\n\t\tlet foreground = 0;\n\t\tlet background = 0;\n\n\t\tif (source.themeData !== null) {\n\t\t\t// Find the first themeData that matches\n\t\t\tfor (let i = 0, len = source.themeData.length; i < len; i++) {\n\t\t\t\tlet themeData = source.themeData[i];\n\n\t\t\t\tif (this._matches(scopesList, themeData.parentScopes)) {\n\t\t\t\t\tfontStyle = themeData.fontStyle;\n\t\t\t\t\tforeground = themeData.foreground;\n\t\t\t\t\tbackground = themeData.background;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn StackElementMetadata.set(metadata, source.languageId, source.tokenType, fontStyle, foreground, background);\n\t}\n\n\tprivate static _push(target: ScopeListElement, grammar: Grammar, scopes: string[]): ScopeListElement {\n\t\tfor (let i = 0, len = scopes.length; i < len; i++) {\n\t\t\tlet scope = scopes[i];\n\t\t\tlet rawMetadata = grammar.getMetadataForScope(scope);\n\t\t\tlet metadata = ScopeListElement.mergeMetadata(target.metadata, target, rawMetadata);\n\t\t\ttarget = new ScopeListElement(target, scope, metadata);\n\t\t}\n\t\treturn target;\n\t}\n\n\tpublic push(grammar: Grammar, scope: string): ScopeListElement {\n\t\tif (scope === null) {\n\t\t\treturn this;\n\t\t}\n\t\tif (scope.indexOf(' ') >= 0) {\n\t\t\t// there are multiple scopes to push\n\t\t\treturn ScopeListElement._push(this, grammar, scope.split(/ /g));\n\t\t}\n\t\t// there is a single scope to push\n\t\treturn ScopeListElement._push(this, grammar, [scope]);\n\t}\n\n\tprivate static _generateScopes(scopesList: ScopeListElement): string[] {\n\t\tlet result: string[] = [], resultLen = 0;\n\t\twhile (scopesList) {\n\t\t\tresult[resultLen++] = scopesList.scope;\n\t\t\tscopesList = scopesList.parent;\n\t\t}\n\t\tresult.reverse();\n\t\treturn result;\n\t}\n\n\tpublic generateScopes(): string[] {\n\t\treturn ScopeListElement._generateScopes(this);\n\t}\n}\n\n/**\n * Represents a \"pushed\" state on the stack (as a linked list element).\n */\nexport class StackElement implements StackElementDef {\n\t_stackElementBrand: void;\n\n\tpublic static NULL = new StackElement(null, 0, 0, null, null, null);\n\n\t/**\n\t * The position on the current line where this state was pushed.\n\t * This is relevant only while tokenizing a line, to detect endless loops.\n\t * Its value is meaningless across lines.\n\t */\n\tprivate _enterPos: number;\n\n\t/**\n\t * The previous state on the stack (or null for the root state).\n\t */\n\tpublic readonly parent: StackElement;\n\t/**\n\t * The depth of the stack.\n\t */\n\tpublic readonly depth: number;\n\n\t/**\n\t * The state (rule) that this element represents.\n\t */\n\tpublic readonly ruleId: number;\n\t/**\n\t * The \"pop\" (end) condition for this state in case that it was dynamically generated through captured text.\n\t */\n\tpublic readonly endRule: string;\n\t/**\n\t * The list of scopes containing the \"name\" for this state.\n\t */\n\tpublic readonly nameScopesList: ScopeListElement;\n\t/**\n\t * The list of scopes containing the \"contentName\" (besides \"name\") for this state.\n\t * This list **must** contain as an element `scopeName`.\n\t */\n\tpublic readonly contentNameScopesList: ScopeListElement;\n\n\tconstructor(parent: StackElement, ruleId: number, enterPos: number, endRule: string, nameScopesList: ScopeListElement, contentNameScopesList: ScopeListElement) {\n\t\tthis.parent = parent;\n\t\tthis.depth = (this.parent ? this.parent.depth + 1 : 1);\n\t\tthis.ruleId = ruleId;\n\t\tthis._enterPos = enterPos;\n\t\tthis.endRule = endRule;\n\t\tthis.nameScopesList = nameScopesList;\n\t\tthis.contentNameScopesList = contentNameScopesList;\n\t}\n\n\t/**\n\t * A structural equals check. Does not take into account `scopes`.\n\t */\n\tprivate static _structuralEquals(a: StackElement, b: StackElement): boolean {\n\t\tdo {\n\t\t\tif (a === b) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Go to previous pair\n\t\t\ta = a.parent;\n\t\t\tb = b.parent;\n\n\t\t\tif (!a && !b) {\n\t\t\t\t// End of list reached for both\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!a || !b) {\n\t\t\t\t// End of list reached only for one\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t} while (true);\n\t}\n\n\tprivate static _equals(a: StackElement, b: StackElement): boolean {\n\t\tif (a === b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!this._structuralEquals(a, b)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.contentNameScopesList.equals(b.contentNameScopesList);\n\t}\n\n\tpublic clone(): StackElement {\n\t\treturn this;\n\t}\n\n\tpublic equals(other: StackElement): boolean {\n\t\tif (other === null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn StackElement._equals(this, other);\n\t}\n\n\tprivate static _reset(el: StackElement): void {\n\t\twhile (el) {\n\t\t\tel._enterPos = -1;\n\t\t\tel = el.parent;\n\t\t}\n\t}\n\n\tpublic reset(): void {\n\t\tStackElement._reset(this);\n\t}\n\n\tpublic pop(): StackElement {\n\t\treturn this.parent;\n\t}\n\n\tpublic safePop(): StackElement {\n\t\tif (this.parent) {\n\t\t\treturn this.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic push(ruleId: number, enterPos: number, endRule: string, nameScopesList: ScopeListElement, contentNameScopesList: ScopeListElement): StackElement {\n\t\treturn new StackElement(this, ruleId, enterPos, endRule, nameScopesList, contentNameScopesList);\n\t}\n\n\tpublic getEnterPos(): number {\n\t\treturn this._enterPos;\n\t}\n\n\tpublic getRule(grammar: IRuleRegistry): Rule {\n\t\treturn grammar.getRule(this.ruleId);\n\t}\n\n\tprivate _writeString(res: string[], outIndex: number): number {\n\t\tif (this.parent) {\n\t\t\toutIndex = this.parent._writeString(res, outIndex);\n\t\t}\n\n\t\tres[outIndex++] = `(${this.ruleId}, TODO-${this.nameScopesList}, TODO-${this.contentNameScopesList})`;\n\n\t\treturn outIndex;\n\t}\n\n\tpublic toString(): string {\n\t\tlet r: string[] = [];\n\t\tthis._writeString(r, 0);\n\t\treturn '[' + r.join(',') + ']';\n\t}\n\n\tpublic setContentNameScopesList(contentNameScopesList: ScopeListElement): StackElement {\n\t\tif (this.contentNameScopesList === contentNameScopesList) {\n\t\t\treturn this;\n\t\t}\n\t\treturn this.parent.push(this.ruleId, this._enterPos, this.endRule, this.nameScopesList, contentNameScopesList);\n\t}\n\n\tpublic setEndRule(endRule: string): StackElement {\n\t\tif (this.endRule === endRule) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new StackElement(this.parent, this.ruleId, this._enterPos, endRule, this.nameScopesList, this.contentNameScopesList);\n\t}\n\n\tpublic hasSameRuleAs(other: StackElement): boolean {\n\t\treturn this.ruleId === other.ruleId;\n\t}\n}\n\nexport class LocalStackElement {\n\tpublic readonly scopes: ScopeListElement;\n\tpublic readonly endPos: number;\n\n\tconstructor(scopes: ScopeListElement, endPos: number) {\n\t\tthis.scopes = scopes;\n\t\tthis.endPos = endPos;\n\t}\n}\n\ninterface TokenTypeMatcher {\n\treadonly matcher: Matcher<string[]>;\n\treadonly type: StandardTokenType;\n}\n\nclass LineTokens {\n\n\tprivate readonly _emitBinaryTokens: boolean;\n\t/**\n\t * defined only if `IN_DEBUG_MODE`.\n\t */\n\tprivate readonly _lineText: string;\n\t/**\n\t * used only if `_emitBinaryTokens` is false.\n\t */\n\tprivate readonly _tokens: IToken[];\n\t/**\n\t * used only if `_emitBinaryTokens` is true.\n\t */\n\tprivate readonly _binaryTokens: number[];\n\n\tprivate _lastTokenEndIndex: number;\n\n\tprivate readonly _tokenTypeOverrides: TokenTypeMatcher[];\n\n\tconstructor(emitBinaryTokens: boolean, lineText: string, tokenTypeOverrides: TokenTypeMatcher[]) {\n\t\tthis._emitBinaryTokens = emitBinaryTokens;\n\t\tthis._tokenTypeOverrides = tokenTypeOverrides;\n\t\tif (IN_DEBUG_MODE) {\n\t\t\tthis._lineText = lineText;\n\t\t}\n\t\tif (this._emitBinaryTokens) {\n\t\t\tthis._binaryTokens = [];\n\t\t} else {\n\t\t\tthis._tokens = [];\n\t\t}\n\t\tthis._lastTokenEndIndex = 0;\n\t}\n\n\tpublic produce(stack: StackElement, endIndex: number): void {\n\t\tthis.produceFromScopes(stack.contentNameScopesList, endIndex);\n\t}\n\n\tpublic produceFromScopes(scopesList: ScopeListElement, endIndex: number): void {\n\t\tif (this._lastTokenEndIndex >= endIndex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._emitBinaryTokens) {\n\t\t\tlet metadata = scopesList.metadata;\n\n\t\t\tfor (const tokenType of this._tokenTypeOverrides) {\n\t\t\t\tif (tokenType.matcher(scopesList.generateScopes())) {\n\t\t\t\t\tmetadata = StackElementMetadata.set(metadata, 0, toTemporaryType(tokenType.type), FontStyle.NotSet, 0, 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {\n\t\t\t\t// no need to push a token with the same metadata\n\t\t\t\tthis._lastTokenEndIndex = endIndex;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._binaryTokens.push(this._lastTokenEndIndex);\n\t\t\tthis._binaryTokens.push(metadata);\n\n\t\t\tthis._lastTokenEndIndex = endIndex;\n\t\t\treturn;\n\t\t}\n\n\t\tlet scopes = scopesList.generateScopes();\n\n\t\tif (IN_DEBUG_MODE) {\n\t\t\tconsole.log('  token: |' + this._lineText.substring(this._lastTokenEndIndex, endIndex).replace(/\\n$/, '\\\\n') + '|');\n\t\t\tfor (var k = 0; k < scopes.length; k++) {\n\t\t\t\tconsole.log('      * ' + scopes[k]);\n\t\t\t}\n\t\t}\n\n\t\tthis._tokens.push({\n\t\t\tstartIndex: this._lastTokenEndIndex,\n\t\t\tendIndex: endIndex,\n\t\t\t// value: lineText.substring(lastTokenEndIndex, endIndex),\n\t\t\tscopes: scopes\n\t\t});\n\n\t\tthis._lastTokenEndIndex = endIndex;\n\t}\n\n\tpublic getResult(stack: StackElement, lineLength: number): IToken[] {\n\t\tif (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {\n\t\t\t// pop produced token for newline\n\t\t\tthis._tokens.pop();\n\t\t}\n\n\t\tif (this._tokens.length === 0) {\n\t\t\tthis._lastTokenEndIndex = -1;\n\t\t\tthis.produce(stack, lineLength);\n\t\t\tthis._tokens[this._tokens.length - 1].startIndex = 0;\n\t\t}\n\n\t\treturn this._tokens;\n\t}\n\n\tpublic getBinaryResult(stack: StackElement, lineLength: number): Uint32Array {\n\t\tif (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {\n\t\t\t// pop produced token for newline\n\t\t\tthis._binaryTokens.pop();\n\t\t\tthis._binaryTokens.pop();\n\t\t}\n\n\t\tif (this._binaryTokens.length === 0) {\n\t\t\tthis._lastTokenEndIndex = -1;\n\t\t\tthis.produce(stack, lineLength);\n\t\t\tthis._binaryTokens[this._binaryTokens.length - 2] = 0;\n\t\t}\n\n\t\tlet result = new Uint32Array(this._binaryTokens.length);\n\t\tfor (let i = 0, len = this._binaryTokens.length; i < len; i++) {\n\t\t\tresult[i] = this._binaryTokens[i];\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nfunction toTemporaryType(standardType: StandardTokenType): TemporaryStandardTokenType {\n\tswitch (standardType) {\n\t\tcase StandardTokenType.RegEx:\n\t\t\treturn TemporaryStandardTokenType.RegEx;\n\t\tcase StandardTokenType.String:\n\t\t\treturn TemporaryStandardTokenType.String;\n\t\tcase StandardTokenType.Comment:\n\t\t\treturn TemporaryStandardTokenType.Comment;\n\t\tcase StandardTokenType.Other:\n\t\tdefault:\n\t\t\t// `MetaEmbedded` is the same scope as `Other`\n\t\t\t// but it overwrites existing token types in the stack.\n\t\t\treturn TemporaryStandardTokenType.MetaEmbedded;\n\t}\n}","/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport { createGrammar, Grammar, collectIncludedScopes, IGrammarRepository, IScopeNameSet } from './grammar';\nimport { IRawGrammar } from './types';\nimport { IGrammar, IEmbeddedLanguagesMap, ITokenTypeMap } from './main';\nimport { Theme, ThemeTrieElementRule } from './theme';\n\nexport class SyncRegistry implements IGrammarRepository {\n\n\tprivate readonly _grammars: { [scopeName: string]: Grammar; };\n\tprivate readonly _rawGrammars: { [scopeName: string]: IRawGrammar; };\n\tprivate readonly _injectionGrammars: { [scopeName: string]: string[]; };\n\tprivate _theme: Theme;\n\n\tconstructor(theme: Theme) {\n\t\tthis._theme = theme;\n\t\tthis._grammars = {};\n\t\tthis._rawGrammars = {};\n\t\tthis._injectionGrammars = {};\n\t}\n\n\tpublic setTheme(theme: Theme): void {\n\t\tthis._theme = theme;\n\t\tObject.keys(this._grammars).forEach((scopeName) => {\n\t\t\tlet grammar = this._grammars[scopeName];\n\t\t\tgrammar.onDidChangeTheme();\n\t\t});\n\t}\n\n\tpublic getColorMap(): string[] {\n\t\treturn this._theme.getColorMap();\n\t}\n\n\t/**\n\t * Add `grammar` to registry and return a list of referenced scope names\n\t */\n\tpublic addGrammar(grammar: IRawGrammar, injectionScopeNames?: string[]): string[] {\n\t\tthis._rawGrammars[grammar.scopeName] = grammar;\n\n\t\tlet includedScopes: IScopeNameSet = {};\n\t\tcollectIncludedScopes(includedScopes, grammar);\n\n\t\tif (injectionScopeNames) {\n\t\t\tthis._injectionGrammars[grammar.scopeName] = injectionScopeNames;\n\t\t\tinjectionScopeNames.forEach(scopeName => {\n\t\t\t\tincludedScopes[scopeName] = true;\n\t\t\t});\n\t\t}\n\t\treturn Object.keys(includedScopes);\n\t}\n\n\t/**\n\t * Lookup a raw grammar.\n\t */\n\tpublic lookup(scopeName: string): IRawGrammar {\n\t\treturn this._rawGrammars[scopeName];\n\t}\n\n\t/**\n\t * Returns the injections for the given grammar\n\t */\n\tpublic injections(targetScope: string): string[] {\n\t\treturn this._injectionGrammars[targetScope];\n\t}\n\n\t/**\n\t * Get the default theme settings\n\t */\n\tpublic getDefaults(): ThemeTrieElementRule {\n\t\treturn this._theme.getDefaults();\n\t}\n\n\t/**\n\t * Match a scope in the theme.\n\t */\n\tpublic themeMatch(scopeName: string): ThemeTrieElementRule[] {\n\t\treturn this._theme.match(scopeName);\n\t}\n\n\n\t/**\n\t * Lookup a grammar.\n\t */\n\tpublic grammarForScopeName(scopeName: string, initialLanguage: number, embeddedLanguages: IEmbeddedLanguagesMap, tokenTypes: ITokenTypeMap): IGrammar {\n\t\tif (!this._grammars[scopeName]) {\n\t\t\tlet rawGrammar = this._rawGrammars[scopeName];\n\t\t\tif (!rawGrammar) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tthis._grammars[scopeName] = createGrammar(rawGrammar, initialLanguage, embeddedLanguages, tokenTypes, this);\n\t\t}\n\t\treturn this._grammars[scopeName];\n\t}\n}\n","/*---------------------------------------------------------\r\n * Copyright (C) Microsoft Corporation. All rights reserved.\r\n *--------------------------------------------------------*/\r\n'use strict';\r\nfunction parseWithLocation(content, filename, locationKeyName) {\r\n    return _parse(content, filename, locationKeyName);\r\n}\r\nexports.parseWithLocation = parseWithLocation;\r\n/**\r\n * A very fast plist parser\r\n */\r\nfunction parse(content) {\r\n    return _parse(content, null, null);\r\n}\r\nexports.parse = parse;\r\nfunction _parse(content, filename, locationKeyName) {\r\n    var len = content.length;\r\n    var pos = 0;\r\n    var line = 1;\r\n    var char = 0;\r\n    // Skip UTF8 BOM\r\n    if (len > 0 && content.charCodeAt(0) === 65279 /* BOM */) {\r\n        pos = 1;\r\n    }\r\n    function advancePosBy(by) {\r\n        if (locationKeyName === null) {\r\n            pos = pos + by;\r\n        }\r\n        else {\r\n            while (by > 0) {\r\n                var chCode = content.charCodeAt(pos);\r\n                if (chCode === 10 /* LINE_FEED */) {\r\n                    pos++;\r\n                    line++;\r\n                    char = 0;\r\n                }\r\n                else {\r\n                    pos++;\r\n                    char++;\r\n                }\r\n                by--;\r\n            }\r\n        }\r\n    }\r\n    function advancePosTo(to) {\r\n        if (locationKeyName === null) {\r\n            pos = to;\r\n        }\r\n        else {\r\n            advancePosBy(to - pos);\r\n        }\r\n    }\r\n    function skipWhitespace() {\r\n        while (pos < len) {\r\n            var chCode = content.charCodeAt(pos);\r\n            if (chCode !== 32 /* SPACE */ && chCode !== 9 /* TAB */ && chCode !== 13 /* CARRIAGE_RETURN */ && chCode !== 10 /* LINE_FEED */) {\r\n                break;\r\n            }\r\n            advancePosBy(1);\r\n        }\r\n    }\r\n    function advanceIfStartsWith(str) {\r\n        if (content.substr(pos, str.length) === str) {\r\n            advancePosBy(str.length);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function advanceUntil(str) {\r\n        var nextOccurence = content.indexOf(str, pos);\r\n        if (nextOccurence !== -1) {\r\n            advancePosTo(nextOccurence + str.length);\r\n        }\r\n        else {\r\n            // EOF\r\n            advancePosTo(len);\r\n        }\r\n    }\r\n    function captureUntil(str) {\r\n        var nextOccurence = content.indexOf(str, pos);\r\n        if (nextOccurence !== -1) {\r\n            var r = content.substring(pos, nextOccurence);\r\n            advancePosTo(nextOccurence + str.length);\r\n            return r;\r\n        }\r\n        else {\r\n            // EOF\r\n            var r = content.substr(pos);\r\n            advancePosTo(len);\r\n            return r;\r\n        }\r\n    }\r\n    var state = 0 /* ROOT_STATE */;\r\n    var cur = null;\r\n    var stateStack = [];\r\n    var objStack = [];\r\n    var curKey = null;\r\n    function pushState(newState, newCur) {\r\n        stateStack.push(state);\r\n        objStack.push(cur);\r\n        state = newState;\r\n        cur = newCur;\r\n    }\r\n    function popState() {\r\n        state = stateStack.pop();\r\n        cur = objStack.pop();\r\n    }\r\n    function fail(msg) {\r\n        throw new Error('Near offset ' + pos + ': ' + msg + ' ~~~' + content.substr(pos, 50) + '~~~');\r\n    }\r\n    var dictState = {\r\n        enterDict: function () {\r\n            if (curKey === null) {\r\n                fail('missing <key>');\r\n            }\r\n            var newDict = {};\r\n            if (locationKeyName !== null) {\r\n                newDict[locationKeyName] = {\r\n                    filename: filename,\r\n                    line: line,\r\n                    char: char\r\n                };\r\n            }\r\n            cur[curKey] = newDict;\r\n            curKey = null;\r\n            pushState(1 /* DICT_STATE */, newDict);\r\n        },\r\n        enterArray: function () {\r\n            if (curKey === null) {\r\n                fail('missing <key>');\r\n            }\r\n            var newArr = [];\r\n            cur[curKey] = newArr;\r\n            curKey = null;\r\n            pushState(2 /* ARR_STATE */, newArr);\r\n        }\r\n    };\r\n    var arrState = {\r\n        enterDict: function () {\r\n            var newDict = {};\r\n            if (locationKeyName !== null) {\r\n                newDict[locationKeyName] = {\r\n                    filename: filename,\r\n                    line: line,\r\n                    char: char\r\n                };\r\n            }\r\n            cur.push(newDict);\r\n            pushState(1 /* DICT_STATE */, newDict);\r\n        },\r\n        enterArray: function () {\r\n            var newArr = [];\r\n            cur.push(newArr);\r\n            pushState(2 /* ARR_STATE */, newArr);\r\n        }\r\n    };\r\n    function enterDict() {\r\n        if (state === 1 /* DICT_STATE */) {\r\n            dictState.enterDict();\r\n        }\r\n        else if (state === 2 /* ARR_STATE */) {\r\n            arrState.enterDict();\r\n        }\r\n        else {\r\n            cur = {};\r\n            if (locationKeyName !== null) {\r\n                cur[locationKeyName] = {\r\n                    filename: filename,\r\n                    line: line,\r\n                    char: char\r\n                };\r\n            }\r\n            pushState(1 /* DICT_STATE */, cur);\r\n        }\r\n    }\r\n    function leaveDict() {\r\n        if (state === 1 /* DICT_STATE */) {\r\n            popState();\r\n        }\r\n        else if (state === 2 /* ARR_STATE */) {\r\n            fail('unexpected </dict>');\r\n        }\r\n        else {\r\n            fail('unexpected </dict>');\r\n        }\r\n    }\r\n    function enterArray() {\r\n        if (state === 1 /* DICT_STATE */) {\r\n            dictState.enterArray();\r\n        }\r\n        else if (state === 2 /* ARR_STATE */) {\r\n            arrState.enterArray();\r\n        }\r\n        else {\r\n            cur = [];\r\n            pushState(2 /* ARR_STATE */, cur);\r\n        }\r\n    }\r\n    function leaveArray() {\r\n        if (state === 1 /* DICT_STATE */) {\r\n            fail('unexpected </array>');\r\n        }\r\n        else if (state === 2 /* ARR_STATE */) {\r\n            popState();\r\n        }\r\n        else {\r\n            fail('unexpected </array>');\r\n        }\r\n    }\r\n    function acceptKey(val) {\r\n        if (state === 1 /* DICT_STATE */) {\r\n            if (curKey !== null) {\r\n                fail('too many <key>');\r\n            }\r\n            curKey = val;\r\n        }\r\n        else if (state === 2 /* ARR_STATE */) {\r\n            fail('unexpected <key>');\r\n        }\r\n        else {\r\n            fail('unexpected <key>');\r\n        }\r\n    }\r\n    function acceptString(val) {\r\n        if (state === 1 /* DICT_STATE */) {\r\n            if (curKey === null) {\r\n                fail('missing <key>');\r\n            }\r\n            cur[curKey] = val;\r\n            curKey = null;\r\n        }\r\n        else if (state === 2 /* ARR_STATE */) {\r\n            cur.push(val);\r\n        }\r\n        else {\r\n            cur = val;\r\n        }\r\n    }\r\n    function acceptReal(val) {\r\n        if (isNaN(val)) {\r\n            fail('cannot parse float');\r\n        }\r\n        if (state === 1 /* DICT_STATE */) {\r\n            if (curKey === null) {\r\n                fail('missing <key>');\r\n            }\r\n            cur[curKey] = val;\r\n            curKey = null;\r\n        }\r\n        else if (state === 2 /* ARR_STATE */) {\r\n            cur.push(val);\r\n        }\r\n        else {\r\n            cur = val;\r\n        }\r\n    }\r\n    function acceptInteger(val) {\r\n        if (isNaN(val)) {\r\n            fail('cannot parse integer');\r\n        }\r\n        if (state === 1 /* DICT_STATE */) {\r\n            if (curKey === null) {\r\n                fail('missing <key>');\r\n            }\r\n            cur[curKey] = val;\r\n            curKey = null;\r\n        }\r\n        else if (state === 2 /* ARR_STATE */) {\r\n            cur.push(val);\r\n        }\r\n        else {\r\n            cur = val;\r\n        }\r\n    }\r\n    function acceptDate(val) {\r\n        if (state === 1 /* DICT_STATE */) {\r\n            if (curKey === null) {\r\n                fail('missing <key>');\r\n            }\r\n            cur[curKey] = val;\r\n            curKey = null;\r\n        }\r\n        else if (state === 2 /* ARR_STATE */) {\r\n            cur.push(val);\r\n        }\r\n        else {\r\n            cur = val;\r\n        }\r\n    }\r\n    function acceptData(val) {\r\n        if (state === 1 /* DICT_STATE */) {\r\n            if (curKey === null) {\r\n                fail('missing <key>');\r\n            }\r\n            cur[curKey] = val;\r\n            curKey = null;\r\n        }\r\n        else if (state === 2 /* ARR_STATE */) {\r\n            cur.push(val);\r\n        }\r\n        else {\r\n            cur = val;\r\n        }\r\n    }\r\n    function acceptBool(val) {\r\n        if (state === 1 /* DICT_STATE */) {\r\n            if (curKey === null) {\r\n                fail('missing <key>');\r\n            }\r\n            cur[curKey] = val;\r\n            curKey = null;\r\n        }\r\n        else if (state === 2 /* ARR_STATE */) {\r\n            cur.push(val);\r\n        }\r\n        else {\r\n            cur = val;\r\n        }\r\n    }\r\n    function escapeVal(str) {\r\n        return str.replace(/&#([0-9]+);/g, function (_, m0) {\r\n            return String.fromCodePoint(parseInt(m0, 10));\r\n        }).replace(/&#x([0-9a-f]+);/g, function (_, m0) {\r\n            return String.fromCodePoint(parseInt(m0, 16));\r\n        }).replace(/&amp;|&lt;|&gt;|&quot;|&apos;/g, function (_) {\r\n            switch (_) {\r\n                case '&amp;': return '&';\r\n                case '&lt;': return '<';\r\n                case '&gt;': return '>';\r\n                case '&quot;': return '\"';\r\n                case '&apos;': return '\\'';\r\n            }\r\n            return _;\r\n        });\r\n    }\r\n    function parseOpenTag() {\r\n        var r = captureUntil('>');\r\n        var isClosed = false;\r\n        if (r.charCodeAt(r.length - 1) === 47 /* SLASH */) {\r\n            isClosed = true;\r\n            r = r.substring(0, r.length - 1);\r\n        }\r\n        return {\r\n            name: r.trim(),\r\n            isClosed: isClosed\r\n        };\r\n    }\r\n    function parseTagValue(tag) {\r\n        if (tag.isClosed) {\r\n            return '';\r\n        }\r\n        var val = captureUntil('</');\r\n        advanceUntil('>');\r\n        return escapeVal(val);\r\n    }\r\n    while (pos < len) {\r\n        skipWhitespace();\r\n        if (pos >= len) {\r\n            break;\r\n        }\r\n        var chCode = content.charCodeAt(pos);\r\n        advancePosBy(1);\r\n        if (chCode !== 60 /* LESS_THAN */) {\r\n            fail('expected <');\r\n        }\r\n        if (pos >= len) {\r\n            fail('unexpected end of input');\r\n        }\r\n        var peekChCode = content.charCodeAt(pos);\r\n        if (peekChCode === 63 /* QUESTION_MARK */) {\r\n            advancePosBy(1);\r\n            advanceUntil('?>');\r\n            continue;\r\n        }\r\n        if (peekChCode === 33 /* EXCLAMATION_MARK */) {\r\n            advancePosBy(1);\r\n            if (advanceIfStartsWith('--')) {\r\n                advanceUntil('-->');\r\n                continue;\r\n            }\r\n            advanceUntil('>');\r\n            continue;\r\n        }\r\n        if (peekChCode === 47 /* SLASH */) {\r\n            advancePosBy(1);\r\n            skipWhitespace();\r\n            if (advanceIfStartsWith('plist')) {\r\n                advanceUntil('>');\r\n                continue;\r\n            }\r\n            if (advanceIfStartsWith('dict')) {\r\n                advanceUntil('>');\r\n                leaveDict();\r\n                continue;\r\n            }\r\n            if (advanceIfStartsWith('array')) {\r\n                advanceUntil('>');\r\n                leaveArray();\r\n                continue;\r\n            }\r\n            fail('unexpected closed tag');\r\n        }\r\n        var tag = parseOpenTag();\r\n        switch (tag.name) {\r\n            case 'dict':\r\n                enterDict();\r\n                if (tag.isClosed) {\r\n                    leaveDict();\r\n                }\r\n                continue;\r\n            case 'array':\r\n                enterArray();\r\n                if (tag.isClosed) {\r\n                    leaveArray();\r\n                }\r\n                continue;\r\n            case 'key':\r\n                acceptKey(parseTagValue(tag));\r\n                continue;\r\n            case 'string':\r\n                acceptString(parseTagValue(tag));\r\n                continue;\r\n            case 'real':\r\n                acceptReal(parseFloat(parseTagValue(tag)));\r\n                continue;\r\n            case 'integer':\r\n                acceptInteger(parseInt(parseTagValue(tag), 10));\r\n                continue;\r\n            case 'date':\r\n                acceptDate(new Date(parseTagValue(tag)));\r\n                continue;\r\n            case 'data':\r\n                acceptData(parseTagValue(tag));\r\n                continue;\r\n            case 'true':\r\n                parseTagValue(tag);\r\n                acceptBool(true);\r\n                continue;\r\n            case 'false':\r\n                parseTagValue(tag);\r\n                acceptBool(false);\r\n                continue;\r\n        }\r\n        if (/^plist/.test(tag.name)) {\r\n            continue;\r\n        }\r\n        fail('unexpected opened tag ' + tag.name);\r\n    }\r\n    return cur;\r\n}\r\n","/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nfunction doFail(streamState: JSONStreamState, msg: string): void {\n\t// console.log('Near offset ' + streamState.pos + ': ' + msg + ' ~~~' + streamState.source.substr(streamState.pos, 50) + '~~~');\n\tthrow new Error('Near offset ' + streamState.pos + ': ' + msg + ' ~~~' + streamState.source.substr(streamState.pos, 50) + '~~~');\n}\n\nexport interface ILocation {\n\treadonly filename: string;\n\treadonly line: number;\n\treadonly char: number;\n}\n\nexport function parse(source: string, filename: string, withMetadata: boolean): any {\n\tlet streamState = new JSONStreamState(source);\n\tlet token = new JSONToken();\n\tlet state = JSONState.ROOT_STATE;\n\tlet cur: any = null;\n\tlet stateStack: JSONState[] = [];\n\tlet objStack: any[] = [];\n\n\tfunction pushState(): void {\n\t\tstateStack.push(state);\n\t\tobjStack.push(cur);\n\t}\n\n\tfunction popState(): void {\n\t\tstate = stateStack.pop();\n\t\tcur = objStack.pop();\n\t}\n\n\tfunction fail(msg: string): void {\n\t\tdoFail(streamState, msg);\n\t}\n\n\twhile (nextJSONToken(streamState, token)) {\n\n\t\tif (state === JSONState.ROOT_STATE) {\n\t\t\tif (cur !== null) {\n\t\t\t\tfail('too many constructs in root');\n\t\t\t}\n\n\t\t\tif (token.type === JSONTokenType.LEFT_CURLY_BRACKET) {\n\t\t\t\tcur = {};\n\t\t\t\tif (withMetadata) {\n\t\t\t\t\tcur.$vscodeTextmateLocation = token.toLocation(filename);\n\t\t\t\t}\n\t\t\t\tpushState();\n\t\t\t\tstate = JSONState.DICT_STATE;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (token.type === JSONTokenType.LEFT_SQUARE_BRACKET) {\n\t\t\t\tcur = [];\n\t\t\t\tpushState();\n\t\t\t\tstate = JSONState.ARR_STATE;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfail('unexpected token in root');\n\n\t\t}\n\n\t\tif (state === JSONState.DICT_STATE_COMMA) {\n\n\t\t\tif (token.type === JSONTokenType.RIGHT_CURLY_BRACKET) {\n\t\t\t\tpopState();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (token.type === JSONTokenType.COMMA) {\n\t\t\t\tstate = JSONState.DICT_STATE_NO_CLOSE;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfail('expected , or }');\n\n\t\t}\n\n\t\tif (state === JSONState.DICT_STATE || state === JSONState.DICT_STATE_NO_CLOSE) {\n\n\t\t\tif (state === JSONState.DICT_STATE && token.type === JSONTokenType.RIGHT_CURLY_BRACKET) {\n\t\t\t\tpopState();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (token.type === JSONTokenType.STRING) {\n\t\t\t\tlet keyValue = token.value;\n\n\t\t\t\tif (!nextJSONToken(streamState, token) || (/*TS bug*/<any>token.type) !== JSONTokenType.COLON) {\n\t\t\t\t\tfail('expected colon');\n\t\t\t\t}\n\t\t\t\tif (!nextJSONToken(streamState, token)) {\n\t\t\t\t\tfail('expected value');\n\t\t\t\t}\n\n\t\t\t\tstate = JSONState.DICT_STATE_COMMA;\n\n\t\t\t\tif (token.type === JSONTokenType.STRING) {\n\t\t\t\t\tcur[keyValue] = token.value;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (token.type === JSONTokenType.NULL) {\n\t\t\t\t\tcur[keyValue] = null;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (token.type === JSONTokenType.TRUE) {\n\t\t\t\t\tcur[keyValue] = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (token.type === JSONTokenType.FALSE) {\n\t\t\t\t\tcur[keyValue] = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (token.type === JSONTokenType.NUMBER) {\n\t\t\t\t\tcur[keyValue] = parseFloat(token.value);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (token.type === JSONTokenType.LEFT_SQUARE_BRACKET) {\n\t\t\t\t\tlet newArr: any[] = [];\n\t\t\t\t\tcur[keyValue] = newArr;\n\t\t\t\t\tpushState();\n\t\t\t\t\tstate = JSONState.ARR_STATE;\n\t\t\t\t\tcur = newArr;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (token.type === JSONTokenType.LEFT_CURLY_BRACKET) {\n\t\t\t\t\tlet newDict: any = {};\n\t\t\t\t\tif (withMetadata) {\n\t\t\t\t\t\tnewDict.$vscodeTextmateLocation = token.toLocation(filename);\n\t\t\t\t\t}\n\t\t\t\t\tcur[keyValue] = newDict;\n\t\t\t\t\tpushState();\n\t\t\t\t\tstate = JSONState.DICT_STATE;\n\t\t\t\t\tcur = newDict;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfail('unexpected token in dict');\n\t\t}\n\n\t\tif (state === JSONState.ARR_STATE_COMMA) {\n\n\t\t\tif (token.type === JSONTokenType.RIGHT_SQUARE_BRACKET) {\n\t\t\t\tpopState();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (token.type === JSONTokenType.COMMA) {\n\t\t\t\tstate = JSONState.ARR_STATE_NO_CLOSE;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfail('expected , or ]');\n\t\t}\n\n\t\tif (state === JSONState.ARR_STATE || state === JSONState.ARR_STATE_NO_CLOSE) {\n\n\t\t\tif (state === JSONState.ARR_STATE && token.type === JSONTokenType.RIGHT_SQUARE_BRACKET) {\n\t\t\t\tpopState();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstate = JSONState.ARR_STATE_COMMA;\n\n\t\t\tif (token.type === JSONTokenType.STRING) {\n\t\t\t\tcur.push(token.value);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (token.type === JSONTokenType.NULL) {\n\t\t\t\tcur.push(null);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (token.type === JSONTokenType.TRUE) {\n\t\t\t\tcur.push(true);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (token.type === JSONTokenType.FALSE) {\n\t\t\t\tcur.push(false);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (token.type === JSONTokenType.NUMBER) {\n\t\t\t\tcur.push(parseFloat(token.value));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (token.type === JSONTokenType.LEFT_SQUARE_BRACKET) {\n\t\t\t\tlet newArr: any[] = [];\n\t\t\t\tcur.push(newArr);\n\t\t\t\tpushState();\n\t\t\t\tstate = JSONState.ARR_STATE;\n\t\t\t\tcur = newArr;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (token.type === JSONTokenType.LEFT_CURLY_BRACKET) {\n\t\t\t\tlet newDict: any = {};\n\t\t\t\tif (withMetadata) {\n\t\t\t\t\tnewDict.$vscodeTextmateLocation = token.toLocation(filename);\n\t\t\t\t}\n\t\t\t\tcur.push(newDict);\n\t\t\t\tpushState();\n\t\t\t\tstate = JSONState.DICT_STATE;\n\t\t\t\tcur = newDict;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfail('unexpected token in array');\n\t\t}\n\n\t\tfail('unknown state');\n\t}\n\n\tif (objStack.length !== 0) {\n\t\tfail('unclosed constructs');\n\t}\n\n\treturn cur;\n}\n\nclass JSONStreamState {\n\tsource: string;\n\n\tpos: number;\n\tlen: number;\n\n\tline: number;\n\tchar: number;\n\n\tconstructor(source: string) {\n\t\tthis.source = source;\n\t\tthis.pos = 0;\n\t\tthis.len = source.length;\n\t\tthis.line = 1;\n\t\tthis.char = 0;\n\t}\n}\n\nconst enum JSONTokenType {\n\tUNKNOWN = 0,\n\tSTRING = 1,\n\tLEFT_SQUARE_BRACKET = 2, // [\n\tLEFT_CURLY_BRACKET = 3, // {\n\tRIGHT_SQUARE_BRACKET = 4, // ]\n\tRIGHT_CURLY_BRACKET = 5, // }\n\tCOLON = 6, // :\n\tCOMMA = 7, // ,\n\tNULL = 8,\n\tTRUE = 9,\n\tFALSE = 10,\n\tNUMBER = 11\n}\n\nconst enum JSONState {\n\tROOT_STATE = 0,\n\tDICT_STATE = 1,\n\tDICT_STATE_COMMA = 2,\n\tDICT_STATE_NO_CLOSE = 3,\n\tARR_STATE = 4,\n\tARR_STATE_COMMA = 5,\n\tARR_STATE_NO_CLOSE = 6,\n}\n\nconst enum ChCode {\n\tSPACE = 0x20,\n\tHORIZONTAL_TAB = 0x09,\n\tCARRIAGE_RETURN = 0x0D,\n\tLINE_FEED = 0x0A,\n\tQUOTATION_MARK = 0x22,\n\tBACKSLASH = 0x5C,\n\n\tLEFT_SQUARE_BRACKET = 0x5B,\n\tLEFT_CURLY_BRACKET = 0x7B,\n\tRIGHT_SQUARE_BRACKET = 0x5D,\n\tRIGHT_CURLY_BRACKET = 0x7D,\n\tCOLON = 0x3A,\n\tCOMMA = 0x2C,\n\tDOT = 0x2E,\n\n\tD0 = 0x30,\n\tD9 = 0x39,\n\n\tMINUS = 0x2D,\n\tPLUS = 0x2B,\n\n\tE = 0x45,\n\n\ta = 0x61,\n\te = 0x65,\n\tf = 0x66,\n\tl = 0x6C,\n\tn = 0x6E,\n\tr = 0x72,\n\ts = 0x73,\n\tt = 0x74,\n\tu = 0x75,\n}\n\nclass JSONToken {\n\tvalue: string;\n\ttype: JSONTokenType;\n\n\toffset: number;\n\tlen: number;\n\n\tline: number; /* 1 based line number */\n\tchar: number;\n\n\tconstructor() {\n\t\tthis.value = null;\n\t\tthis.offset = -1;\n\t\tthis.len = -1;\n\t\tthis.line = -1;\n\t\tthis.char = -1;\n\t}\n\n\ttoLocation(filename: string): ILocation {\n\t\treturn {\n\t\t\tfilename: filename,\n\t\t\tline: this.line,\n\t\t\tchar: this.char\n\t\t};\n\t}\n}\n\n/**\n * precondition: the string is known to be valid JSON (https://www.ietf.org/rfc/rfc4627.txt)\n */\nfunction nextJSONToken(_state: JSONStreamState, _out: JSONToken): boolean {\n\t_out.value = null;\n\t_out.type = JSONTokenType.UNKNOWN;\n\t_out.offset = -1;\n\t_out.len = -1;\n\t_out.line = -1;\n\t_out.char = -1;\n\n\tlet source = _state.source;\n\tlet pos = _state.pos;\n\tlet len = _state.len;\n\tlet line = _state.line;\n\tlet char = _state.char;\n\n\t//------------------------ skip whitespace\n\tlet chCode: number;\n\tdo {\n\t\tif (pos >= len) {\n\t\t\treturn false; /*EOS*/\n\t\t}\n\n\t\tchCode = source.charCodeAt(pos);\n\t\tif (chCode === ChCode.SPACE || chCode === ChCode.HORIZONTAL_TAB || chCode === ChCode.CARRIAGE_RETURN) {\n\t\t\t// regular whitespace\n\t\t\tpos++; char++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chCode === ChCode.LINE_FEED) {\n\t\t\t// newline\n\t\t\tpos++; line++; char = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// not whitespace\n\t\tbreak;\n\t} while (true);\n\n\t_out.offset = pos;\n\t_out.line = line;\n\t_out.char = char;\n\n\tif (chCode === ChCode.QUOTATION_MARK) {\n\t\t//------------------------ strings\n\t\t_out.type = JSONTokenType.STRING;\n\n\t\tpos++; char++;\n\n\t\tdo {\n\t\t\tif (pos >= len) {\n\t\t\t\treturn false; /*EOS*/\n\t\t\t}\n\n\t\t\tchCode = source.charCodeAt(pos);\n\t\t\tpos++; char++;\n\n\t\t\tif (chCode === ChCode.BACKSLASH) {\n\t\t\t\t// skip next char\n\t\t\t\tpos++; char++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chCode === ChCode.QUOTATION_MARK) {\n\t\t\t\t// end of the string\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (true);\n\n\t\t_out.value = source.substring(_out.offset + 1, pos - 1).replace(/\\\\u([0-9A-Fa-f]{4})/g, (_, m0) => {\n\t\t\treturn (<any>String).fromCodePoint(parseInt(m0, 16));\n\t\t}).replace(/\\\\(.)/g, (_, m0) => {\n\t\t\tswitch (m0) {\n\t\t\t\tcase '\"': return '\"';\n\t\t\t\tcase '\\\\': return '\\\\';\n\t\t\t\tcase '/': return '/';\n\t\t\t\tcase 'b': return '\\b';\n\t\t\t\tcase 'f': return '\\f';\n\t\t\t\tcase 'n': return '\\n';\n\t\t\t\tcase 'r': return '\\r';\n\t\t\t\tcase 't': return '\\t';\n\t\t\t\tdefault: doFail(_state, 'invalid escape sequence');\n\t\t\t}\n\t\t});\n\n\t} else if (chCode === ChCode.LEFT_SQUARE_BRACKET) {\n\n\t\t_out.type = JSONTokenType.LEFT_SQUARE_BRACKET;\n\t\tpos++; char++;\n\n\t} else if (chCode === ChCode.LEFT_CURLY_BRACKET) {\n\n\t\t_out.type = JSONTokenType.LEFT_CURLY_BRACKET;\n\t\tpos++; char++;\n\n\t} else if (chCode === ChCode.RIGHT_SQUARE_BRACKET) {\n\n\t\t_out.type = JSONTokenType.RIGHT_SQUARE_BRACKET;\n\t\tpos++; char++;\n\n\t} else if (chCode === ChCode.RIGHT_CURLY_BRACKET) {\n\n\t\t_out.type = JSONTokenType.RIGHT_CURLY_BRACKET;\n\t\tpos++; char++;\n\n\t} else if (chCode === ChCode.COLON) {\n\n\t\t_out.type = JSONTokenType.COLON;\n\t\tpos++; char++;\n\n\t} else if (chCode === ChCode.COMMA) {\n\n\t\t_out.type = JSONTokenType.COMMA;\n\t\tpos++; char++;\n\n\t} else if (chCode === ChCode.n) {\n\t\t//------------------------ null\n\n\t\t_out.type = JSONTokenType.NULL;\n\t\tpos++; char++; chCode = source.charCodeAt(pos);\n\t\tif (chCode !== ChCode.u) { return false; /* INVALID */ }\n\t\tpos++; char++; chCode = source.charCodeAt(pos);\n\t\tif (chCode !== ChCode.l) { return false; /* INVALID */ }\n\t\tpos++; char++; chCode = source.charCodeAt(pos);\n\t\tif (chCode !== ChCode.l) { return false; /* INVALID */ }\n\t\tpos++; char++;\n\n\t} else if (chCode === ChCode.t) {\n\t\t//------------------------ true\n\n\t\t_out.type = JSONTokenType.TRUE;\n\t\tpos++; char++; chCode = source.charCodeAt(pos);\n\t\tif (chCode !== ChCode.r) { return false; /* INVALID */ }\n\t\tpos++; char++; chCode = source.charCodeAt(pos);\n\t\tif (chCode !== ChCode.u) { return false; /* INVALID */ }\n\t\tpos++; char++; chCode = source.charCodeAt(pos);\n\t\tif (chCode !== ChCode.e) { return false; /* INVALID */ }\n\t\tpos++; char++;\n\n\t} else if (chCode === ChCode.f) {\n\t\t//------------------------ false\n\n\t\t_out.type = JSONTokenType.FALSE;\n\t\tpos++; char++; chCode = source.charCodeAt(pos);\n\t\tif (chCode !== ChCode.a) { return false; /* INVALID */ }\n\t\tpos++; char++; chCode = source.charCodeAt(pos);\n\t\tif (chCode !== ChCode.l) { return false; /* INVALID */ }\n\t\tpos++; char++; chCode = source.charCodeAt(pos);\n\t\tif (chCode !== ChCode.s) { return false; /* INVALID */ }\n\t\tpos++; char++; chCode = source.charCodeAt(pos);\n\t\tif (chCode !== ChCode.e) { return false; /* INVALID */ }\n\t\tpos++; char++;\n\n\t} else {\n\t\t//------------------------ numbers\n\n\t\t_out.type = JSONTokenType.NUMBER;\n\t\tdo {\n\t\t\tif (pos >= len) { return false; /*EOS*/ }\n\n\t\t\tchCode = source.charCodeAt(pos);\n\t\t\tif (\n\t\t\t\tchCode === ChCode.DOT\n\t\t\t\t|| (chCode >= ChCode.D0 && chCode <= ChCode.D9)\n\t\t\t\t|| (chCode === ChCode.e || chCode === ChCode.E)\n\t\t\t\t|| (chCode === ChCode.MINUS || chCode === ChCode.PLUS)\n\t\t\t) {\n\t\t\t\t// looks like a piece of a number\n\t\t\t\tpos++; char++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// pos--; char--;\n\t\t\tbreak;\n\t\t} while (true);\n\t}\n\n\t_out.len = pos - _out.offset;\n\tif (_out.value === null) {\n\t\t_out.value = source.substr(_out.offset, _out.len);\n\t}\n\n\t_state.pos = pos;\n\t_state.line = line;\n\t_state.char = char;\n\n\t// console.log('PRODUCING TOKEN: ', _out.value, JSONTokenType[_out.type]);\n\n\treturn true;\n}\n","/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport { IRawGrammar } from './types';\nimport * as plist from 'fast-plist';\nimport { CAPTURE_METADATA } from './debug';\nimport { parse as manualParseJSON } from './json';\n\nexport function parseJSONGrammar(contents: string, filename: string): IRawGrammar {\n\tif (CAPTURE_METADATA) {\n\t\treturn <IRawGrammar>manualParseJSON(contents, filename, true);\n\t}\n\treturn <IRawGrammar>JSON.parse(contents);\n}\n\nexport function parsePLISTGrammar(contents: string, filename: string): IRawGrammar {\n\tif (CAPTURE_METADATA) {\n\t\treturn <IRawGrammar>plist.parseWithLocation(contents, filename, '$vscodeTextmateLocation');\n\t}\n\treturn <IRawGrammar>plist.parse(contents);\n}\n","/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport { IRawTheme } from './main';\n\nexport const enum FontStyle {\n\tNotSet = -1,\n\tNone = 0,\n\tItalic = 1,\n\tBold = 2,\n\tUnderline = 4\n}\n\nexport class ParsedThemeRule {\n\t_parsedThemeRuleBrand: void;\n\n\treadonly scope: string;\n\treadonly parentScopes: string[];\n\treadonly index: number;\n\n\t/**\n\t * -1 if not set. An or mask of `FontStyle` otherwise.\n\t */\n\treadonly fontStyle: number;\n\treadonly foreground: string;\n\treadonly background: string;\n\n\tconstructor(\n\t\tscope: string,\n\t\tparentScopes: string[],\n\t\tindex: number,\n\t\tfontStyle: number,\n\t\tforeground: string,\n\t\tbackground: string,\n\t) {\n\t\tthis.scope = scope;\n\t\tthis.parentScopes = parentScopes;\n\t\tthis.index = index;\n\t\tthis.fontStyle = fontStyle;\n\t\tthis.foreground = foreground;\n\t\tthis.background = background;\n\t}\n}\n\nfunction isValidHexColor(hex: string): boolean {\n\tif (/^#[0-9a-f]{6}$/i.test(hex)) {\n\t\t// #rrggbb\n\t\treturn true;\n\t}\n\n\tif (/^#[0-9a-f]{8}$/i.test(hex)) {\n\t\t// #rrggbbaa\n\t\treturn true;\n\t}\n\n\tif (/^#[0-9a-f]{3}$/i.test(hex)) {\n\t\t// #rgb\n\t\treturn true;\n\t}\n\n\tif (/^#[0-9a-f]{4}$/i.test(hex)) {\n\t\t// #rgba\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTheme(source: IRawTheme): ParsedThemeRule[] {\n\tif (!source) {\n\t\treturn [];\n\t}\n\tif (!source.settings || !Array.isArray(source.settings)) {\n\t\treturn [];\n\t}\n\tlet settings = source.settings;\n\tlet result: ParsedThemeRule[] = [], resultLen = 0;\n\tfor (let i = 0, len = settings.length; i < len; i++) {\n\t\tlet entry = settings[i];\n\n\t\tif (!entry.settings) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet scopes: string[];\n\t\tif (typeof entry.scope === 'string') {\n\t\t\tlet _scope = entry.scope;\n\n\t\t\t// remove leading commas\n\t\t\t_scope = _scope.replace(/^[,]+/, '');\n\n\t\t\t// remove trailing commans\n\t\t\t_scope = _scope.replace(/[,]+$/, '');\n\n\t\t\tscopes = _scope.split(',');\n\t\t} else if (Array.isArray(entry.scope)) {\n\t\t\tscopes = entry.scope;\n\t\t} else {\n\t\t\tscopes = [''];\n\t\t}\n\n\t\tlet fontStyle: number = FontStyle.NotSet;\n\t\tif (typeof entry.settings.fontStyle === 'string') {\n\t\t\tfontStyle = FontStyle.None;\n\n\t\t\tlet segments = entry.settings.fontStyle.split(' ');\n\t\t\tfor (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n\t\t\t\tlet segment = segments[j];\n\t\t\t\tswitch (segment) {\n\t\t\t\t\tcase 'italic':\n\t\t\t\t\t\tfontStyle = fontStyle | FontStyle.Italic;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'bold':\n\t\t\t\t\t\tfontStyle = fontStyle | FontStyle.Bold;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'underline':\n\t\t\t\t\t\tfontStyle = fontStyle | FontStyle.Underline;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet foreground: string = null;\n\t\tif (typeof entry.settings.foreground === 'string' && isValidHexColor(entry.settings.foreground)) {\n\t\t\tforeground = entry.settings.foreground;\n\t\t}\n\n\t\tlet background: string = null;\n\t\tif (typeof entry.settings.background === 'string' && isValidHexColor(entry.settings.background)) {\n\t\t\tbackground = entry.settings.background;\n\t\t}\n\n\t\tfor (let j = 0, lenJ = scopes.length; j < lenJ; j++) {\n\t\t\tlet _scope = scopes[j].trim();\n\n\t\t\tlet segments = _scope.split(' ');\n\n\t\t\tlet scope = segments[segments.length - 1];\n\t\t\tlet parentScopes: string[] = null;\n\t\t\tif (segments.length > 1) {\n\t\t\t\tparentScopes = segments.slice(0, segments.length - 1);\n\t\t\t\tparentScopes.reverse();\n\t\t\t}\n\n\t\t\tresult[resultLen++] = new ParsedThemeRule(\n\t\t\t\tscope,\n\t\t\t\tparentScopes,\n\t\t\t\ti,\n\t\t\t\tfontStyle,\n\t\t\t\tforeground,\n\t\t\t\tbackground\n\t\t\t);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedThemeRules(parsedThemeRules: ParsedThemeRule[]): Theme {\n\n\t// Sort rules lexicographically, and then by index if necessary\n\tparsedThemeRules.sort((a, b) => {\n\t\tlet r = strcmp(a.scope, b.scope);\n\t\tif (r !== 0) {\n\t\t\treturn r;\n\t\t}\n\t\tr = strArrCmp(a.parentScopes, b.parentScopes);\n\t\tif (r !== 0) {\n\t\t\treturn r;\n\t\t}\n\t\treturn a.index - b.index;\n\t});\n\n\t// Determine defaults\n\tlet defaultFontStyle = FontStyle.None;\n\tlet defaultForeground = '#000000';\n\tlet defaultBackground = '#ffffff';\n\twhile (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === '') {\n\t\tlet incomingDefaults = parsedThemeRules.shift();\n\t\tif (incomingDefaults.fontStyle !== FontStyle.NotSet) {\n\t\t\tdefaultFontStyle = incomingDefaults.fontStyle;\n\t\t}\n\t\tif (incomingDefaults.foreground !== null) {\n\t\t\tdefaultForeground = incomingDefaults.foreground;\n\t\t}\n\t\tif (incomingDefaults.background !== null) {\n\t\t\tdefaultBackground = incomingDefaults.background;\n\t\t}\n\t}\n\tlet colorMap = new ColorMap();\n\tlet defaults = new ThemeTrieElementRule(0, null, defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));\n\n\tlet root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, FontStyle.NotSet, 0, 0), []);\n\tfor (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n\t\tlet rule = parsedThemeRules[i];\n\t\troot.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n\t}\n\n\treturn new Theme(colorMap, defaults, root);\n}\n\nexport class ColorMap {\n\n\tprivate _lastColorId: number;\n\tprivate _id2color: string[];\n\tprivate _color2id: { [color: string]: number; };\n\n\tconstructor() {\n\t\tthis._lastColorId = 0;\n\t\tthis._id2color = [];\n\t\tthis._color2id = Object.create(null);\n\t}\n\n\tpublic getId(color: string): number {\n\t\tif (color === null) {\n\t\t\treturn 0;\n\t\t}\n\t\tcolor = color.toUpperCase();\n\t\tlet value = this._color2id[color];\n\t\tif (value) {\n\t\t\treturn value;\n\t\t}\n\t\tvalue = ++this._lastColorId;\n\t\tthis._color2id[color] = value;\n\t\tthis._id2color[value] = color;\n\t\treturn value;\n\t}\n\n\tpublic getColorMap(): string[] {\n\t\treturn this._id2color.slice(0);\n\t}\n\n}\n\nexport class Theme {\n\n\tpublic static createFromRawTheme(source: IRawTheme): Theme {\n\t\treturn this.createFromParsedTheme(parseTheme(source));\n\t}\n\n\tpublic static createFromParsedTheme(source: ParsedThemeRule[]): Theme {\n\t\treturn resolveParsedThemeRules(source);\n\t}\n\n\tprivate readonly _colorMap: ColorMap;\n\tprivate readonly _root: ThemeTrieElement;\n\tprivate readonly _defaults: ThemeTrieElementRule;\n\tprivate readonly _cache: { [scopeName: string]: ThemeTrieElementRule[]; };\n\n\tconstructor(colorMap: ColorMap, defaults: ThemeTrieElementRule, root: ThemeTrieElement) {\n\t\tthis._colorMap = colorMap;\n\t\tthis._root = root;\n\t\tthis._defaults = defaults;\n\t\tthis._cache = {};\n\t}\n\n\tpublic getColorMap(): string[] {\n\t\treturn this._colorMap.getColorMap();\n\t}\n\n\tpublic getDefaults(): ThemeTrieElementRule {\n\t\treturn this._defaults;\n\t}\n\n\tpublic match(scopeName: string): ThemeTrieElementRule[] {\n\t\tif (!this._cache.hasOwnProperty(scopeName)) {\n\t\t\tthis._cache[scopeName] = this._root.match(scopeName);\n\t\t}\n\t\treturn this._cache[scopeName];\n\t}\n}\n\nexport function strcmp(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t}\n\tif (a > b) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nexport function strArrCmp(a: string[], b: string[]): number {\n\tif (a === null && b === null) {\n\t\treturn 0;\n\t}\n\tif (!a) {\n\t\treturn -1;\n\t}\n\tif (!b) {\n\t\treturn 1;\n\t}\n\tlet len1 = a.length;\n\tlet len2 = b.length;\n\tif (len1 === len2) {\n\t\tfor (let i = 0; i < len1; i++) {\n\t\t\tlet res = strcmp(a[i], b[i]);\n\t\t\tif (res !== 0) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\treturn len1 - len2;\n}\n\nexport class ThemeTrieElementRule {\n\t_themeTrieElementRuleBrand: void;\n\n\tscopeDepth: number;\n\tparentScopes: string[];\n\tfontStyle: number;\n\tforeground: number;\n\tbackground: number;\n\n\tconstructor(scopeDepth: number, parentScopes: string[], fontStyle: number, foreground: number, background: number) {\n\t\tthis.scopeDepth = scopeDepth;\n\t\tthis.parentScopes = parentScopes;\n\t\tthis.fontStyle = fontStyle;\n\t\tthis.foreground = foreground;\n\t\tthis.background = background;\n\t}\n\n\tpublic clone(): ThemeTrieElementRule {\n\t\treturn new ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);\n\t}\n\n\tpublic static cloneArr(arr:ThemeTrieElementRule[]): ThemeTrieElementRule[] {\n\t\tlet r: ThemeTrieElementRule[] = [];\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tr[i] = arr[i].clone();\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic acceptOverwrite(scopeDepth: number, fontStyle: number, foreground: number, background: number): void {\n\t\tif (this.scopeDepth > scopeDepth) {\n\t\t\tconsole.log('how did this happen?');\n\t\t} else {\n\t\t\tthis.scopeDepth = scopeDepth;\n\t\t}\n\t\t// console.log('TODO -> my depth: ' + this.scopeDepth + ', overwriting depth: ' + scopeDepth);\n\t\tif (fontStyle !== FontStyle.NotSet) {\n\t\t\tthis.fontStyle = fontStyle;\n\t\t}\n\t\tif (foreground !== 0) {\n\t\t\tthis.foreground = foreground;\n\t\t}\n\t\tif (background !== 0) {\n\t\t\tthis.background = background;\n\t\t}\n\t}\n}\n\nexport interface ITrieChildrenMap {\n\t[segment: string]: ThemeTrieElement;\n}\n\nexport class ThemeTrieElement {\n\t_themeTrieElementBrand: void;\n\n\tprivate readonly _mainRule: ThemeTrieElementRule;\n\tprivate readonly _rulesWithParentScopes: ThemeTrieElementRule[];\n\tprivate readonly _children: ITrieChildrenMap;\n\n\tconstructor(\n\t\tmainRule: ThemeTrieElementRule,\n\t\trulesWithParentScopes: ThemeTrieElementRule[] = [],\n\t\tchildren: ITrieChildrenMap = {}\n\t) {\n\t\tthis._mainRule = mainRule;\n\t\tthis._rulesWithParentScopes = rulesWithParentScopes;\n\t\tthis._children = children;\n\t}\n\n\tprivate static _sortBySpecificity(arr: ThemeTrieElementRule[]): ThemeTrieElementRule[] {\n\t\tif (arr.length === 1) {\n\t\t\treturn arr;\n\t\t}\n\n\t\tarr.sort(this._cmpBySpecificity);\n\n\t\treturn arr;\n\t}\n\n\tprivate static _cmpBySpecificity(a: ThemeTrieElementRule, b: ThemeTrieElementRule): number {\n\t\tif (a.scopeDepth === b.scopeDepth) {\n\t\t\tconst aParentScopes = a.parentScopes;\n\t\t\tconst bParentScopes = b.parentScopes;\n\t\t\tlet aParentScopesLen = aParentScopes === null ? 0 : aParentScopes.length;\n\t\t\tlet bParentScopesLen = bParentScopes === null ? 0 : bParentScopes.length;\n\t\t\tif (aParentScopesLen === bParentScopesLen) {\n\t\t\t\tfor (let i = 0; i < aParentScopesLen; i++) {\n\t\t\t\t\tconst aLen = aParentScopes[i].length;\n\t\t\t\t\tconst bLen = bParentScopes[i].length;\n\t\t\t\t\tif (aLen !== bLen) {\n\t\t\t\t\t\treturn bLen - aLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn bParentScopesLen - aParentScopesLen;\n\t\t}\n\t\treturn b.scopeDepth - a.scopeDepth;\n\t}\n\n\tpublic match(scope: string): ThemeTrieElementRule[] {\n\t\tif (scope === '') {\n\t\t\treturn ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));\n\t\t}\n\n\t\tlet dotIndex = scope.indexOf('.');\n\t\tlet head: string;\n\t\tlet tail: string;\n\t\tif (dotIndex === -1) {\n\t\t\thead = scope;\n\t\t\ttail = '';\n\t\t} else {\n\t\t\thead = scope.substring(0, dotIndex);\n\t\t\ttail = scope.substring(dotIndex + 1);\n\t\t}\n\n\t\tif (this._children.hasOwnProperty(head)) {\n\t\t\treturn this._children[head].match(tail);\n\t\t}\n\n\t\treturn ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));\n\t}\n\n\tpublic insert(scopeDepth: number, scope: string, parentScopes: string[], fontStyle: number, foreground: number, background: number): void {\n\t\tif (scope === '') {\n\t\t\tthis._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);\n\t\t\treturn;\n\t\t}\n\n\t\tlet dotIndex = scope.indexOf('.');\n\t\tlet head: string;\n\t\tlet tail: string;\n\t\tif (dotIndex === -1) {\n\t\t\thead = scope;\n\t\t\ttail = '';\n\t\t} else {\n\t\t\thead = scope.substring(0, dotIndex);\n\t\t\ttail = scope.substring(dotIndex + 1);\n\t\t}\n\n\t\tlet child: ThemeTrieElement;\n\t\tif (this._children.hasOwnProperty(head)) {\n\t\t\tchild = this._children[head];\n\t\t} else {\n\t\t\tchild = new ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));\n\t\t\tthis._children[head] = child;\n\t\t}\n\n\t\tchild.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);\n\t}\n\n\tprivate _doInsertHere(scopeDepth: number, parentScopes: string[], fontStyle: number, foreground: number, background: number): void {\n\n\t\tif (parentScopes === null) {\n\t\t\t// Merge into the main rule\n\t\t\tthis._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n\t\t\treturn;\n\t\t}\n\n\t\t// Try to merge into existing rule\n\t\tfor (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {\n\t\t\tlet rule = this._rulesWithParentScopes[i];\n\n\t\t\tif (strArrCmp(rule.parentScopes, parentScopes) === 0) {\n\t\t\t\t// bingo! => we get to merge this into an existing one\n\t\t\t\trule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Must add a new rule\n\n\t\t// Inherit from main rule\n\t\tif (fontStyle === FontStyle.NotSet) {\n\t\t\tfontStyle = this._mainRule.fontStyle;\n\t\t}\n\t\tif (foreground === 0) {\n\t\t\tforeground = this._mainRule.foreground;\n\t\t}\n\t\tif (background === 0) {\n\t\t\tbackground = this._mainRule.background;\n\t\t}\n\n\t\tthis._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));\n\t}\n}\n","/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport { SyncRegistry } from './registry';\nimport { parseJSONGrammar, parsePLISTGrammar } from './grammarReader';\nimport { Theme } from './theme';\nimport { StackElement as StackElementImpl } from './grammar';\nimport { IGrammarDefinition, IRawGrammar } from './types';\n\nexport { IGrammarDefinition, IRawGrammar }\n\nlet DEFAULT_OPTIONS: RegistryOptions = {\n\tgetGrammarDefinition: (scopeName: string) => null,\n\tgetInjections: (scopeName: string) => null\n};\n\n/**\n * A single theme setting.\n */\nexport interface IRawThemeSetting {\n\treadonly name?: string;\n\treadonly scope?: string | string[];\n\treadonly settings: {\n\t\treadonly fontStyle?: string;\n\t\treadonly foreground?: string;\n\t\treadonly background?: string;\n\t};\n}\n\n/**\n * A TextMate theme.\n */\nexport interface IRawTheme {\n\treadonly name?: string;\n\treadonly settings: IRawThemeSetting[];\n}\n\n/**\n * A registry helper that can locate grammar file paths given scope names.\n */\nexport interface RegistryOptions {\n\ttheme?: IRawTheme;\n\tgetGrammarDefinition(scopeName: string, dependentScope: string): Promise<IGrammarDefinition>;\n\tgetInjections?(scopeName: string): string[];\n}\n\n/**\n * A map from scope name to a language id. Please do not use language id 0.\n */\nexport interface IEmbeddedLanguagesMap {\n\t[scopeName: string]: number;\n}\n\n/**\n * A map from selectors to token types.\n */\nexport interface ITokenTypeMap {\n\t[selector: string]: StandardTokenType;\n}\n\nexport const enum StandardTokenType {\n\tOther = 0,\n\tComment = 1,\n\tString = 2,\n\tRegEx = 4\n}\n\nexport interface IGrammarConfiguration {\n\tembeddedLanguages?: IEmbeddedLanguagesMap;\n\ttokenTypes?: ITokenTypeMap;\n}\n\n/**\n * The registry that will hold all grammars.\n */\nexport class Registry {\n\n\tprivate readonly _locator: RegistryOptions;\n\tprivate readonly _syncRegistry: SyncRegistry;\n\tprivate readonly installationQueue: Map<string, Promise<IGrammar>>;\n\n\tconstructor(locator: RegistryOptions = DEFAULT_OPTIONS) {\n\t\tthis._locator = locator;\n\t\tthis._syncRegistry = new SyncRegistry(Theme.createFromRawTheme(locator.theme));\n\t\tthis.installationQueue = new Map();\n\t}\n\n\t/**\n\t * Change the theme. Once called, no previous `ruleStack` should be used anymore.\n\t */\n\tpublic setTheme(theme: IRawTheme): void {\n\t\tthis._syncRegistry.setTheme(Theme.createFromRawTheme(theme));\n\t}\n\n\t/**\n\t * Returns a lookup array for color ids.\n\t */\n\tpublic getColorMap(): string[] {\n\t\treturn this._syncRegistry.getColorMap();\n\t}\n\n\t/**\n\t * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n\t * Please do not use language id 0.\n\t */\n\tpublic loadGrammarWithEmbeddedLanguages(initialScopeName: string, initialLanguage: number, embeddedLanguages: IEmbeddedLanguagesMap): Promise<IGrammar> {\n\t\treturn this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages });\n\t}\n\n\t/**\n\t * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n\t * Please do not use language id 0.\n\t */\n\tpublic async loadGrammarWithConfiguration(initialScopeName: string, initialLanguage: number, configuration: IGrammarConfiguration): Promise<IGrammar> {\n\t\tawait this._loadGrammar(initialScopeName);\n\t\treturn this.grammarForScopeName(initialScopeName, initialLanguage, configuration.embeddedLanguages, configuration.tokenTypes);\n\t}\n\n\t/**\n\t * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n\t */\n\tpublic async loadGrammar(initialScopeName: string): Promise<IGrammar> {\n\t\treturn this._loadGrammar(initialScopeName);\n\t}\n\n\tprivate async _loadGrammar(initialScopeName: string, dependentScope: string = null): Promise<IGrammar> {\n\n\t\t// already installed\n\t\tif (this._syncRegistry.lookup(initialScopeName)) {\n\t\t\treturn this.grammarForScopeName(initialScopeName);\n\t\t}\n\t\t// installation in progress\n\t\tif (this.installationQueue.has(initialScopeName)) {\n\t\t\treturn this.installationQueue.get(initialScopeName);\n\t\t}\n\t\t// start installation process\n\t\tconst prom = new Promise<IGrammar>(async (resolve, reject) => {\n\t\t\tlet grammarDefinition = await this._locator.getGrammarDefinition(initialScopeName, dependentScope);\n\t\t\tif (!grammarDefinition) {\n\t\t\t\tthrow new Error(`A tmGrammar load was requested but registry host failed to provide grammar definition`);\n\t\t\t}\n\t\t\tif ((grammarDefinition.format !== 'json' && grammarDefinition.format !== 'plist') ||\n\t\t\t\t(grammarDefinition.format === 'json' && typeof grammarDefinition.content !== 'object' && typeof grammarDefinition.content !== 'string') ||\n\t\t\t\t(grammarDefinition.format === 'plist' && typeof grammarDefinition.content !== 'string')\n\t\t\t) {\n\t\t\t\tthrow new TypeError('Grammar definition must be an object, either `{ content: string | object, format: \"json\" }` OR `{ content: string, format: \"plist\" }`)');\n\t\t\t}\n\t\t\tconst rawGrammar: IRawGrammar = grammarDefinition.format === 'json'\n\t\t\t\t? typeof grammarDefinition.content === 'string'\n\t\t\t\t\t? parseJSONGrammar(grammarDefinition.content, 'c://fakepath/grammar.json')\n\t\t\t\t\t: grammarDefinition.content as IRawGrammar\n\t\t\t\t: parsePLISTGrammar(grammarDefinition.content as string, 'c://fakepath/grammar.plist');\n\t\t\tlet injections = (typeof this._locator.getInjections === 'function') && this._locator.getInjections(initialScopeName);\n\n\t\t\t(rawGrammar as any).scopeName = initialScopeName;\n\t\t\tlet deps = this._syncRegistry.addGrammar(rawGrammar, injections);\n\t\t\tawait Promise.all(deps.map(async (scopeNameD) => {\n\t\t\t\ttry {\n\t\t\t\t\treturn this._loadGrammar(scopeNameD, initialScopeName);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new Error(`While trying to load tmGrammar with scopeId: '${initialScopeName}', it's dependency (scopeId: ${scopeNameD}) loading errored: ${error.message}`);\n\t\t\t\t}\n\t\t\t}));\n\t\t\tresolve(this.grammarForScopeName(initialScopeName));\n\t\t});\n\t\tthis.installationQueue.set(initialScopeName, prom);\n\t\tawait prom;\n\t\tthis.installationQueue.delete(initialScopeName);\n\t\treturn prom;\n\t}\n\n\t/**\n\t * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `loadGrammarFromPathSync`.\n\t */\n\tpublic grammarForScopeName(scopeName: string, initialLanguage: number = 0, embeddedLanguages: IEmbeddedLanguagesMap = null, tokenTypes: ITokenTypeMap = null): IGrammar {\n\t\treturn this._syncRegistry.grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes);\n\t}\n}\n\n/**\n * A grammar\n */\nexport interface IGrammar {\n\t/**\n\t * Tokenize `lineText` using previous line state `prevState`.\n\t */\n\ttokenizeLine(lineText: string, prevState: StackElement): ITokenizeLineResult;\n\n\t/**\n\t * Tokenize `lineText` using previous line state `prevState`.\n\t * The result contains the tokens in binary format, resolved with the following information:\n\t *  - language\n\t *  - token type (regex, string, comment, other)\n\t *  - font style\n\t *  - foreground color\n\t *  - background color\n\t * e.g. for getting the languageId: `(metadata & MetadataConsts.LANGUAGEID_MASK) >>> MetadataConsts.LANGUAGEID_OFFSET`\n\t */\n\ttokenizeLine2(lineText: string, prevState: StackElement): ITokenizeLineResult2;\n}\n\nexport interface ITokenizeLineResult {\n\treadonly tokens: IToken[];\n\t/**\n\t * The `prevState` to be passed on to the next line tokenization.\n\t */\n\treadonly ruleStack: StackElement;\n}\n\n/**\n * Helpers to manage the \"collapsed\" metadata of an entire StackElement stack.\n * The following assumptions have been made:\n *  - languageId < 256 => needs 8 bits\n *  - unique color count < 512 => needs 9 bits\n *\n * The binary format is:\n * - -------------------------------------------\n *     3322 2222 2222 1111 1111 1100 0000 0000\n *     1098 7654 3210 9876 5432 1098 7654 3210\n * - -------------------------------------------\n *     xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n *     bbbb bbbb bfff ffff ffFF FTTT LLLL LLLL\n * - -------------------------------------------\n *  - L = LanguageId (8 bits)\n *  - T = StandardTokenType (3 bits)\n *  - F = FontStyle (3 bits)\n *  - f = foreground color (9 bits)\n *  - b = background color (9 bits)\n */\nexport const enum MetadataConsts {\n\tLANGUAGEID_MASK = 0b00000000000000000000000011111111,\n\tTOKEN_TYPE_MASK = 0b00000000000000000000011100000000,\n\tFONT_STYLE_MASK = 0b00000000000000000011100000000000,\n\tFOREGROUND_MASK = 0b00000000011111111100000000000000,\n\tBACKGROUND_MASK = 0b11111111100000000000000000000000,\n\n\tLANGUAGEID_OFFSET = 0,\n\tTOKEN_TYPE_OFFSET = 8,\n\tFONT_STYLE_OFFSET = 11,\n\tFOREGROUND_OFFSET = 14,\n\tBACKGROUND_OFFSET = 23\n}\n\nexport interface ITokenizeLineResult2 {\n\t/**\n\t * The tokens in binary format. Each token occupies two array indices. For token i:\n\t *  - at offset 2*i => startIndex\n\t *  - at offset 2*i + 1 => metadata\n\t *\n\t */\n\treadonly tokens: Uint32Array;\n\t/**\n\t * The `prevState` to be passed on to the next line tokenization.\n\t */\n\treadonly ruleStack: StackElement;\n}\n\nexport interface IToken {\n\tstartIndex: number;\n\treadonly endIndex: number;\n\treadonly scopes: string[];\n}\n\n/**\n * **IMPORTANT** - Immutable!\n */\nexport interface StackElement {\n\t_stackElementBrand: void;\n\treadonly depth: number;\n\n\tclone(): StackElement;\n\tequals(other: StackElement): boolean;\n}\n\nexport const INITIAL: StackElement = StackElementImpl.NULL;\n","'use strict';\n\nclass CancelError extends Error {\n\tconstructor(reason) {\n\t\tsuper(reason || 'Promise was canceled');\n\t\tthis.name = 'CancelError';\n\t}\n\n\tget isCanceled() {\n\t\treturn true;\n\t}\n}\n\nclass PCancelable {\n\tstatic fn(userFn) {\n\t\treturn (...args) => {\n\t\t\treturn new PCancelable((resolve, reject, onCancel) => {\n\t\t\t\targs.push(onCancel);\n\t\t\t\tuserFn(...args).then(resolve, reject);\n\t\t\t});\n\t\t};\n\t}\n\n\tconstructor(executor) {\n\t\tthis._cancelHandlers = [];\n\t\tthis._isPending = true;\n\t\tthis._isCanceled = false;\n\t\tthis._rejectOnCancel = true;\n\n\t\tthis._promise = new Promise((resolve, reject) => {\n\t\t\tthis._reject = reject;\n\n\t\t\tconst onResolve = value => {\n\t\t\t\tthis._isPending = false;\n\t\t\t\tresolve(value);\n\t\t\t};\n\n\t\t\tconst onReject = error => {\n\t\t\t\tthis._isPending = false;\n\t\t\t\treject(error);\n\t\t\t};\n\n\t\t\tconst onCancel = handler => {\n\t\t\t\tthis._cancelHandlers.push(handler);\n\t\t\t};\n\n\t\t\tObject.defineProperties(onCancel, {\n\t\t\t\tshouldReject: {\n\t\t\t\t\tget: () => this._rejectOnCancel,\n\t\t\t\t\tset: bool => {\n\t\t\t\t\t\tthis._rejectOnCancel = bool;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn executor(onResolve, onReject, onCancel);\n\t\t});\n\t}\n\n\tthen(onFulfilled, onRejected) {\n\t\treturn this._promise.then(onFulfilled, onRejected);\n\t}\n\n\tcatch(onRejected) {\n\t\treturn this._promise.catch(onRejected);\n\t}\n\n\tfinally(onFinally) {\n\t\treturn this._promise.finally(onFinally);\n\t}\n\n\tcancel(reason) {\n\t\tif (!this._isPending || this._isCanceled) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._cancelHandlers.length > 0) {\n\t\t\ttry {\n\t\t\t\tfor (const handler of this._cancelHandlers) {\n\t\t\t\t\thandler();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis._reject(error);\n\t\t\t}\n\t\t}\n\n\t\tthis._isCanceled = true;\n\t\tif (this._rejectOnCancel) {\n\t\t\tthis._reject(new CancelError(reason));\n\t\t}\n\t}\n\n\tget isCanceled() {\n\t\treturn this._isCanceled;\n\t}\n}\n\nObject.setPrototypeOf(PCancelable.prototype, Promise.prototype);\n\nmodule.exports = PCancelable;\nmodule.exports.default = PCancelable;\n\nmodule.exports.CancelError = CancelError;\n","var hasOwnProperty = Object.prototype.hasOwnProperty\n\nmodule.exports = PseudoMap\n\nfunction PseudoMap (set) {\n  if (!(this instanceof PseudoMap)) // whyyyyyyy\n    throw new TypeError(\"Constructor PseudoMap requires 'new'\")\n\n  this.clear()\n\n  if (set) {\n    if ((set instanceof PseudoMap) ||\n        (typeof Map === 'function' && set instanceof Map))\n      set.forEach(function (value, key) {\n        this.set(key, value)\n      }, this)\n    else if (Array.isArray(set))\n      set.forEach(function (kv) {\n        this.set(kv[0], kv[1])\n      }, this)\n    else\n      throw new TypeError('invalid argument')\n  }\n}\n\nPseudoMap.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  Object.keys(this._data).forEach(function (k) {\n    if (k !== 'size')\n      fn.call(thisp, this._data[k].value, this._data[k].key)\n  }, this)\n}\n\nPseudoMap.prototype.has = function (k) {\n  return !!find(this._data, k)\n}\n\nPseudoMap.prototype.get = function (k) {\n  var res = find(this._data, k)\n  return res && res.value\n}\n\nPseudoMap.prototype.set = function (k, v) {\n  set(this._data, k, v)\n}\n\nPseudoMap.prototype.delete = function (k) {\n  var res = find(this._data, k)\n  if (res) {\n    delete this._data[res._index]\n    this._data.size--\n  }\n}\n\nPseudoMap.prototype.clear = function () {\n  var data = Object.create(null)\n  data.size = 0\n\n  Object.defineProperty(this, '_data', {\n    value: data,\n    enumerable: false,\n    configurable: true,\n    writable: false\n  })\n}\n\nObject.defineProperty(PseudoMap.prototype, 'size', {\n  get: function () {\n    return this._data.size\n  },\n  set: function (n) {},\n  enumerable: true,\n  configurable: true\n})\n\nPseudoMap.prototype.values =\nPseudoMap.prototype.keys =\nPseudoMap.prototype.entries = function () {\n  throw new Error('iterators are not implemented in this version')\n}\n\n// Either identical, or both NaN\nfunction same (a, b) {\n  return a === b || a !== a && b !== b\n}\n\nfunction Entry (k, v, i) {\n  this.key = k\n  this.value = v\n  this._index = i\n}\n\nfunction find (data, k) {\n  for (var i = 0, s = '_' + k, key = s;\n       hasOwnProperty.call(data, key);\n       key = s + i++) {\n    if (same(data[key].key, k))\n      return data[key]\n  }\n}\n\nfunction set (data, k, v) {\n  for (var i = 0, s = '_' + k, key = s;\n       hasOwnProperty.call(data, key);\n       key = s + i++) {\n    if (same(data[key].key, k)) {\n      data[key].value = v\n      return\n    }\n  }\n  data.size++\n  data[key] = new Entry(k, v, key)\n}\n","if (process.env.npm_package_name === 'pseudomap' &&\n    process.env.npm_lifecycle_script === 'test')\n  process.env.TEST_PSEUDOMAP = 'true'\n\nif (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {\n  module.exports = Map\n} else {\n  module.exports = require('./pseudomap')\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","module.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n","'use strict'\n\nmodule.exports = LRUCache\n\n// This will be a proper iterable 'Map' in engines that support it,\n// or a fakey-fake PseudoMap in older versions.\nvar Map = require('pseudomap')\nvar util = require('util')\n\n// A linked list to keep track of recently-used-ness\nvar Yallist = require('yallist')\n\n// use symbols if possible, otherwise just _props\nvar hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1'\nvar makeSymbol\nif (hasSymbol) {\n  makeSymbol = function (key) {\n    return Symbol(key)\n  }\n} else {\n  makeSymbol = function (key) {\n    return '_' + key\n  }\n}\n\nvar MAX = makeSymbol('max')\nvar LENGTH = makeSymbol('length')\nvar LENGTH_CALCULATOR = makeSymbol('lengthCalculator')\nvar ALLOW_STALE = makeSymbol('allowStale')\nvar MAX_AGE = makeSymbol('maxAge')\nvar DISPOSE = makeSymbol('dispose')\nvar NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')\nvar LRU_LIST = makeSymbol('lruList')\nvar CACHE = makeSymbol('cache')\n\nfunction naiveLength () { return 1 }\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nfunction LRUCache (options) {\n  if (!(this instanceof LRUCache)) {\n    return new LRUCache(options)\n  }\n\n  if (typeof options === 'number') {\n    options = { max: options }\n  }\n\n  if (!options) {\n    options = {}\n  }\n\n  var max = this[MAX] = options.max\n  // Kind of weird to have a default max of Infinity, but oh well.\n  if (!max ||\n      !(typeof max === 'number') ||\n      max <= 0) {\n    this[MAX] = Infinity\n  }\n\n  var lc = options.length || naiveLength\n  if (typeof lc !== 'function') {\n    lc = naiveLength\n  }\n  this[LENGTH_CALCULATOR] = lc\n\n  this[ALLOW_STALE] = options.stale || false\n  this[MAX_AGE] = options.maxAge || 0\n  this[DISPOSE] = options.dispose\n  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n  this.reset()\n}\n\n// resize the cache when the max changes.\nObject.defineProperty(LRUCache.prototype, 'max', {\n  set: function (mL) {\n    if (!mL || !(typeof mL === 'number') || mL <= 0) {\n      mL = Infinity\n    }\n    this[MAX] = mL\n    trim(this)\n  },\n  get: function () {\n    return this[MAX]\n  },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'allowStale', {\n  set: function (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  },\n  get: function () {\n    return this[ALLOW_STALE]\n  },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'maxAge', {\n  set: function (mA) {\n    if (!mA || !(typeof mA === 'number') || mA < 0) {\n      mA = 0\n    }\n    this[MAX_AGE] = mA\n    trim(this)\n  },\n  get: function () {\n    return this[MAX_AGE]\n  },\n  enumerable: true\n})\n\n// resize the cache when the lengthCalculator changes.\nObject.defineProperty(LRUCache.prototype, 'lengthCalculator', {\n  set: function (lC) {\n    if (typeof lC !== 'function') {\n      lC = naiveLength\n    }\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(function (hit) {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      }, this)\n    }\n    trim(this)\n  },\n  get: function () { return this[LENGTH_CALCULATOR] },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'length', {\n  get: function () { return this[LENGTH] },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'itemCount', {\n  get: function () { return this[LRU_LIST].length },\n  enumerable: true\n})\n\nLRUCache.prototype.rforEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this[LRU_LIST].tail; walker !== null;) {\n    var prev = walker.prev\n    forEachStep(this, fn, walker, thisp)\n    walker = prev\n  }\n}\n\nfunction forEachStep (self, fn, node, thisp) {\n  var hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE]) {\n      hit = undefined\n    }\n  }\n  if (hit) {\n    fn.call(thisp, hit.value, hit.key, self)\n  }\n}\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this[LRU_LIST].head; walker !== null;) {\n    var next = walker.next\n    forEachStep(this, fn, walker, thisp)\n    walker = next\n  }\n}\n\nLRUCache.prototype.keys = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.key\n  }, this)\n}\n\nLRUCache.prototype.values = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.value\n  }, this)\n}\n\nLRUCache.prototype.reset = function () {\n  if (this[DISPOSE] &&\n      this[LRU_LIST] &&\n      this[LRU_LIST].length) {\n    this[LRU_LIST].forEach(function (hit) {\n      this[DISPOSE](hit.key, hit.value)\n    }, this)\n  }\n\n  this[CACHE] = new Map() // hash of items by key\n  this[LRU_LIST] = new Yallist() // list of items in order of use recency\n  this[LENGTH] = 0 // length of items in the list\n}\n\nLRUCache.prototype.dump = function () {\n  return this[LRU_LIST].map(function (hit) {\n    if (!isStale(this, hit)) {\n      return {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }\n    }\n  }, this).toArray().filter(function (h) {\n    return h\n  })\n}\n\nLRUCache.prototype.dumpLru = function () {\n  return this[LRU_LIST]\n}\n\n/* istanbul ignore next */\nLRUCache.prototype.inspect = function (n, opts) {\n  var str = 'LRUCache {'\n  var extras = false\n\n  var as = this[ALLOW_STALE]\n  if (as) {\n    str += '\\n  allowStale: true'\n    extras = true\n  }\n\n  var max = this[MAX]\n  if (max && max !== Infinity) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  max: ' + util.inspect(max, opts)\n    extras = true\n  }\n\n  var maxAge = this[MAX_AGE]\n  if (maxAge) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  maxAge: ' + util.inspect(maxAge, opts)\n    extras = true\n  }\n\n  var lc = this[LENGTH_CALCULATOR]\n  if (lc && lc !== naiveLength) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  length: ' + util.inspect(this[LENGTH], opts)\n    extras = true\n  }\n\n  var didFirst = false\n  this[LRU_LIST].forEach(function (item) {\n    if (didFirst) {\n      str += ',\\n  '\n    } else {\n      if (extras) {\n        str += ',\\n'\n      }\n      didFirst = true\n      str += '\\n  '\n    }\n    var key = util.inspect(item.key).split('\\n').join('\\n  ')\n    var val = { value: item.value }\n    if (item.maxAge !== maxAge) {\n      val.maxAge = item.maxAge\n    }\n    if (lc !== naiveLength) {\n      val.length = item.length\n    }\n    if (isStale(this, item)) {\n      val.stale = true\n    }\n\n    val = util.inspect(val, opts).split('\\n').join('\\n  ')\n    str += key + ' => ' + val\n  })\n\n  if (didFirst || extras) {\n    str += '\\n'\n  }\n  str += '}'\n\n  return str\n}\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || this[MAX_AGE]\n\n  var now = maxAge ? Date.now() : 0\n  var len = this[LENGTH_CALCULATOR](value, key)\n\n  if (this[CACHE].has(key)) {\n    if (len > this[MAX]) {\n      del(this, this[CACHE].get(key))\n      return false\n    }\n\n    var node = this[CACHE].get(key)\n    var item = node.value\n\n    // dispose of the old one before overwriting\n    // split out into 2 ifs for better coverage tracking\n    if (this[DISPOSE]) {\n      if (!this[NO_DISPOSE_ON_SET]) {\n        this[DISPOSE](key, item.value)\n      }\n    }\n\n    item.now = now\n    item.maxAge = maxAge\n    item.value = value\n    this[LENGTH] += len - item.length\n    item.length = len\n    this.get(key)\n    trim(this)\n    return true\n  }\n\n  var hit = new Entry(key, value, len, now, maxAge)\n\n  // oversized objects fall out of cache automatically.\n  if (hit.length > this[MAX]) {\n    if (this[DISPOSE]) {\n      this[DISPOSE](key, value)\n    }\n    return false\n  }\n\n  this[LENGTH] += hit.length\n  this[LRU_LIST].unshift(hit)\n  this[CACHE].set(key, this[LRU_LIST].head)\n  trim(this)\n  return true\n}\n\nLRUCache.prototype.has = function (key) {\n  if (!this[CACHE].has(key)) return false\n  var hit = this[CACHE].get(key).value\n  if (isStale(this, hit)) {\n    return false\n  }\n  return true\n}\n\nLRUCache.prototype.get = function (key) {\n  return get(this, key, true)\n}\n\nLRUCache.prototype.peek = function (key) {\n  return get(this, key, false)\n}\n\nLRUCache.prototype.pop = function () {\n  var node = this[LRU_LIST].tail\n  if (!node) return null\n  del(this, node)\n  return node.value\n}\n\nLRUCache.prototype.del = function (key) {\n  del(this, this[CACHE].get(key))\n}\n\nLRUCache.prototype.load = function (arr) {\n  // reset the cache\n  this.reset()\n\n  var now = Date.now()\n  // A previous serialized cache has the most recent items first\n  for (var l = arr.length - 1; l >= 0; l--) {\n    var hit = arr[l]\n    var expiresAt = hit.e || 0\n    if (expiresAt === 0) {\n      // the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v)\n    } else {\n      var maxAge = expiresAt - now\n      // dont add already expired items\n      if (maxAge > 0) {\n        this.set(hit.k, hit.v, maxAge)\n      }\n    }\n  }\n}\n\nLRUCache.prototype.prune = function () {\n  var self = this\n  this[CACHE].forEach(function (value, key) {\n    get(self, key, false)\n  })\n}\n\nfunction get (self, key, doUse) {\n  var node = self[CACHE].get(key)\n  if (node) {\n    var hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE]) hit = undefined\n    } else {\n      if (doUse) {\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    if (hit) hit = hit.value\n  }\n  return hit\n}\n\nfunction isStale (self, hit) {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE])) {\n    return false\n  }\n  var stale = false\n  var diff = Date.now() - hit.now\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge\n  } else {\n    stale = self[MAX_AGE] && (diff > self[MAX_AGE])\n  }\n  return stale\n}\n\nfunction trim (self) {\n  if (self[LENGTH] > self[MAX]) {\n    for (var walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      var prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nfunction del (self, node) {\n  if (node) {\n    var hit = node.value\n    if (self[DISPOSE]) {\n      self[DISPOSE](hit.key, hit.value)\n    }\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\n// classy, since V8 prefers predictable objects.\nfunction Entry (key, value, length, now, maxAge) {\n  this.key = key\n  this.value = value\n  this.length = length\n  this.now = now\n  this.maxAge = maxAge || 0\n}\n","import * as LRU from 'lru-cache'\nimport { Theme } from 'monaco-textmate/dist/theme'\nimport { ITextmateThemePlus } from '.'\n\nexport enum CmToken {\n    Atom = 'atom',\n    Attribute = 'attribute',\n    Bracket = 'bracket',\n    Builtin = 'builtin',\n    Comment = 'comment',\n    Def = 'def',\n    Error = 'error',\n    Header = 'header',\n    HR = 'hr',\n    Keyword = 'keyword',\n    Link = 'link',\n    Meta = 'meta',\n    Number = 'number',\n    Operator = 'operator',\n    Property = 'property',\n    Qualifier = 'qualifier',\n    Quote = 'quote',\n    String = 'string',\n    String2 = 'string-2',\n    Tag = 'tag',\n    Type = 'type',\n    Variable = 'variable',\n    Variable2 = 'variable-2',\n    Variable3 = 'variable-3',\n}\n\n\n/**\n * Generates css style rules from TM theme\n * Backwards compatible with Codemirror tokens (this theme WILL apply to traditional Codemirror modes)\n */\nexport function cssTextFromTmTheme(rawTheme: ITextmateThemePlus): string {\n    const theme = Theme.createFromRawTheme(rawTheme)\n    const cccmTokenColors = {\n        [CmToken.Atom]: theme.match('constant.language')[0].foreground,\n        [CmToken.Attribute]: theme.match('entity.other.attribute-name')[0].foreground,\n        [CmToken.Bracket]: theme.match('punctuation.definition.tag')[0].foreground,\n        [CmToken.Builtin]: theme.match('support.function')[0].foreground,\n        [CmToken.Comment]: theme.match('comment')[0].foreground,\n        [CmToken.Def]: theme.match('entity.name.function')[0].foreground,\n        [CmToken.Error]: null,\n        [CmToken.Header]: null,\n        [CmToken.HR]: null,\n        [CmToken.Keyword]: theme.match('keyword')[0].foreground,\n        [CmToken.Link]: null,\n        [CmToken.Meta]: theme.match('meta')[0].foreground,\n        [CmToken.Number]: theme.match('constant.numeric')[0].foreground,\n        [CmToken.Operator]: theme.match('keyword.operator')[0].foreground,\n        [CmToken.Property]: theme.match('variable.other.property')[0].foreground,\n        [CmToken.Qualifier]: null,\n        [CmToken.Quote]: null,\n        [CmToken.String]: theme.match('string')[0].foreground,\n        [CmToken.String2]: theme.match('string.regexp')[0].foreground,\n        [CmToken.Tag]: theme.match('entity.name.tag')[0].foreground,\n        [CmToken.Type]: theme.match('storage.type')[0].foreground,\n        [CmToken.Variable]: theme.match('variable.other.object')[0].foreground,\n        [CmToken.Variable2]: theme.match('support.class.builtin')[0].foreground,\n        [CmToken.Variable3]: null,\n    }\n\n    const { name, settings, gutterSettings } = rawTheme\n    const prefix = `.cm-s-${name}`\n    const lines = []\n\n    const { settings: generalSettings } = settings.find((rule) => !rule.scope) || {} as any\n    if (generalSettings) {\n        const { background, caret, foreground, lineHighlight, selection } = generalSettings\n        lines.push(`${prefix}.CodeMirror {`)\n        if (background) {\n            lines.push(`\\tbackground: ${background};`)\n        }\n        if (foreground) {\n            lines.push(`\\tcolor: ${foreground};`)\n        }\n        lines.push('}')\n\n        if (caret) {\n            lines.push(`${prefix} .CodeMirror-cursor { border-left-color: ${caret}; }`)\n        }\n\n        if (lineHighlight) {\n            lines.push(`${prefix} .CodeMirror-activeline-background { background: ${lineHighlight}; }`)\n        }\n\n        if (selection) {\n            lines.push(`${prefix} .CodeMirror-selected { background: ${selection}; }`)\n        }\n    }\n\n    if (gutterSettings) {\n        const { background, divider, foreground, lineActiveBackground, lineActiveForeground } = gutterSettings\n        lines.push(`${prefix} .CodeMirror-gutters {`)\n        if (background) {\n            lines.push(`\\tbackground: ${background};`)\n        }\n        if (divider) {\n            lines.push(`\\tborder-right-color: ${divider};`)\n        }\n        lines.push('}')\n\n        if (foreground) {\n            lines.push(`${prefix} .CodeMirror-linenumber { color: ${foreground}; }`)\n        }\n\n        if (lineActiveBackground) {\n            lines.push(`${prefix} .CodeMirror-activeline .CodeMirror-activeline-gutter { background: ${lineActiveBackground}; }`)\n        }\n\n        if (lineActiveForeground) {\n            lines.push(`${prefix} .CodeMirror-activeline .CodeMirror-linenumber { color: ${lineActiveForeground}; }`)\n        }\n    }\n    const colorMap = theme.getColorMap()\n\n    for (const token in cccmTokenColors) {\n        const colorId = cccmTokenColors[token]\n        if (colorId) {\n            lines.push(`${prefix} .cm-${token} { color: ${colorMap[colorId]} }`)\n        }\n    }\n\n    return lines\n        .concat(...colorMap.map((color, i) => `${prefix} .cm-tm-${i} { color: ${color} }`))\n        .join('\\n')\n}\n\n\nconst tmToCm = {\n    comment: {\n        $: CmToken.Comment,\n    },\n\n    constant: {\n        // TODO: Revision\n        $: CmToken.Def,\n        character: {\n            escape: {\n                $: CmToken.String2,\n            },\n        },\n        language: {\n            $: CmToken.Atom,\n        },\n        numeric: {\n            $: CmToken.Number,\n        },\n        other: {\n            email: {\n                link: {\n                    $: CmToken.Link,\n                },\n            },\n            symbol: {\n                // TODO: Revision\n                $: CmToken.Def,\n            },\n        },\n    },\n\n    entity: {\n        name: {\n            class: {\n                $: CmToken.Def,\n            },\n            function: {\n                $: CmToken.Def,\n            },\n            tag: {\n                $: CmToken.Tag,\n            },\n            type: {\n                $: CmToken.Type,\n                class: {\n                    $: CmToken.Variable,\n                },\n            },\n        },\n        other: {\n            'attribute-name': {\n                $: CmToken.Attribute,\n            },\n            'inherited-class': {\n                // TODO: Revision\n                $: CmToken.Def,\n            },\n        },\n        support: {\n            function: {\n                // TODO: Revision\n                $: CmToken.Def,\n            },\n        },\n    },\n\n    keyword: {\n        $: CmToken.Keyword,\n        operator: {\n            $: CmToken.Operator,\n        },\n        other: {\n            'special-method': CmToken.Def,\n        },\n    },\n    punctuation: {\n        $: CmToken.Operator,\n        definition: {\n            comment: {\n                $: CmToken.Comment,\n            },\n            tag: {\n                $: CmToken.Bracket,\n            },\n            // 'template-expression': {\n            //     $: CodeMirrorToken.Operator,\n            // },\n        },\n        // terminator: {\n        //     $: CodeMirrorToken.Operator,\n        // },\n    },\n\n    storage: {\n        $: CmToken.Keyword,\n    },\n\n    string: {\n        $: CmToken.String,\n        regexp: {\n            $: CmToken.String2,\n        },\n    },\n\n    support: {\n        class: {\n            $: CmToken.Def,\n        },\n        constant: {\n            $: CmToken.Variable2,\n        },\n        function: {\n            $: CmToken.Def,\n        },\n        type: {\n            $: CmToken.Type,\n        },\n        variable: {\n            $: CmToken.Variable2,\n            property: {\n                $: CmToken.Property,\n            },\n        },\n    },\n\n    variable: {\n        $: CmToken.Def,\n        language: {\n            // TODO: Revision\n            $: CmToken.Variable3,\n        },\n        other: {\n            object: {\n                $: CmToken.Variable,\n                property: {\n                    $: CmToken.Property,\n                },\n            },\n            property: {\n                $: CmToken.Property,\n            },\n        },\n        parameter: {\n            $: CmToken.Def,\n        },\n    },\n}\n\nfunction walk(scopeSegments: string[], tree = tmToCm): CmToken {\n    const first = scopeSegments.shift()\n    const node = tree[first]\n    if (node) {\n        return walk(scopeSegments, node) || node.$ || null\n    }\n    return null\n}\n\nconst dotRE = /\\./\nconst cache = new LRU<string, CmToken>({ max: 2000 })\nexport function tmScopeToCmToken(scope: string): CmToken {\n    if (!cache.has(scope)) {\n        cache.set(scope, walk(scope.split(dotRE)))\n    }\n    return cache.get(scope)\n}\n","import { IGrammar, IRawGrammar, IRawTheme, IToken, Registry, StackElement } from 'monaco-textmate'\nimport { Theme } from 'monaco-textmate/dist/theme'\nimport { tmScopeToCmToken, cssTextFromTmTheme } from './tmToCm'\nimport { ITextmateThemePlus } from '.';\n\nexport type IRawGrammarSource = IRawGrammar | Promise<IRawGrammar> | ((scopeName: string) => IRawGrammar | Promise<IRawGrammar>)\n\nexport interface IHighlighterState {\n    ruleStack: StackElement\n    tokensCache: IToken[]\n}\n\nconst requestIdle = (ms = 10000) => new Promise<void>((res) => {\n    if ('requestIdleCallback' in window) {\n        (window as any).requestIdleCallback(res, { timeout: ms })\n    } else {\n        setTimeout(res, ms)\n    }\n})\n\nclass Highlighter {\n    public static addGrammar(scopeName: string, grammar: IRawGrammarSource): void {\n        Highlighter.scopeNameToRawGrammars.set(scopeName, grammar)\n    }\n\n    /**\n     * Inject grammars\n     * @param scopeName Scope name to inject\n     * @param injectInto List of host scope names who will suffer the injection\n     */\n    public static linkInjections(scopeName: string, injectInto: string[]) {\n        if (!Array.isArray(injectInto) || !injectInto.every((scope) => typeof scope === 'string')) {\n            throw new TypeError(`Second argument to 'linkInjections' must be an array of strings (scope names)`)\n        }\n        const affectedLanguages = new Set<string>()\n        injectInto.forEach((scope) => {\n            if (Highlighter.scopeNameToInjections.has(scope)) {\n                Highlighter.scopeNameToInjections.get(scope).add(scopeName)\n            } else {\n                Highlighter.scopeNameToInjections.set(scope, new Set().add(scopeName))\n            }\n            if (Highlighter.scopeNameToLanguageId.has(scope)) {\n                affectedLanguages.add(Highlighter.scopeNameToLanguageId.get(scope))\n            }\n        })\n        // Purge existing registry\n        Highlighter.registry = null\n        return Array.from(affectedLanguages)\n    }\n\n    /**\n     * Uninject grammars\n     * @param scopeName Previously injected scope name to uninject\n     * @param injections If provided injected scope name will be uninjected only from this list of host scope names, otherwise will be uninjected from all\n     */\n    public static unlinkInjections(scopeName: string, injections?: string[]) {\n        if (!Highlighter.scopeNameToInjections.has(scopeName)) {\n            return\n        }\n        const affectedLanguages = new Set<string>()\n        if (!injections) {\n            Highlighter.scopeNameToInjections.forEach((injectionList, hostScopeName) => {\n                if (injectionList.has(scopeName)) {\n                    if (Highlighter.scopeNameToLanguageId.has(hostScopeName)) {\n                        affectedLanguages.add(Highlighter.scopeNameToLanguageId.get(hostScopeName))\n                    }\n                    injectionList.delete(scopeName)\n                }\n            })\n        } else if (!Array.isArray(injections) || !injections.every((scope) => typeof scope === 'string')) {\n            throw new TypeError(`Second argument to 'linkInjections' must be an array of strings (scope names)`)\n        } else {\n            Highlighter.scopeNameToInjections.forEach((injectionList, hostScopeName) => {\n                if (injections.indexOf(hostScopeName) > -1 && injectionList.has(scopeName)) {\n                    if (Highlighter.scopeNameToLanguageId.has(hostScopeName)) {\n                        affectedLanguages.add(Highlighter.scopeNameToLanguageId.get(hostScopeName))\n                    }\n                    injectionList.delete(scopeName)\n                }\n            })\n        }\n        // Purge existing registry\n        Highlighter.registry = null\n        return Array.from(affectedLanguages)\n    }\n\n    public static async activateLanguage(scopeName: string, languageId: string, load: 'now' | 'asap' | 'defer' = 'defer'): Promise<boolean> {\n        if (!Highlighter.scopeNameToRawGrammars.has(scopeName)) {\n            throw new Error(`'${scopeName}' doesn't have a grammar registered. Use addGrammar to register grammar for itself and it's dependencies`)\n        }\n\n        if (Highlighter.languageIdToScopeName.has(languageId)) {\n            throw new Error(`Language with ID '${languageId}' is already bound to '${Highlighter.languageIdToScopeName.get(languageId)}'. Overwrite not allowed`)\n        }\n\n        Highlighter.languageIdToScopeName.set(languageId, scopeName)\n        Highlighter.scopeNameToLanguageId.set(scopeName, languageId)\n        if (load === 'now') {\n            await Highlighter.loadLanguage(languageId)\n            return true\n        }\n        if (load === 'asap') {\n            await requestIdle()\n            await Highlighter.loadLanguage(languageId)\n            return true\n        }\n        return false\n    }\n\n    public static loadLanguage(languageId: string): Promise<IGrammar> {\n        const scopeName = Highlighter.languageIdToScopeName.get(languageId)\n        if (!scopeName || !Highlighter.scopeNameToRawGrammars.has(scopeName)) {\n            return null\n        }\n        if (!Highlighter.registry) {\n            Highlighter.initRegistry()\n        }\n        return Highlighter.registry.loadGrammar(scopeName)\n    }\n\n    public static hasLanguageRegistered(languageId: string) {\n        return Highlighter.languageIdToScopeName.has(languageId)\n    }\n\n    private static scopeNameToInjections: Map<string, Set<string>> = new Map()\n    private static scopeNameToRawGrammars: Map<string, IRawGrammarSource> = new Map()\n    private static scopeNameToLanguageId: Map<string, string> = new Map()\n    private static languageIdToScopeName: Map<string, string> = new Map()\n    private static registry: Registry\n\n    private static initRegistry() {\n        Highlighter.registry = new Registry({\n            async getGrammarDefinition(scopeName: string, dependentScope: string) {\n                if (!Highlighter.scopeNameToRawGrammars.has(scopeName)) {\n                    throw new Error(`Grammar for scope '${scopeName}' not found.${dependentScope ? ` It is a dependency of ${dependentScope}. ` : ''} Use addGrammar to register one.`)\n                }\n\n                let grammar = Highlighter.scopeNameToRawGrammars.get(scopeName)\n                if (typeof grammar === 'function') {\n                    grammar = grammar(scopeName)\n                    Highlighter.scopeNameToRawGrammars.set(scopeName, grammar)\n                }\n\n                if (grammar instanceof Promise) {\n                    grammar = await grammar\n                    Highlighter.scopeNameToRawGrammars.set(scopeName, grammar)\n                }\n\n                if (grammar !== null && typeof grammar === 'object') {\n                    return {\n                        content: grammar as IRawGrammar,\n                        format: 'json' as any,\n                    }\n                }\n                return null\n            },\n            getInjections(scopeName: string): string[] {\n                if (Highlighter.scopeNameToInjections.has(scopeName)) {\n                    return Array.from(Highlighter.scopeNameToInjections.get(scopeName))\n                }\n            },\n        })\n    }\n\n    private rawTheme: ITextmateThemePlus\n    private theme: Theme\n    private cachedCssText: string\n\n    constructor(theme?: ITextmateThemePlus) {\n        if (theme) {\n            if (typeof theme.name !== 'string') {\n                throw new TypeError(`Theme object must have 'name' property for referencing purposes`)\n            }\n            this.rawTheme = theme\n            this.theme = Theme.createFromRawTheme(theme)\n        }\n    }\n\n    public get cssText() {\n        if (!this.cachedCssText) {\n            this.cachedCssText = cssTextFromTmTheme(this.rawTheme)\n        }\n        return this.cachedCssText\n    }\n\n    public async getTokenizer(languageId: string) {\n        const grammar = await Highlighter.loadLanguage(languageId)\n        return (stream: CodeMirror.StringStream, state: IHighlighterState): string => {\n            const { pos, string: str } = stream\n            if (pos === 0) {\n                const { ruleStack, tokens } = grammar.tokenizeLine(str, state.ruleStack)\n                state.tokensCache = tokens.slice()\n                state.ruleStack = ruleStack\n            }\n\n            const { tokensCache } = state\n            const nextToken = tokensCache.shift()\n            if (!nextToken) {\n                stream.skipToEnd()\n                return null\n            }\n            const { endIndex, scopes } = nextToken\n            stream.eatWhile(() => stream.pos < endIndex)\n\n            return this.theme\n                ? this.tmScopeToTmThemeToken(scopes)\n                : this.tmScopeToCmToken(scopes)\n        }\n    }\n\n    private tmScopeToCmToken(scopes: string[]): string {\n        let i = scopes.length - 1\n        let cmToken = null\n        do {\n            cmToken = tmScopeToCmToken(scopes[i--])\n        } while (!cmToken && i >= 0)\n        return cmToken\n    }\n\n    private tmScopeToTmThemeToken(scopes: string[]): string {\n        let i = scopes.length - 1\n        let cmToken = null\n        do {\n            const { foreground, fontStyle } = this.theme.match(scopes[i--])[0]\n            if (foreground > 0) {\n                cmToken = `tm-${foreground}`\n                cmToken = fontStyle === 0\n                    ? cmToken\n                    : fontStyle === 1\n                        ? cmToken + ' em'\n                        : fontStyle === 2\n                            ? cmToken + ' strong'\n                            : cmToken\n            }\n        } while (!cmToken && i >= 0)\n        return cmToken\n    }\n}\n\nexport { Highlighter }\n","import 'regenerator-runtime/runtime';\nimport CodeMirror from 'codemirror';\nimport { activateLanguage, addGrammar } from 'codemirror-textmate';\nimport { loadWASM } from 'onigasm';\n \nasync function run() {\n    await loadWASM('onigasm.wasm');\n\n    const scopeName = 'source.racket';\n    addGrammar(scopeName, async () => (await fetch(`racket.tmLanguage.json`)).json())\n    await activateLanguage(scopeName, 'racket', 'now');\n \n    const editor = CodeMirror.fromTextArea(document.getElementById('cm-host'), {\n        lineNumbers: true,\n        mode: 'racket',\n    });\n    console.log(editor);\n}\n\nrun();"]}